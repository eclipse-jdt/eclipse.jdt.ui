From e6127eea5ab93d807f68215d66c59b67de9af0ef Mon Sep 17 00:00:00 2001
From: Jeff Johnston <jjohnstn@redhat.com>
Date: Wed, 4 Jan 2023 15:45:02 -0500
Subject: [PATCH 1/2] Add bcoview plug-ins to jdt.ui

---
 org.eclipse.jdt.bcoview.feature/.project           |   11 +
 org.eclipse.jdt.bcoview.feature/build.properties   |    1 +
 org.eclipse.jdt.bcoview.feature/feature.xml        |   49 +
 org.eclipse.jdt.bcoview.tests/.classpath           |    8 +
 org.eclipse.jdt.bcoview.tests/.gitignore           |    6 +
 org.eclipse.jdt.bcoview.tests/.project             |   28 +
 .../.settings/org.eclipse.jdt.core.prefs           |    8 +
 org.eclipse.jdt.bcoview.tests/META-INF/MANIFEST.MF |   11 +
 org.eclipse.jdt.bcoview.tests/build.properties     |    1 +
 org.eclipse.jdt.bcoview.tests/src/inner/Anon1.java |  113 ++
 .../src/inner/Anon1_1.java                         |  125 ++
 org.eclipse.jdt.bcoview.tests/src/inner/Anon2.java |   91 +
 org.eclipse.jdt.bcoview.tests/src/inner/Anon3.java |  140 ++
 .../src/inner/Anon3_3.java                         |  156 ++
 org.eclipse.jdt.bcoview.tests/src/inner/Anon4.java |  121 ++
 org.eclipse.jdt.bcoview.tests/src/inner/Anon5.java |  141 ++
 .../src/org/eclipse/jdt/bcoview/AllTests.java      |   34 +
 .../jdt/bcoview/ui/TestJdk14Compatibility.java     |   56 +
 .../jdt/bcoview/ui/TestJdk15Compatibility.java     |   56 +
 .../org/eclipse/jdt/bcoview/ui/TestJdtUtils.java   |  462 +++++
 org.eclipse.jdt.bcoview/.classpath                 |   17 +
 org.eclipse.jdt.bcoview/.gitignore                 |    6 +
 org.eclipse.jdt.bcoview/.options                   |    1 +
 org.eclipse.jdt.bcoview/.project                   |   34 +
 .../.settings/edu.umd.cs.findbugs.core.prefs       |  171 ++
 .../.settings/org.eclipse.jdt.core.prefs           |  401 ++++
 .../.settings/org.eclipse.jdt.ui.prefs             |  136 ++
 org.eclipse.jdt.bcoview/LICENSE.txt                |  277 +++
 org.eclipse.jdt.bcoview/META-INF/MANIFEST.MF       |   33 +
 org.eclipse.jdt.bcoview/README.txt                 |   58 +
 org.eclipse.jdt.bcoview/about.html                 |   36 +
 org.eclipse.jdt.bcoview/about.ini                  |   14 +
 org.eclipse.jdt.bcoview/about.properties           |    5 +
 org.eclipse.jdt.bcoview/about32.png                |  Bin 0 -> 409 bytes
 org.eclipse.jdt.bcoview/asm-build.properties       |    1 +
 org.eclipse.jdt.bcoview/build.properties           |   18 +
 org.eclipse.jdt.bcoview/findbugsExclude.xml        |   19 +
 org.eclipse.jdt.bcoview/icons/asm.gif              |  Bin 0 -> 253 bytes
 org.eclipse.jdt.bcoview/icons/bytecodeview.gif     |  Bin 0 -> 373 bytes
 org.eclipse.jdt.bcoview/icons/hex_mode.gif         |  Bin 0 -> 144 bytes
 org.eclipse.jdt.bcoview/icons/hide_line_info.gif   |  Bin 0 -> 97 bytes
 org.eclipse.jdt.bcoview/icons/hide_locals.gif      |  Bin 0 -> 152 bytes
 org.eclipse.jdt.bcoview/icons/link_with_editor.gif |  Bin 0 -> 160 bytes
 org.eclipse.jdt.bcoview/icons/raw_mode.gif         |  Bin 0 -> 351 bytes
 org.eclipse.jdt.bcoview/icons/reference.gif        |  Bin 0 -> 242 bytes
 org.eclipse.jdt.bcoview/icons/selected_only.gif    |  Bin 0 -> 379 bytes
 org.eclipse.jdt.bcoview/icons/source.gif           |  Bin 0 -> 582 bytes
 org.eclipse.jdt.bcoview/icons/stackmap.gif         |  Bin 0 -> 104 bytes
 org.eclipse.jdt.bcoview/icons/stackmapexp.gif      |  Bin 0 -> 114 bytes
 org.eclipse.jdt.bcoview/icons/th_automatic.gif     |  Bin 0 -> 358 bytes
 org.eclipse.jdt.bcoview/icons/th_horizontal.gif    |  Bin 0 -> 374 bytes
 org.eclipse.jdt.bcoview/icons/th_vertical.gif      |  Bin 0 -> 352 bytes
 org.eclipse.jdt.bcoview/icons/verify.gif           |  Bin 0 -> 374 bytes
 org.eclipse.jdt.bcoview/plugin.xml                 |  177 ++
 org.eclipse.jdt.bcoview/raw_images/asm.psd         |  Bin 0 -> 361560 bytes
 org.eclipse.jdt.bcoview/site/feature.xml           |   49 +
 org.eclipse.jdt.bcoview/site/site.xml              |   47 +
 .../eclipse/jdt/bcoview/BytecodeOutlinePlugin.java |  143 ++
 .../BytecodeOutlinePluginResources.properties      |  102 +
 .../bcoview/asm/CommentedASMifierClassVisitor.java |  348 ++++
 .../jdt/bcoview/asm/CommentedClassVisitor.java     |  601 ++++++
 .../eclipse/jdt/bcoview/asm/DecompiledClass.java   |  441 +++++
 .../jdt/bcoview/asm/DecompiledClassInfo.java       |   27 +
 .../eclipse/jdt/bcoview/asm/DecompiledMethod.java  |  635 +++++++
 .../eclipse/jdt/bcoview/asm/DecompilerHelper.java  |   85 +
 .../eclipse/jdt/bcoview/asm/DecompilerOptions.java |   36 +
 .../jdt/bcoview/asm/ICommentedClassVisitor.java    |   22 +
 .../src/org/eclipse/jdt/bcoview/asm/Index.java     |   32 +
 .../org/eclipse/jdt/bcoview/asm/JavaVersion.java   |   48 +
 .../src/org/eclipse/jdt/bcoview/asm/LineRange.java |   25 +
 .../jdt/bcoview/compare/BytecodeCompare.java       |  298 +++
 .../eclipse/jdt/bcoview/compare/TypedElement.java  |  155 ++
 .../jdt/bcoview/preferences/BCOConstants.java      |  145 ++
 .../preferences/BCOPreferenceInitializer.java      |   56 +
 .../jdt/bcoview/preferences/BCOPreferencePage.java |  179 ++
 .../org/eclipse/jdt/bcoview/ui/EclipseUtils.java   |  124 ++
 .../src/org/eclipse/jdt/bcoview/ui/JdtUtils.java   | 1500 +++++++++++++++
 .../org/eclipse/jdt/bcoview/ui/TypeFactory.java    |  391 ++++
 .../jdt/bcoview/ui/actions/BytecodeAction.java     |  144 ++
 .../bcoview/ui/actions/CompareBytecodeAction.java  |   33 +
 .../ui/actions/CompareMemberBytecodeAction.java    |   66 +
 .../bcoview/ui/actions/DefaultToggleAction.java    |  114 ++
 .../eclipse/jdt/bcoview/ui/actions/OpenAction.java |  100 +
 .../ui/actions/OpenBytecodeReferenceAction.java    |   65 +
 .../bcoview/views/BCOViewSelectionProvider.java    |  111 ++
 .../jdt/bcoview/views/BytecodeOutlineView.java     | 1967 ++++++++++++++++++++
 .../jdt/bcoview/views/BytecodeReferenceView.java   |  194 ++
 .../eclipse/jdt/bcoview/views/EditorListener.java  |  265 +++
 .../org/eclipse/jdt/bcoview/views/HelpUtils.java   |  192 ++
 .../eclipse/jdt/bcoview/views/IBytecodePart.java   |   18 +
 pom.xml                                            |    3 +
 91 files changed, 11783 insertions(+)
 create mode 100644 org.eclipse.jdt.bcoview.feature/.project
 create mode 100644 org.eclipse.jdt.bcoview.feature/build.properties
 create mode 100644 org.eclipse.jdt.bcoview.feature/feature.xml
 create mode 100644 org.eclipse.jdt.bcoview.tests/.classpath
 create mode 100644 org.eclipse.jdt.bcoview.tests/.gitignore
 create mode 100644 org.eclipse.jdt.bcoview.tests/.project
 create mode 100644 org.eclipse.jdt.bcoview.tests/.settings/org.eclipse.jdt.core.prefs
 create mode 100644 org.eclipse.jdt.bcoview.tests/META-INF/MANIFEST.MF
 create mode 100644 org.eclipse.jdt.bcoview.tests/build.properties
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon1.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon1_1.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon2.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon3.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon3_3.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon4.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/inner/Anon5.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/AllTests.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk14Compatibility.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk15Compatibility.java
 create mode 100644 org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdtUtils.java
 create mode 100644 org.eclipse.jdt.bcoview/.classpath
 create mode 100644 org.eclipse.jdt.bcoview/.gitignore
 create mode 100644 org.eclipse.jdt.bcoview/.options
 create mode 100644 org.eclipse.jdt.bcoview/.project
 create mode 100644 org.eclipse.jdt.bcoview/.settings/edu.umd.cs.findbugs.core.prefs
 create mode 100644 org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.core.prefs
 create mode 100644 org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.ui.prefs
 create mode 100644 org.eclipse.jdt.bcoview/LICENSE.txt
 create mode 100644 org.eclipse.jdt.bcoview/META-INF/MANIFEST.MF
 create mode 100644 org.eclipse.jdt.bcoview/README.txt
 create mode 100644 org.eclipse.jdt.bcoview/about.html
 create mode 100644 org.eclipse.jdt.bcoview/about.ini
 create mode 100644 org.eclipse.jdt.bcoview/about.properties
 create mode 100644 org.eclipse.jdt.bcoview/about32.png
 create mode 100644 org.eclipse.jdt.bcoview/asm-build.properties
 create mode 100644 org.eclipse.jdt.bcoview/build.properties
 create mode 100644 org.eclipse.jdt.bcoview/findbugsExclude.xml
 create mode 100644 org.eclipse.jdt.bcoview/icons/asm.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/bytecodeview.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/hex_mode.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/hide_line_info.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/hide_locals.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/link_with_editor.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/raw_mode.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/reference.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/selected_only.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/source.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/stackmap.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/stackmapexp.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/th_automatic.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/th_horizontal.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/th_vertical.gif
 create mode 100644 org.eclipse.jdt.bcoview/icons/verify.gif
 create mode 100644 org.eclipse.jdt.bcoview/plugin.xml
 create mode 100644 org.eclipse.jdt.bcoview/raw_images/asm.psd
 create mode 100644 org.eclipse.jdt.bcoview/site/feature.xml
 create mode 100644 org.eclipse.jdt.bcoview/site/site.xml
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePlugin.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePluginResources.properties
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedASMifierClassVisitor.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedClassVisitor.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClass.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClassInfo.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledMethod.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerHelper.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerOptions.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/ICommentedClassVisitor.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/Index.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/JavaVersion.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/LineRange.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/BytecodeCompare.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/TypedElement.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOConstants.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferenceInitializer.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferencePage.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/EclipseUtils.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/JdtUtils.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/TypeFactory.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/BytecodeAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareBytecodeAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareMemberBytecodeAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/DefaultToggleAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenBytecodeReferenceAction.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BCOViewSelectionProvider.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeOutlineView.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeReferenceView.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/EditorListener.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/HelpUtils.java
 create mode 100644 org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/IBytecodePart.java

diff --git a/org.eclipse.jdt.bcoview.feature/.project b/org.eclipse.jdt.bcoview.feature/.project
new file mode 100644
index 0000000..2a38fee
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.feature/.project
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.jdt.bcoview.feature</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+	</buildSpec>
+	<natures>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.bcoview.feature/build.properties b/org.eclipse.jdt.bcoview.feature/build.properties
new file mode 100644
index 0000000..82ab19c
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.feature/build.properties
@@ -0,0 +1 @@
+bin.includes = feature.xml
diff --git a/org.eclipse.jdt.bcoview.feature/feature.xml b/org.eclipse.jdt.bcoview.feature/feature.xml
new file mode 100644
index 0000000..fb6bb35
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.feature/feature.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<feature
+      id="org.eclipse.jdt.bcoview.feature"
+      label="Bytecode Outline"
+      version="1.0.1.qualifier"
+      provider-name="Andrey Loskutov"
+      plugin="org.eclipse.jdt.bcoview">
+
+   <description url="https://github.com/iloveeclipse/bytecodeoutline/wiki">
+      Bytecode outline and bytecode comparison view for java/class files.
+   </description>
+
+   <copyright url="..">
+      Copyright (c) 2004-2020 by Andrey Loskutov Loskutov@gmx.de
+   All rights reserved.
+   </copyright>
+
+   <license url="https://www.eclipse.org/legal/epl-2.0/">
+      Copyright (c) 2004 - 2020 Andrey Loskutov, licensed under the Eclipse Public License 2.0.
+   </license>
+
+   <url>
+      <update label="Andrey Loskutov Eclipse plugins" url="https://raw.githubusercontent.com/iloveeclipse/plugins/latest/"/>
+   </url>
+
+   <requires>
+      <import plugin="org.eclipse.ui"/>
+      <import plugin="org.eclipse.ui.editors"/>
+      <import plugin="org.eclipse.core.runtime"/>
+      <import plugin="org.eclipse.jface.text"/>
+      <import plugin="org.eclipse.ui.workbench.texteditor"/>
+      <import plugin="org.eclipse.jdt.ui"/>
+      <import plugin="org.eclipse.ui.ide"/>
+      <import plugin="org.eclipse.compare"/>
+      <import plugin="org.eclipse.ui.console"/>
+      <import plugin="org.eclipse.help.base"/>
+      <import plugin="org.eclipse.debug.ui"/>
+      <import plugin="org.eclipse.jdt.debug"/>
+      <import plugin="org.eclipse.jdt.core" version="3.6.0" match="greaterOrEqual"/>
+   </requires>
+
+   <plugin
+         id="org.eclipse.jdt.bcoview"
+         download-size="710"
+         install-size="710"
+         version="0.0.0"
+         unpack="false"/>
+
+</feature>
diff --git a/org.eclipse.jdt.bcoview.tests/.classpath b/org.eclipse.jdt.bcoview.tests/.classpath
new file mode 100644
index 0000000..eb371e7
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/.classpath
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry excluding="src/" kind="src" path=""/>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.bcoview.tests/.gitignore b/org.eclipse.jdt.bcoview.tests/.gitignore
new file mode 100644
index 0000000..9bde11d
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/.gitignore
@@ -0,0 +1,6 @@
+output
+doc
+.fbwarnings
+/bin/
+/bin_tests/
+/lib/
diff --git a/org.eclipse.jdt.bcoview.tests/.project b/org.eclipse.jdt.bcoview.tests/.project
new file mode 100644
index 0000000..70c1a46
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/.project
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.jdt.bcoview.tests</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.bcoview.tests/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.bcoview.tests/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..9f6ece8
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,8 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.release=disabled
+org.eclipse.jdt.core.compiler.source=1.8
diff --git a/org.eclipse.jdt.bcoview.tests/META-INF/MANIFEST.MF b/org.eclipse.jdt.bcoview.tests/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..220ec2f
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/META-INF/MANIFEST.MF
@@ -0,0 +1,11 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: Tests
+Bundle-SymbolicName: org.eclipse.jdt.bcoview.tests
+Bundle-Version: 1.0.0.qualifier
+Require-Bundle: org.eclipse.core.runtime,
+ org.eclipse.equinox.registry,
+ org.eclipse.jdt.core,
+ org.eclipse.core.resources,
+ org.eclipse.jdt.bcoview;bundle-version="1.0.1",
+ org.junit
diff --git a/org.eclipse.jdt.bcoview.tests/build.properties b/org.eclipse.jdt.bcoview.tests/build.properties
new file mode 100644
index 0000000..5f22cdd
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/build.properties
@@ -0,0 +1 @@
+bin.includes = META-INF/
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon1.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon1.java
new file mode 100644
index 0000000..7753367
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon1.java
@@ -0,0 +1,113 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon1 {
+    final static String v15 = "Anon1";
+    final static String v14 = "Anon1";
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon1$3";
+            final static String v14 = "Anon1$11";
+        };
+        new Object() {
+            final static String v15 = "Anon1$4";
+            final static String v14 = "Anon1$12";
+        };
+    }
+
+    Anon1() {
+        new Object() {
+            final static String v15 = "Anon1$5";
+            final static String v14 = "Anon1$13";
+        };
+        new Object() {
+            final static String v15 = "Anon1$6";
+            final static String v14 = "Anon1$14";
+        };
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon1$7";
+            final static String v14 = "Anon1$15";
+        };
+        new Object() {
+            final static String v15 = "Anon1$8";
+            final static String v14 = "Anon1$16";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon1$1";
+            final static String v14 = "Anon1$1";
+        };
+
+        new Object() {
+            final static String v15 = "Anon1$2";
+            final static String v14 = "Anon1$2";
+        };
+    }
+
+    static class A2 {
+        final static String v15 = "Anon1$A2";
+        final static String v14 = "Anon1$A2";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon1$A2$5";
+                final static String v14 = "Anon1$7";
+            };
+            new Object() {
+                final static String v15 = "Anon1$A2$6";
+                final static String v14 = "Anon1$8";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon1$A2$1";
+                final static String v14 = "Anon1$3";
+            };
+            new Object() {
+                final static String v15 = "Anon1$A2$2";
+                final static String v14 = "Anon1$4";
+            };
+        }
+
+        static void staticMethod() {
+            new Object() {
+                final static String v15 = "Anon1$A2$7";
+                final static String v14 = "Anon1$9";
+            };
+            new Object() {
+                final static String v15 = "Anon1$A2$8";
+                final static String v14 = "Anon1$10";
+            };
+        }
+
+        static {
+            new Object() {
+                final static String v15 = "Anon1$A2$3";
+                final static String v14 = "Anon1$5";
+            };
+            new Object() {
+                final static String v15 = "Anon1$A2$4";
+                final static String v14 = "Anon1$6";
+            };
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon1_1.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon1_1.java
new file mode 100644
index 0000000..39b3961
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon1_1.java
@@ -0,0 +1,125 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon1_1 {
+    final static String v15 = "Anon1_1";
+    final static String v14 = "Anon1_1";
+
+    static {
+        new Object() {
+            final static String v15 = "Anon1_1$1";
+            final static String v14 = "Anon1_1$1";
+        };
+    }
+
+    Anon1_1() {
+        new Object() {
+            final static String v15 = "Anon1_1$4";
+            final static String v14 = "Anon1_1$12";
+        };
+    }
+
+    {
+        new Object() {
+            final static String v15 = "Anon1_1$2";
+            final static String v14 = "Anon1_1$2";
+        };
+    }
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon1_1$5";
+            final static String v14 = "Anon1_1$13";
+        };
+        new Object() {
+            final static String v15 = "Anon1_1$6";
+            final static String v14 = "Anon1_1$14";
+        };
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon1_1$7";
+            final static String v14 = "Anon1_1$15";
+        };
+        new Object() {
+            final static String v15 = "Anon1_1$8";
+            final static String v14 = "Anon1_1$16";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon1_1$3";
+            final static String v14 = "Anon1_1$3";
+        };
+    }
+
+    static class A2 {
+        final static String v15 = "Anon1_1$A2";
+        final static String v14 = "Anon1_1$A2";
+
+        static {
+            new Object() {
+                final static String v15 = "Anon1_1$A2$1";
+                final static String v14 = "Anon1_1$4";
+            };
+        }
+
+        A2(){
+            new Object() {
+                final static String v15 = "Anon1_1$A2$4";
+                final static String v14 = "Anon1_1$7";
+            };
+        }
+
+        static {
+            new Object() {
+                final static String v15 = "Anon1_1$A2$2";
+                final static String v14 = "Anon1_1$5";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon1_1$A2$3";
+                final static String v14 = "Anon1_1$6";
+            };
+        }
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon1_1$A2$5";
+                final static String v14 = "Anon1_1$8";
+            };
+            new Object() {
+                final static String v15 = "Anon1_1$A2$6";
+                final static String v14 = "Anon1_1$9";
+            };
+        }
+
+        static void staticMethod() {
+            new Object() {
+                final static String v15 = "Anon1_1$A2$7";
+                final static String v14 = "Anon1_1$10";
+            };
+            new Object() {
+                final static String v15 = "Anon1_1$A2$8";
+                final static String v14 = "Anon1_1$11";
+            };
+        }
+
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon2.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon2.java
new file mode 100644
index 0000000..33f6e17
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon2.java
@@ -0,0 +1,91 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon2 {
+    final static String v15 = "Anon2";
+    final static String v14 = "Anon2";
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon2$3";
+            final static String v14 = "Anon2$7";
+        };
+        new Object() {
+            final static String v15 = "Anon2$4";
+            final static String v14 = "Anon2$8";
+        };
+    }
+
+    Anon2() {
+        new Object() {
+            final static String v15 = "Anon2$5";
+            final static String v14 = "Anon2$9";
+        };
+        new Object() {
+            final static String v15 = "Anon2$6";
+            final static String v14 = "Anon2$10";
+        };
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon2$7";
+            final static String v14 = "Anon2$11";
+        };
+        new Object() {
+            final static String v15 = "Anon2$8";
+            final static String v14 = "Anon2$12";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon2$1";
+            final static String v14 = "Anon2$1";
+        };
+
+        new Object() {
+            final static String v15 = "Anon2$2";
+            final static String v14 = "Anon2$2";
+        };
+    }
+
+    class A2 {
+        final static String v15 = "Anon2$A2";
+        final static String v14 = "Anon2$A2";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon2$A2$3";
+                final static String v14 = "Anon2$5";
+            };
+            new Object() {
+                final static String v15 = "Anon2$A2$4";
+                final static String v14 = "Anon2$6";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon2$A2$1";
+                final static String v14 = "Anon2$3";
+            };
+            new Object() {
+                final static String v15 = "Anon2$A2$2";
+                final static String v14 = "Anon2$4";
+            };
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon3.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon3.java
new file mode 100644
index 0000000..91c30b0
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon3.java
@@ -0,0 +1,140 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon3 {
+    final static String v15 = "Anon3";
+    final static String v14 = "Anon3";
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon3$3";
+            final static String v14 = "Anon3$15";
+        };
+        new Object() {
+            final static String v15 = "Anon3$4";
+            final static String v14 = "Anon3$16";
+        };
+    }
+
+    Anon3() {
+        new Object() {
+            final static String v15 = "Anon3$5";
+            final static String v14 = "Anon3$17";
+        };
+        new Object() {
+            final static String v15 = "Anon3$6";
+            final static String v14 = "Anon3$18";
+        };
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon3$7";
+            final static String v14 = "Anon3$19";
+        };
+        new Object() {
+            final static String v15 = "Anon3$8";
+            final static String v14 = "Anon3$20";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon3$1";
+            final static String v14 = "Anon3$1";
+        };
+
+        new Object() {
+            final static String v15 = "Anon3$2";
+            final static String v14 = "Anon3$2";
+        };
+    }
+
+    class A2 {
+        final static String v15 = "Anon3$A2";
+        final static String v14 = "Anon3$A2";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon3$A2$3";
+                final static String v14 = "Anon3$5";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A2$4";
+                final static String v14 = "Anon3$6";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon3$A2$1";
+                final static String v14 = "Anon3$3";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A2$2";
+                final static String v14 = "Anon3$4";
+            };
+        }
+    }
+
+    static class A3 {
+        final static String v15 = "Anon3$A3";
+        final static String v14 = "Anon3$A3";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon3$A3$5";
+                final static String v14 = "Anon3$11";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A3$6";
+                final static String v14 = "Anon3$12";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon3$A3$1";
+                final static String v14 = "Anon3$7";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A3$2";
+                final static String v14 = "Anon3$8";
+            };
+        }
+
+        static void staticMethod() {
+            new Object() {
+                final static String v15 = "Anon3$A3$7";
+                final static String v14 = "Anon3$13";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A3$8";
+                final static String v14 = "Anon3$14";
+            };
+        }
+
+        static {
+            new Object() {
+                final static String v15 = "Anon3$A3$3";
+                final static String v14 = "Anon3$9";
+            };
+            new Object() {
+                final static String v15 = "Anon3$A3$4";
+                final static String v14 = "Anon3$10";
+            };
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon3_3.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon3_3.java
new file mode 100644
index 0000000..ac0683b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon3_3.java
@@ -0,0 +1,156 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon3_3 {
+    final static String v15 = "Anon3_3";
+    final static String v14 = "Anon3_3";
+
+    static {
+        new Object() {
+            final static String v15 = "Anon3_3$1";
+            final static String v14 = "Anon3_3$1";
+        };
+    }
+
+    Anon3_3() {
+        new Object() {
+            final static String v15 = "Anon3_3$4";
+            final static String v14 = "Anon3_3$16";
+        };
+    }
+
+    {
+        new Object() {
+            final static String v15 = "Anon3_3$2";
+            final static String v14 = "Anon3_3$2";
+        };
+    }
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon3_3$5";
+            final static String v14 = "Anon3_3$17";
+        };
+        new Object() {
+            final static String v15 = "Anon3_3$6";
+            final static String v14 = "Anon3_3$18";
+        };
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon3_3$7";
+            final static String v14 = "Anon3_3$19";
+        };
+        new Object() {
+            final static String v15 = "Anon3_3$8";
+            final static String v14 = "Anon3_3$20";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon3_3$3";
+            final static String v14 = "Anon3_3$3";
+        };
+    }
+
+    class A2 {
+        final static String v15 = "Anon3_3$A2";
+        final static String v14 = "Anon3_3$A2";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon3_3$A2$2";
+                final static String v14 = "Anon3_3$5";
+            };
+            new Object() {
+                final static String v15 = "Anon3_3$A2$3";
+                final static String v14 = "Anon3_3$6";
+            };
+        }
+
+        A2(){
+            new Object() {
+                final static String v15 = "Anon3_3$A2$4";
+                final static String v14 = "Anon3_3$7";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon3_3$A2$1";
+                final static String v14 = "Anon3_3$4";
+            };
+        }
+    }
+
+    static class A3 {
+        final static String v15 = "Anon3_3$A3";
+        final static String v14 = "Anon3_3$A3";
+
+        static {
+            new Object() {
+                final static String v15 = "Anon3_3$A3$1";
+                final static String v14 = "Anon3_3$8";
+            };
+        }
+
+        A3(){
+            new Object() {
+                final static String v15 = "Anon3_3$A3$4";
+                final static String v14 = "Anon3_3$11";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon3_3$A3$2";
+                final static String v14 = "Anon3_3$9";
+            };
+        }
+
+        static {
+            new Object() {
+                final static String v15 = "Anon3_3$A3$3";
+                final static String v14 = "Anon3_3$10";
+            };
+        }
+
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon3_3$A3$5";
+                final static String v14 = "Anon3_3$12";
+            };
+            new Object() {
+                final static String v15 = "Anon3_3$A3$6";
+                final static String v14 = "Anon3_3$13";
+            };
+        }
+
+        static void staticMethod() {
+            new Object() {
+                final static String v15 = "Anon3_3$A3$7";
+                final static String v14 = "Anon3_3$14";
+            };
+            new Object() {
+                final static String v15 = "Anon3_3$A3$8";
+                final static String v14 = "Anon3_3$15";
+            };
+        }
+
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon4.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon4.java
new file mode 100644
index 0000000..ed22c94
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon4.java
@@ -0,0 +1,121 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon4 {
+    final static String v15 = "Anon4";
+    final static String v14 = "Anon4";
+
+    Anon4() {
+        new Object() {
+            final static String v15 = "Anon4$3";
+            final static String v14 = "Anon4$7";
+        };
+        new Object() {
+            final static String v15 = "Anon4$4";
+            final static String v14 = "Anon4$8";
+        };
+    }
+
+    void instanceMethod() {
+        new Object() {
+            final static String v15 = "Anon4$5";
+            final static String v14 = "Anon4$9";
+        };
+        new Object() {
+            final static String v15 = "Anon4$6";
+            final static String v14 = "Anon4$10";
+        };
+
+        class A3 {
+            final static String v15 = "Anon4$1A3";
+            final static String v14 = "Anon4$1$A3";
+
+            void instanceMethod() {
+                new Object() {
+                    final static String v15 = "Anon4$1A3$3";
+                    final static String v14 = "Anon4$13";
+                };
+                new Object() {
+                    final static String v15 = "Anon4$1A3$4";
+                    final static String v14 = "Anon4$14";
+                };
+            }
+
+            {
+                new Object() {
+                    final static String v15 = "Anon4$1A3$1";
+                    final static String v14 = "Anon4$11";
+                };
+                new Object() {
+                    final static String v15 = "Anon4$1A3$2";
+                    final static String v14 = "Anon4$12";
+                };
+            }
+
+        }
+    }
+
+    static void staticMethod() {
+        new Object() {
+            final static String v15 = "Anon4$7";
+            final static String v14 = "Anon4$15";
+        };
+        new Object() {
+            final static String v15 = "Anon4$8";
+            final static String v14 = "Anon4$16";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon4$1";
+            final static String v14 = "Anon4$1";
+        };
+
+        new Object() {
+            final static String v15 = "Anon4$2";
+            final static String v14 = "Anon4$2";
+        };
+    }
+
+    class A2 {
+        final static String v15 = "Anon4$A2";
+        final static String v14 = "Anon4$A2";
+
+        void instanceMethod() {
+            new Object() {
+                final static String v15 = "Anon4$A2$3";
+                final static String v14 = "Anon4$5";
+            };
+            new Object() {
+                final static String v15 = "Anon4$A2$4";
+                final static String v14 = "Anon4$6";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon4$A2$1";
+                final static String v14 = "Anon4$3";
+            };
+            new Object() {
+                final static String v15 = "Anon4$A2$2";
+                final static String v14 = "Anon4$4";
+            };
+        }
+
+
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/inner/Anon5.java b/org.eclipse.jdt.bcoview.tests/src/inner/Anon5.java
new file mode 100644
index 0000000..2f8e61e
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/inner/Anon5.java
@@ -0,0 +1,141 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package inner;
+
+public class Anon5 {
+    final static String v15 = "Anon5";
+    final static String v14 = "Anon5";
+
+    void instanceMethod1() {
+        new Object() {
+            final static String v15 = "Anon5$5";
+            final static String v14 = "Anon5$10";
+        };
+
+        new Object() {
+            final static String v15 = "Anon5$6";
+            final static String v14 = "Anon5$11";
+
+            {
+                new Object() {
+                    final static String v15 = "Anon5$6$1";
+                    final static String v14 = "Anon5$12";
+                };
+            }
+        };
+
+        new Object() {
+            final static String v15 = "Anon5$7";
+            final static String v14 = "Anon5$13";
+        };
+    }
+
+    {
+        new Object() {
+            final static String v15 = "Anon5$1";
+            final static String v14 = "Anon5$1";
+        };
+    }
+
+    Anon5(){
+        new Object() {
+            final static String v15 = "Anon5$8";
+            final static String v14 = "Anon5$14";
+        };
+    }
+
+    static {
+        new Object() {
+            final static String v15 = "Anon5$2";
+            final static String v14 = "Anon5$2";
+        };
+    }
+
+    {
+        new Object() {
+            final static String v15 = "Anon5$3";
+            final static String v14 = "Anon5$3";
+        };
+    }
+
+
+    static {
+        new Object() {
+            final static String v15 = "Anon5$4";
+            final static String v14 = "Anon5$4";
+        };
+    }
+
+
+
+    void instanceMethod2() {
+        class A3 {
+            final static String v15 = "Anon5$1A3";
+            final static String v14 = "Anon5$1$A3";
+
+            {
+                new Object() {
+                    final static String v15 = "Anon5$1A3$1";
+                    final static String v14 = "Anon5$15";
+                };
+            }
+        }
+
+    }
+
+    class A1 {
+        final static String v15 = "Anon5$A1";
+        final static String v14 = "Anon5$A1";
+
+        A1(){
+            new Object() {
+                final static String v15 = "Anon5$A1$2";
+                final static String v14 = "Anon5$6";
+            };
+        }
+        {
+            new Object() {
+                final static String v15 = "Anon5$A1$1";
+                final static String v14 = "Anon5$5";
+            };
+        }
+
+    }
+
+    static class A2 {
+        final static String v15 = "Anon5$A2";
+        final static String v14 = "Anon5$A2";
+
+        A2(){
+            new Object() {
+                final static String v15 = "Anon5$A2$3";
+                final static String v14 = "Anon5$9";
+            };
+        }
+
+        static {
+            new Object() {
+                final static String v15 = "Anon5$A2$1";
+                final static String v14 = "Anon5$7";
+            };
+        }
+
+        {
+            new Object() {
+                final static String v15 = "Anon5$A2$2";
+                final static String v14 = "Anon5$8";
+            };
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/AllTests.java b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/AllTests.java
new file mode 100644
index 0000000..d6a40fe
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/AllTests.java
@@ -0,0 +1,34 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview;
+
+import org.eclipse.jdt.bcoview.ui.TestJdk14Compatibility;
+import org.eclipse.jdt.bcoview.ui.TestJdk15Compatibility;
+
+import junit.framework.Test;
+import junit.framework.TestSuite;
+
+
+public class AllTests {
+
+    public static Test suite() {
+        TestSuite suite = new TestSuite("Test for org.eclipse.jdt.bcoview");
+        //$JUnit-BEGIN$
+        suite.addTestSuite(TestJdk14Compatibility.class);
+        suite.addTestSuite(TestJdk15Compatibility.class);
+        //$JUnit-END$
+        return suite;
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk14Compatibility.java b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk14Compatibility.java
new file mode 100644
index 0000000..89cd156
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk14Compatibility.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+public class TestJdk14Compatibility extends TestJdtUtils {
+
+    public void testGetNamed1() throws Exception {
+        doTest("Anon1");
+    }
+
+    public void testGetNamed1_1() throws Exception {
+        doTest("Anon1_1");
+    }
+
+    public void testGetNamed2() throws Exception {
+        doTest("Anon2");
+    }
+
+    public void testGetNamed3() throws Exception {
+        doTest("Anon3");
+    }
+
+    public void testGetNamed3_3() throws Exception {
+        doTest("Anon3_3");
+    }
+
+    public void testGetNamed4() throws Exception {
+        doTest("Anon4");
+    }
+
+    public void testGetNamed5() throws Exception {
+        doTest("Anon5");
+    }
+
+    @Override
+    protected String getJdkVersion() {
+        return "1.4";
+    }
+
+    @Override
+    protected String getFieldName() {
+        return "v14";
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk15Compatibility.java b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk15Compatibility.java
new file mode 100644
index 0000000..928a365
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdk15Compatibility.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+public class TestJdk15Compatibility extends TestJdtUtils {
+
+    public void testGetNamed1() throws Exception {
+        doTest("Anon1");
+    }
+
+    public void testGetNamed1_1() throws Exception {
+        doTest("Anon1_1");
+    }
+
+    public void testGetNamed2() throws Exception {
+        doTest("Anon2");
+    }
+
+    public void testGetNamed3() throws Exception {
+        doTest("Anon3");
+    }
+
+    public void testGetNamed3_3() throws Exception {
+        doTest("Anon3_3");
+    }
+
+    public void testGetNamed4() throws Exception {
+        doTest("Anon4");
+    }
+
+    public void testGetNamed5() throws Exception {
+        doTest("Anon5");
+    }
+
+    @Override
+    protected String getJdkVersion() {
+        return "1.5";
+    }
+
+    @Override
+    protected String getFieldName() {
+        return "v15";
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdtUtils.java b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdtUtils.java
new file mode 100644
index 0000000..a2d9370
--- /dev/null
+++ b/org.eclipse.jdt.bcoview.tests/src/org/eclipse/jdt/bcoview/ui/TestJdtUtils.java
@@ -0,0 +1,462 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.net.URL;
+import java.nio.file.Files;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IProjectDescription;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.IWorkspaceRunnable;
+import org.eclipse.core.resources.IncrementalProjectBuilder;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.FileLocator;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.NullProgressMonitor;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.core.runtime.Platform;
+import org.eclipse.jdt.bcoview.ui.JdtUtils;
+import org.eclipse.jdt.core.IClasspathAttribute;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IField;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IParent;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.compiler.CharOperation;
+import org.eclipse.jdt.internal.compiler.impl.CompilerOptions;
+import org.eclipse.jdt.internal.core.ClasspathEntry;
+
+import junit.framework.TestCase;
+
+public abstract class TestJdtUtils extends TestCase {
+
+    private static final boolean onlyPrintOutError = false;
+    private static String EXTERNAL_JAR_DIR_PATH;
+    private IWorkspace workspace;
+    private IWorkspaceRoot root;
+    private IJavaProject project;
+
+    protected abstract String getFieldName() ;
+
+    protected abstract String getJdkVersion();
+
+    protected String getJavaProjectName() {
+        return "TestJdtUtils" + getFieldName();
+    }
+
+    @Override
+    protected void setUp() throws Exception {
+        super.setUp();
+        if(project == null){
+            workspace = ResourcesPlugin.getWorkspace();
+            root = workspace.getRoot();
+            project = setUpJavaProject(getJavaProjectName(), getJdkVersion());
+            project.getProject().build(
+                IncrementalProjectBuilder.FULL_BUILD, new NullProgressMonitor());
+            project.makeConsistent(null);
+        }
+    }
+
+    @Override
+    protected void tearDown() throws Exception {
+        deleteProject(project.getProject());
+        super.tearDown();
+    }
+
+
+    protected IJavaProject getJavaProject() {
+        return project;
+    }
+
+    protected ICompilationUnit getCompilationUnit(String cuName)
+        throws JavaModelException {
+
+        ICompilationUnit compilationUnit = getCompilationUnit("src", "inner", cuName);
+        return compilationUnit;
+    }
+
+    /**
+     * Returns the specified compilation unit in the given project, root, and package
+     * fragment or <code>null</code> if it does not exist.
+     */
+    protected ICompilationUnit getCompilationUnit(String rootPath,
+        String packageName, String cuName) throws JavaModelException {
+        IPackageFragment pkg = getPackageFragment(rootPath, packageName);
+        if (pkg == null) {
+            return null;
+        }
+        return pkg.getCompilationUnit(cuName);
+    }
+
+    /**
+     * Returns the specified package fragment in the given project and root, or
+     * <code>null</code> if it does not exist. The rootPath must be specified as a
+     * project relative path. The empty path refers to the default package fragment.
+     */
+    protected IPackageFragment getPackageFragment(String rootPath,
+        String packageName) throws JavaModelException {
+        IPackageFragmentRoot root1 = getPackageFragmentRoot(rootPath);
+        if (root1 == null) {
+            return null;
+        }
+        return root1.getPackageFragment(packageName);
+    }
+
+    /**
+     * Returns the specified package fragment root in the given project, or
+     * <code>null</code> if it does not exist. If relative, the rootPath must be
+     * specified as a project relative path. The empty path refers to the package fragment
+     * root that is the project folder iteslf. If absolute, the rootPath refers to either
+     * an external jar, or a resource internal to the workspace
+     */
+    protected IPackageFragmentRoot getPackageFragmentRoot(String rootPath)
+        throws JavaModelException {
+
+        IJavaProject project = getJavaProject();
+        if (project == null) {
+            return null;
+        }
+        IPath path = new Path(rootPath);
+        if (path.isAbsolute()) {
+            IWorkspaceRoot workspaceRoot = ResourcesPlugin.getWorkspace()
+                .getRoot();
+            IResource resource = workspaceRoot.findMember(path);
+            IPackageFragmentRoot root1;
+            if (resource == null) {
+                // external jar
+                root1 = project.getPackageFragmentRoot(rootPath);
+            } else {
+                // resource in the workspace
+                root1 = project.getPackageFragmentRoot(resource);
+            }
+            return root1;
+        }
+        IPackageFragmentRoot[] roots = project.getPackageFragmentRoots();
+        if (roots == null || roots.length == 0) {
+            return null;
+        }
+        for (int i = 0; i < roots.length; i++) {
+            IPackageFragmentRoot root1 = roots[i];
+            if (!root1.isExternal()
+                && root1.getUnderlyingResource().getProjectRelativePath()
+                    .equals(path)) {
+                return root1;
+            }
+        }
+        return null;
+    }
+
+
+    protected IJavaProject createJavaProject(final String projectName,
+        final String[] sourceFolders, final String[] libraries,
+        final String projectOutput, final String compliance)
+        throws CoreException {
+        final IJavaProject[] result = new IJavaProject[1];
+        IWorkspaceRunnable create = new IWorkspaceRunnable() {
+
+            @Override
+            public void run(IProgressMonitor monitor) throws CoreException {
+                // create project
+                createProject(projectName);
+
+                // set java nature
+                addJavaNature(projectName);
+
+                // create classpath entries
+                IProject project = root.getProject(projectName);
+                IPath projectPath = project.getFullPath();
+                int sourceLength = sourceFolders.length;
+                int libLength = libraries.length;
+
+                IClasspathEntry[] entries = new IClasspathEntry[sourceLength
+                    + libLength];
+                for (int i = 0; i < sourceLength; i++) {
+                    IPath sourcePath = new Path(sourceFolders[i]);
+                    int segmentCount = sourcePath.segmentCount();
+                    if (segmentCount > 0) {
+                        // create folder and its parents
+                        IContainer container = project;
+                        for (int j = 0; j < segmentCount; j++) {
+                            IFolder folder = container.getFolder(new Path(
+                                sourcePath.segment(j)));
+                            if (!folder.exists()) {
+                                folder.create(true, true, null);
+                            }
+                            container = folder;
+                        }
+                    }
+
+                    // create source entry
+                    entries[i] = JavaCore.newSourceEntry(
+                        projectPath.append(sourcePath), new IPath[0],
+                        new IPath[0], null);
+                }
+
+                for (int i = 0; i < libLength; i++) {
+                    String lib = libraries[i];
+                    if (lib.indexOf(File.separatorChar) == -1
+                        && lib.charAt(0) != '/'
+                        && lib.equals(lib.toUpperCase())) { // all upper case is a var
+                        char[][] vars = CharOperation.splitOn(',', lib
+                            .toCharArray());
+                        entries[sourceLength + i] = JavaCore.newVariableEntry(
+                            new Path(new String(vars[0])), vars.length > 1
+                                ? new Path(new String(vars[1]))
+                                : null, vars.length > 2
+                                ? new Path(new String(vars[2]))
+                                : null);
+                    } else {
+                        IPath libPath = new Path(lib);
+                        if (!libPath.isAbsolute() && libPath.segmentCount() > 0
+                            && libPath.getFileExtension() == null) {
+                            project.getFolder(libPath).create(true, true, null);
+                            libPath = projectPath.append(libPath);
+                        }
+                        entries[sourceLength + i] = JavaCore.newLibraryEntry(
+                            libPath, null, null, ClasspathEntry.getAccessRules(
+                                new IPath[0], new IPath[0]),
+                            new IClasspathAttribute[0], false);
+                    }
+                }
+
+                // create project's output folder
+                IPath outputPath = new Path(projectOutput);
+                if (outputPath.segmentCount() > 0) {
+                    IFolder output = project.getFolder(outputPath);
+                    if (!output.exists()) {
+                        output.create(true, true, null);
+                    }
+                }
+
+                // set classpath and output location
+                IJavaProject javaProject = JavaCore.create(project);
+                javaProject.setRawClasspath(entries, projectPath
+                    .append(outputPath), null);
+
+                // set compliance level options
+                if ("1.5".equals(compliance)) {
+                    Map<String, String> options = new HashMap<String, String>();
+                    options.put(
+                        CompilerOptions.OPTION_Compliance,
+                        CompilerOptions.VERSION_1_5);
+                    options.put(
+                        CompilerOptions.OPTION_Source,
+                        CompilerOptions.VERSION_1_5);
+                    options.put(
+                        CompilerOptions.OPTION_TargetPlatform,
+                        CompilerOptions.VERSION_1_5);
+                    javaProject.setOptions(options);
+                }
+
+                result[0] = javaProject;
+            }
+        };
+        workspace.run(create, null);
+        return result[0];
+    }
+
+    protected IProject createProject(final String projectName)
+        throws CoreException {
+        final IProject project1 = root.getProject(projectName);
+
+        deleteProject(project1);
+
+        IWorkspaceRunnable create = new IWorkspaceRunnable() {
+
+            @Override
+            public void run(IProgressMonitor monitor) throws CoreException {
+                project1.create(null);
+                project1.open(null);
+            }
+        };
+        workspace.run(create, null);
+        return project1;
+    }
+
+    protected void addJavaNature(String projectName) throws CoreException {
+        IProject project1 = root.getProject(projectName);
+        IProjectDescription description = project1.getDescription();
+        description.setNatureIds(new String[]{JavaCore.NATURE_ID});
+        project1.setDescription(description, null);
+    }
+
+    protected void deleteProject(IProject project1) throws CoreException {
+        if (project1.exists() && !project1.isOpen()) { // force opening so that project
+                                                        // can be deleted without logging
+                                                        // (see bug 23629)
+            project1.open(null);
+        }
+        project1.delete(true, null);
+    }
+
+
+    protected IJavaProject setUpJavaProject(final String projectName,
+        String compliance) throws CoreException, IOException {
+        // copy files in project from source workspace to target workspace
+        String sourceWorkspacePath = getSourcesPath();
+
+        String targetWorkspacePath = root.getLocation().toFile()
+            .getCanonicalPath();
+        copyDirectory(new File(sourceWorkspacePath), new File(
+            targetWorkspacePath + "/" + projectName, "src"));
+
+        // create project
+        IJavaProject javaProject = createJavaProject(
+            projectName, new String[]{"src"}, new String[] {}, "bin", compliance);
+
+        return javaProject;
+    }
+
+    /**
+     * Copy the given source directory (and all its contents) to the given target
+     * directory.
+     */
+    protected void copyDirectory(File source, File target) throws IOException {
+        if (!target.exists()) {
+            boolean result = target.mkdirs();
+            if(!result){
+                throw new IOException("Can't create directory: " + target);
+            }
+        }
+        File[] files = source.listFiles();
+        if (files == null) {
+            return;
+        }
+        for (int i = 0; i < files.length; i++) {
+            File sourceChild = files[i];
+            String name = sourceChild.getName();
+            if (name.equals("bco")) {
+                continue;
+            }
+            File targetChild = new File(target, name);
+            if (sourceChild.isDirectory()) {
+                copyDirectory(sourceChild, targetChild);
+            } else {
+                copy(sourceChild, targetChild);
+            }
+        }
+    }
+
+    /**
+     * Copy file from src (path to the original file) to dest (path to the destination
+     * file).
+     */
+    protected void copy(File src, File dest) throws IOException {
+        // read source bytes
+        byte[] srcBytes = this.read(src);
+
+        // write bytes to dest
+        FileOutputStream out = new FileOutputStream(dest);
+        out.write(srcBytes);
+        out.close();
+    }
+
+    protected byte[] read(java.io.File file) throws java.io.IOException {
+        return Files.readAllBytes(file.toPath());
+    }
+
+    /**
+     * Returns the OS path to the directory that contains this plugin.
+     */
+    protected String getPluginDirectoryPath() {
+        try {
+            URL platformURL = Platform.getBundle("org.eclipse.jdt.bcoview")
+                .getEntry("/");
+            return new File(FileLocator.toFileURL(platformURL).getFile())
+                .getAbsolutePath();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+        return null;
+    }
+
+    protected String getSourcesPath() {
+        return getPluginDirectoryPath() + java.io.File.separator + "test";
+    }
+
+    protected IType[] getAllTypes(ICompilationUnit cu) throws JavaModelException {
+        ArrayList<IJavaElement> list = new ArrayList<IJavaElement>();
+        collectAllTypes(cu, list);
+        return list.toArray(new IType[list.size()]);
+    }
+
+    protected void collectAllTypes(IParent parent, List<IJavaElement> types) throws JavaModelException {
+        // this call has a (good) side effect that the IParent will be opened
+        IJavaElement[] children = parent.getChildren();
+        for (int i = 0; i < children.length; i++) {
+            if(children[i] instanceof IType){
+                types.add(children[i]);
+                collectAllTypes((IParent) children[i], types);
+            } else if (children[i] instanceof IParent){
+                collectAllTypes((IParent) children[i], types);
+            }
+        }
+    }
+
+    protected void doTest(String topClassName) throws JavaModelException {
+        System.out.println("Test with " + topClassName + ".java");
+
+        ICompilationUnit cu = getCompilationUnit(topClassName + ".java");
+        assertNotNull(cu);
+
+        String packagePath = root.getLocation().append(getJavaProjectName()).append(
+            "bin").append("inner").toOSString()
+            + File.separator;
+
+        String fieldName = getFieldName();
+        IType[] allTypes = getAllTypes(cu);
+        for (int i = 0; i < allTypes.length; i++) {
+            IType type = allTypes[i];
+            IField field = type.getField(fieldName);
+            if (field == null) {
+                continue;
+            }
+            String constant = (String) field.getConstant();
+            if(constant != null){
+                constant = constant.substring(1, constant.length() - 1);
+            }
+            String expectedPath = packagePath + constant + ".class";
+            String name = JdtUtils.getByteCodePath(type);
+            if(!(expectedPath).equals(name)){
+                System.out.println("Expected/received: \nexpected  -> " + expectedPath + "\nreceived -> " + name + "\n");
+                if(!onlyPrintOutError) {
+                    assertEquals(expectedPath, name);
+                }
+            } else {
+                System.out.println("OK: " + name);
+            }
+        }
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/.classpath b/org.eclipse.jdt.bcoview/.classpath
new file mode 100644
index 0000000..39305e0
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.classpath
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry excluding="JCL/" kind="src" output="bin_tests" path="test">
+		<attributes>
+			<attribute name="ignore_optional_problems" value="true"/>
+			<attribute name="test" value="true"/>
+		</attributes>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.pde.core.requiredPlugins">
+		<accessrules>
+			<accessrule kind="accessible" pattern="**/jdt/internal/**"/>
+		</accessrules>
+	</classpathentry>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
diff --git a/org.eclipse.jdt.bcoview/.gitignore b/org.eclipse.jdt.bcoview/.gitignore
new file mode 100644
index 0000000..9bde11d
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.gitignore
@@ -0,0 +1,6 @@
+output
+doc
+.fbwarnings
+/bin/
+/bin_tests/
+/lib/
diff --git a/org.eclipse.jdt.bcoview/.options b/org.eclipse.jdt.bcoview/.options
new file mode 100644
index 0000000..d1eac53
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.options
@@ -0,0 +1 @@
+org.eclipse.jdt.bcoview/debug=false
diff --git a/org.eclipse.jdt.bcoview/.project b/org.eclipse.jdt.bcoview/.project
new file mode 100644
index 0000000..eed078f
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.project
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>org.eclipse.jdt.bcoview</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.ManifestBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>org.eclipse.pde.SchemaBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+		<buildCommand>
+			<name>edu.umd.cs.findbugs.plugin.eclipse.findbugsBuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.pde.PluginNature</nature>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+		<nature>edu.umd.cs.findbugs.plugin.eclipse.findbugsNature</nature>
+	</natures>
+</projectDescription>
diff --git a/org.eclipse.jdt.bcoview/.settings/edu.umd.cs.findbugs.core.prefs b/org.eclipse.jdt.bcoview/.settings/edu.umd.cs.findbugs.core.prefs
new file mode 100644
index 0000000..10e79bd
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.settings/edu.umd.cs.findbugs.core.prefs
@@ -0,0 +1,171 @@
+#FindBugs User Preferences
+#Tue Jun 24 10:13:45 CEST 2014
+cloud_id=edu.umd.cs.findbugs.cloud.doNothingCloud
+detectorAppendingToAnObjectOutputStream=AppendingToAnObjectOutputStream|true
+detectorAtomicityProblem=AtomicityProblem|true
+detectorBCPMethodReturnCheck=BCPMethodReturnCheck|false
+detectorBadAppletConstructor=BadAppletConstructor|false
+detectorBadResultSetAccess=BadResultSetAccess|true
+detectorBadSyntaxForRegularExpression=BadSyntaxForRegularExpression|true
+detectorBadUseOfReturnValue=BadUseOfReturnValue|true
+detectorBadlyOverriddenAdapter=BadlyOverriddenAdapter|true
+detectorBooleanReturnNull=BooleanReturnNull|true
+detectorBuildInterproceduralCallGraph=BuildInterproceduralCallGraph|false
+detectorBuildObligationPolicyDatabase=BuildObligationPolicyDatabase|true
+detectorCallToUnsupportedMethod=CallToUnsupportedMethod|true
+detectorCalledMethods=CalledMethods|true
+detectorCheckCalls=CheckCalls|false
+detectorCheckExpectedWarnings=CheckExpectedWarnings|false
+detectorCheckImmutableAnnotation=CheckImmutableAnnotation|true
+detectorCheckRelaxingNullnessAnnotation=CheckRelaxingNullnessAnnotation|true
+detectorCheckTypeQualifiers=CheckTypeQualifiers|true
+detectorCloneIdiom=CloneIdiom|true
+detectorComparatorIdiom=ComparatorIdiom|false
+detectorConfusedInheritance=ConfusedInheritance|true
+detectorConfusionBetweenInheritedAndOuterMethod=ConfusionBetweenInheritedAndOuterMethod|true
+detectorCrossSiteScripting=CrossSiteScripting|false
+detectorDefaultEncodingDetector=DefaultEncodingDetector|true
+detectorDoInsideDoPrivileged=DoInsideDoPrivileged|true
+detectorDontCatchIllegalMonitorStateException=DontCatchIllegalMonitorStateException|true
+detectorDontIgnoreResultOfPutIfAbsent=DontIgnoreResultOfPutIfAbsent|true
+detectorDontUseEnum=DontUseEnum|true
+detectorDroppedException=DroppedException|true
+detectorDumbMethodInvocations=DumbMethodInvocations|true
+detectorDumbMethods=DumbMethods|true
+detectorDuplicateBranches=DuplicateBranches|true
+detectorEmptyZipFileEntry=EmptyZipFileEntry|true
+detectorEqStringTest=EqStringTest|false
+detectorEqualsOperandShouldHaveClassCompatibleWithThis=EqualsOperandShouldHaveClassCompatibleWithThis|true
+detectorExplicitSerialization=ExplicitSerialization|true
+detectorFieldItemSummary=FieldItemSummary|true
+detectorFinalizerNullsFields=FinalizerNullsFields|true
+detectorFindBadCast=FindBadCast|false
+detectorFindBadCast2=FindBadCast2|true
+detectorFindBadEqualsImplementation=FindBadEqualsImplementation|false
+detectorFindBadForLoop=FindBadForLoop|true
+detectorFindBugsSummaryStats=FindBugsSummaryStats|true
+detectorFindCircularDependencies=FindCircularDependencies|false
+detectorFindDeadLocalStores=FindDeadLocalStores|true
+detectorFindDoubleCheck=FindDoubleCheck|true
+detectorFindEmptySynchronizedBlock=FindEmptySynchronizedBlock|true
+detectorFindFieldSelfAssignment=FindFieldSelfAssignment|true
+detectorFindFinalizeInvocations=FindFinalizeInvocations|true
+detectorFindFloatEquality=FindFloatEquality|true
+detectorFindFloatMath=FindFloatMath|false
+detectorFindHEmismatch=FindHEmismatch|true
+detectorFindInconsistentSync2=FindInconsistentSync2|true
+detectorFindJSR166LockMonitorenter=FindJSR166LockMonitorenter|true
+detectorFindLocalSelfAssignment2=FindLocalSelfAssignment2|true
+detectorFindMaskedFields=FindMaskedFields|true
+detectorFindMismatchedWaitOrNotify=FindMismatchedWaitOrNotify|true
+detectorFindNakedNotify=FindNakedNotify|true
+detectorFindNonSerializableStoreIntoSession=FindNonSerializableStoreIntoSession|false
+detectorFindNonSerializableValuePassedToWriteObject=FindNonSerializableValuePassedToWriteObject|true
+detectorFindNonShortCircuit=FindNonShortCircuit|true
+detectorFindNullDeref=FindNullDeref|true
+detectorFindNullDerefsInvolvingNonShortCircuitEvaluation=FindNullDerefsInvolvingNonShortCircuitEvaluation|true
+detectorFindOpenStream=FindOpenStream|true
+detectorFindPuzzlers=FindPuzzlers|true
+detectorFindRefComparison=FindRefComparison|true
+detectorFindReturnRef=FindReturnRef|false
+detectorFindRoughConstants=FindRoughConstants|true
+detectorFindRunInvocations=FindRunInvocations|true
+detectorFindSelfComparison=FindSelfComparison|true
+detectorFindSelfComparison2=FindSelfComparison2|true
+detectorFindSleepWithLockHeld=FindSleepWithLockHeld|true
+detectorFindSpinLoop=FindSpinLoop|true
+detectorFindSqlInjection=FindSqlInjection|false
+detectorFindTwoLockWait=FindTwoLockWait|true
+detectorFindUncalledPrivateMethods=FindUncalledPrivateMethods|true
+detectorFindUnconditionalWait=FindUnconditionalWait|true
+detectorFindUninitializedGet=FindUninitializedGet|true
+detectorFindUnrelatedTypesInGenericContainer=FindUnrelatedTypesInGenericContainer|true
+detectorFindUnreleasedLock=FindUnreleasedLock|true
+detectorFindUnsatisfiedObligation=FindUnsatisfiedObligation|true
+detectorFindUnsyncGet=FindUnsyncGet|true
+detectorFindUseOfNonSerializableValue=FindUseOfNonSerializableValue|true
+detectorFindUselessControlFlow=FindUselessControlFlow|true
+detectorFormatStringChecker=FormatStringChecker|true
+detectorHugeSharedStringConstants=HugeSharedStringConstants|true
+detectorIDivResultCastToDouble=IDivResultCastToDouble|true
+detectorIncompatMask=IncompatMask|true
+detectorInconsistentAnnotations=InconsistentAnnotations|true
+detectorInefficientIndexOf=InefficientIndexOf|true
+detectorInefficientMemberAccess=InefficientMemberAccess|false
+detectorInefficientToArray=InefficientToArray|true
+detectorInfiniteLoop=InfiniteLoop|true
+detectorInfiniteRecursiveLoop=InfiniteRecursiveLoop|true
+detectorInfiniteRecursiveLoop2=InfiniteRecursiveLoop2|false
+detectorInheritanceUnsafeGetResource=InheritanceUnsafeGetResource|true
+detectorInitializationChain=InitializationChain|true
+detectorInitializeNonnullFieldsInConstructor=InitializeNonnullFieldsInConstructor|true
+detectorInstantiateStaticClass=InstantiateStaticClass|true
+detectorIntCast2LongAsInstant=IntCast2LongAsInstant|true
+detectorInvalidJUnitTest=InvalidJUnitTest|true
+detectorIteratorIdioms=IteratorIdioms|true
+detectorLazyInit=LazyInit|true
+detectorLoadOfKnownNullValue=LoadOfKnownNullValue|true
+detectorLockedFields=LockedFields|false
+detectorLostLoggerDueToWeakReference=LostLoggerDueToWeakReference|true
+detectorMethodReturnCheck=MethodReturnCheck|true
+detectorMethods=Methods|true
+detectorMultithreadedInstanceAccess=MultithreadedInstanceAccess|true
+detectorMutableLock=MutableLock|true
+detectorMutableStaticFields=MutableStaticFields|false
+detectorNaming=Naming|true
+detectorNoteAnnotationRetention=NoteAnnotationRetention|true
+detectorNoteCheckReturnValue=NoteCheckReturnValue|true
+detectorNoteCheckReturnValueAnnotations=NoteCheckReturnValueAnnotations|true
+detectorNoteDirectlyRelevantTypeQualifiers=NoteDirectlyRelevantTypeQualifiers|true
+detectorNoteJCIPAnnotation=NoteJCIPAnnotation|true
+detectorNoteNonNullAnnotations=NoteNonNullAnnotations|true
+detectorNoteNonnullReturnValues=NoteNonnullReturnValues|true
+detectorNoteSuppressedWarnings=NoteSuppressedWarnings|true
+detectorNoteUnconditionalParamDerefs=NoteUnconditionalParamDerefs|true
+detectorNumberConstructor=NumberConstructor|true
+detectorOptionalReturnNull=OptionalReturnNull|true
+detectorOverridingEqualsNotSymmetrical=OverridingEqualsNotSymmetrical|true
+detectorPreferZeroLengthArrays=PreferZeroLengthArrays|true
+detectorPublicSemaphores=PublicSemaphores|true
+detectorQuestionableBooleanAssignment=QuestionableBooleanAssignment|true
+detectorReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass=ReadOfInstanceFieldInMethodInvokedByConstructorInSuperclass|true
+detectorReadReturnShouldBeChecked=ReadReturnShouldBeChecked|true
+detectorRedundantInterfaces=RedundantInterfaces|true
+detectorReflectiveClasses=ReflectiveClasses|true
+detectorRepeatedConditionals=RepeatedConditionals|true
+detectorResolveAllReferences=ResolveAllReferences|false
+detectorRuntimeExceptionCapture=RuntimeExceptionCapture|true
+detectorSerializableIdiom=SerializableIdiom|false
+detectorStartInConstructor=StartInConstructor|true
+detectorStaticCalendarDetector=StaticCalendarDetector|true
+detectorStringConcatenation=StringConcatenation|true
+detectorSuperfluousInstanceOf=SuperfluousInstanceOf|true
+detectorSuspiciousThreadInterrupted=SuspiciousThreadInterrupted|true
+detectorSwitchFallthrough=SwitchFallthrough|true
+detectorSynchronizationOnSharedBuiltinConstant=SynchronizationOnSharedBuiltinConstant|true
+detectorSynchronizeAndNullCheckField=SynchronizeAndNullCheckField|true
+detectorSynchronizeOnClassLiteralNotGetClass=SynchronizeOnClassLiteralNotGetClass|true
+detectorSynchronizingOnContentsOfFieldToProtectField=SynchronizingOnContentsOfFieldToProtectField|true
+detectorTestASM=TestASM|false
+detectorTestDataflowAnalysis=TestDataflowAnalysis|false
+detectorTestingGround=TestingGround|false
+detectorTrainFieldStoreTypes=TrainFieldStoreTypes|true
+detectorTrainNonNullAnnotations=TrainNonNullAnnotations|true
+detectorTrainUnconditionalDerefParams=TrainUnconditionalDerefParams|true
+detectorURLProblems=URLProblems|true
+detectorUncallableMethodOfAnonymousClass=UncallableMethodOfAnonymousClass|true
+detectorUnnecessaryMath=UnnecessaryMath|true
+detectorUnreadFields=UnreadFields|true
+detectorUseObjectEquals=UseObjectEquals|true
+detectorUselessSubclassMethod=UselessSubclassMethod|true
+detectorVarArgsProblems=VarArgsProblems|true
+detectorVolatileUsage=VolatileUsage|true
+detectorWaitInLoop=WaitInLoop|true
+detectorWrongMapIterator=WrongMapIterator|true
+detectorXMLFactoryBypass=XMLFactoryBypass|true
+detector_threshold=2
+effort=max
+excludefilter0=findbugsExclude.xml|true
+filter_settings=Medium|BAD_PRACTICE,CORRECTNESS,EXPERIMENTAL,I18N,MALICIOUS_CODE,MT_CORRECTNESS,PERFORMANCE,SECURITY,STYLE|false|20
+filter_settings_neg=NOISE|
+run_at_full_build=false
diff --git a/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.core.prefs b/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.core.prefs
new file mode 100644
index 0000000..379acff
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.core.prefs
@@ -0,0 +1,401 @@
+eclipse.preferences.version=1
+org.eclipse.jdt.core.codeComplete.argumentPrefixes=
+org.eclipse.jdt.core.codeComplete.argumentSuffixes=
+org.eclipse.jdt.core.codeComplete.fieldPrefixes=
+org.eclipse.jdt.core.codeComplete.fieldSuffixes=
+org.eclipse.jdt.core.codeComplete.localPrefixes=
+org.eclipse.jdt.core.codeComplete.localSuffixes=
+org.eclipse.jdt.core.codeComplete.staticFieldPrefixes=
+org.eclipse.jdt.core.codeComplete.staticFieldSuffixes=
+org.eclipse.jdt.core.codeComplete.staticFinalFieldPrefixes=
+org.eclipse.jdt.core.codeComplete.staticFinalFieldSuffixes=
+org.eclipse.jdt.core.compiler.annotation.inheritNullAnnotations=disabled
+org.eclipse.jdt.core.compiler.annotation.missingNonNullByDefaultAnnotation=ignore
+org.eclipse.jdt.core.compiler.annotation.nonnull=org.eclipse.jdt.annotation.NonNull
+org.eclipse.jdt.core.compiler.annotation.nonnull.secondary=
+org.eclipse.jdt.core.compiler.annotation.nonnullbydefault=org.eclipse.jdt.annotation.NonNullByDefault
+org.eclipse.jdt.core.compiler.annotation.nonnullbydefault.secondary=
+org.eclipse.jdt.core.compiler.annotation.nullable=org.eclipse.jdt.annotation.Nullable
+org.eclipse.jdt.core.compiler.annotation.nullable.secondary=
+org.eclipse.jdt.core.compiler.annotation.nullanalysis=disabled
+org.eclipse.jdt.core.compiler.codegen.inlineJsrBytecode=enabled
+org.eclipse.jdt.core.compiler.codegen.methodParameters=do not generate
+org.eclipse.jdt.core.compiler.codegen.targetPlatform=1.8
+org.eclipse.jdt.core.compiler.codegen.unusedLocal=preserve
+org.eclipse.jdt.core.compiler.compliance=1.8
+org.eclipse.jdt.core.compiler.debug.lineNumber=generate
+org.eclipse.jdt.core.compiler.debug.localVariable=generate
+org.eclipse.jdt.core.compiler.debug.sourceFile=generate
+org.eclipse.jdt.core.compiler.doc.comment.support=enabled
+org.eclipse.jdt.core.compiler.problem.APILeak=warning
+org.eclipse.jdt.core.compiler.problem.annotationSuperInterface=warning
+org.eclipse.jdt.core.compiler.problem.assertIdentifier=error
+org.eclipse.jdt.core.compiler.problem.autoboxing=warning
+org.eclipse.jdt.core.compiler.problem.comparingIdentical=warning
+org.eclipse.jdt.core.compiler.problem.deadCode=warning
+org.eclipse.jdt.core.compiler.problem.deprecation=warning
+org.eclipse.jdt.core.compiler.problem.deprecationInDeprecatedCode=disabled
+org.eclipse.jdt.core.compiler.problem.deprecationWhenOverridingDeprecatedMethod=enabled
+org.eclipse.jdt.core.compiler.problem.discouragedReference=warning
+org.eclipse.jdt.core.compiler.problem.emptyStatement=warning
+org.eclipse.jdt.core.compiler.problem.enumIdentifier=error
+org.eclipse.jdt.core.compiler.problem.explicitlyClosedAutoCloseable=ignore
+org.eclipse.jdt.core.compiler.problem.fallthroughCase=warning
+org.eclipse.jdt.core.compiler.problem.fatalOptionalError=disabled
+org.eclipse.jdt.core.compiler.problem.fieldHiding=warning
+org.eclipse.jdt.core.compiler.problem.finalParameterBound=warning
+org.eclipse.jdt.core.compiler.problem.finallyBlockNotCompletingNormally=warning
+org.eclipse.jdt.core.compiler.problem.forbiddenReference=error
+org.eclipse.jdt.core.compiler.problem.hiddenCatchBlock=warning
+org.eclipse.jdt.core.compiler.problem.includeNullInfoFromAsserts=enabled
+org.eclipse.jdt.core.compiler.problem.incompatibleNonInheritedInterfaceMethod=warning
+org.eclipse.jdt.core.compiler.problem.incompleteEnumSwitch=warning
+org.eclipse.jdt.core.compiler.problem.indirectStaticAccess=warning
+org.eclipse.jdt.core.compiler.problem.invalidJavadoc=ignore
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTags=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsDeprecatedRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsNotVisibleRef=enabled
+org.eclipse.jdt.core.compiler.problem.invalidJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.localVariableHiding=warning
+org.eclipse.jdt.core.compiler.problem.methodWithConstructorName=warning
+org.eclipse.jdt.core.compiler.problem.missingDefaultCase=warning
+org.eclipse.jdt.core.compiler.problem.missingDeprecatedAnnotation=ignore
+org.eclipse.jdt.core.compiler.problem.missingEnumCaseDespiteDefault=disabled
+org.eclipse.jdt.core.compiler.problem.missingHashCodeMethod=warning
+org.eclipse.jdt.core.compiler.problem.missingJavadocComments=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocCommentsVisibility=public
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagDescription=return_tag
+org.eclipse.jdt.core.compiler.problem.missingJavadocTags=ignore
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsMethodTypeParameters=disabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsOverriding=enabled
+org.eclipse.jdt.core.compiler.problem.missingJavadocTagsVisibility=private
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.missingOverrideAnnotationForInterfaceMethodImplementation=enabled
+org.eclipse.jdt.core.compiler.problem.missingSerialVersion=warning
+org.eclipse.jdt.core.compiler.problem.missingSynchronizedOnInheritedMethod=warning
+org.eclipse.jdt.core.compiler.problem.noEffectAssignment=warning
+org.eclipse.jdt.core.compiler.problem.noImplicitStringConversion=warning
+org.eclipse.jdt.core.compiler.problem.nonExternalizedStringLiteral=ignore
+org.eclipse.jdt.core.compiler.problem.nonnullParameterAnnotationDropped=warning
+org.eclipse.jdt.core.compiler.problem.nonnullTypeVariableFromLegacyInvocation=warning
+org.eclipse.jdt.core.compiler.problem.nullAnnotationInferenceConflict=error
+org.eclipse.jdt.core.compiler.problem.nullReference=warning
+org.eclipse.jdt.core.compiler.problem.nullSpecViolation=error
+org.eclipse.jdt.core.compiler.problem.nullUncheckedConversion=warning
+org.eclipse.jdt.core.compiler.problem.overridingPackageDefaultMethod=warning
+org.eclipse.jdt.core.compiler.problem.parameterAssignment=ignore
+org.eclipse.jdt.core.compiler.problem.pessimisticNullAnalysisForFreeTypeVariables=warning
+org.eclipse.jdt.core.compiler.problem.possibleAccidentalBooleanAssignment=warning
+org.eclipse.jdt.core.compiler.problem.potentialNullReference=warning
+org.eclipse.jdt.core.compiler.problem.potentiallyUnclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.rawTypeReference=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullAnnotation=warning
+org.eclipse.jdt.core.compiler.problem.redundantNullCheck=warning
+org.eclipse.jdt.core.compiler.problem.redundantSpecificationOfTypeArguments=warning
+org.eclipse.jdt.core.compiler.problem.redundantSuperinterface=warning
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBePotentiallyStatic=ignore
+org.eclipse.jdt.core.compiler.problem.reportMethodCanBeStatic=warning
+org.eclipse.jdt.core.compiler.problem.specialParameterHidingField=disabled
+org.eclipse.jdt.core.compiler.problem.staticAccessReceiver=warning
+org.eclipse.jdt.core.compiler.problem.suppressOptionalErrors=disabled
+org.eclipse.jdt.core.compiler.problem.suppressWarnings=enabled
+org.eclipse.jdt.core.compiler.problem.syntacticNullAnalysisForFields=disabled
+org.eclipse.jdt.core.compiler.problem.syntheticAccessEmulation=ignore
+org.eclipse.jdt.core.compiler.problem.terminalDeprecation=warning
+org.eclipse.jdt.core.compiler.problem.typeParameterHiding=warning
+org.eclipse.jdt.core.compiler.problem.unavoidableGenericTypeProblems=disabled
+org.eclipse.jdt.core.compiler.problem.uncheckedTypeOperation=warning
+org.eclipse.jdt.core.compiler.problem.unclosedCloseable=warning
+org.eclipse.jdt.core.compiler.problem.undocumentedEmptyBlock=warning
+org.eclipse.jdt.core.compiler.problem.unhandledWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentType=warning
+org.eclipse.jdt.core.compiler.problem.unlikelyCollectionMethodArgumentTypeStrict=disabled
+org.eclipse.jdt.core.compiler.problem.unlikelyEqualsArgumentType=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryElse=warning
+org.eclipse.jdt.core.compiler.problem.unnecessaryTypeCheck=warning
+org.eclipse.jdt.core.compiler.problem.unqualifiedFieldAccess=ignore
+org.eclipse.jdt.core.compiler.problem.unstableAutoModuleName=warning
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownException=warning
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionExemptExceptionAndThrowable=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedDeclaredThrownExceptionWhenOverriding=disabled
+org.eclipse.jdt.core.compiler.problem.unusedExceptionParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedImport=warning
+org.eclipse.jdt.core.compiler.problem.unusedLabel=warning
+org.eclipse.jdt.core.compiler.problem.unusedLocal=warning
+org.eclipse.jdt.core.compiler.problem.unusedObjectAllocation=warning
+org.eclipse.jdt.core.compiler.problem.unusedParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedParameterIncludeDocCommentReference=enabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenImplementingAbstract=disabled
+org.eclipse.jdt.core.compiler.problem.unusedParameterWhenOverridingConcrete=disabled
+org.eclipse.jdt.core.compiler.problem.unusedPrivateMember=warning
+org.eclipse.jdt.core.compiler.problem.unusedTypeParameter=ignore
+org.eclipse.jdt.core.compiler.problem.unusedWarningToken=warning
+org.eclipse.jdt.core.compiler.problem.varargsArgumentNeedCast=warning
+org.eclipse.jdt.core.compiler.release=disabled
+org.eclipse.jdt.core.compiler.source=1.8
+org.eclipse.jdt.core.compiler.taskCaseSensitive=enabled
+org.eclipse.jdt.core.compiler.taskPriorities=NORMAL,HIGH,HIGH
+org.eclipse.jdt.core.compiler.taskTags=TODO,FIXME,XXX
+org.eclipse.jdt.core.formatter.align_type_members_on_columns=false
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_allocation_expression=32
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_enum_constant=16
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call=32
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_method_invocation=32
+org.eclipse.jdt.core.formatter.alignment_for_arguments_in_qualified_allocation_expression=32
+org.eclipse.jdt.core.formatter.alignment_for_assignment=0
+org.eclipse.jdt.core.formatter.alignment_for_binary_expression=16
+org.eclipse.jdt.core.formatter.alignment_for_compact_if=52
+org.eclipse.jdt.core.formatter.alignment_for_conditional_expression=49
+org.eclipse.jdt.core.formatter.alignment_for_enum_constants=0
+org.eclipse.jdt.core.formatter.alignment_for_expressions_in_array_initializer=16
+org.eclipse.jdt.core.formatter.alignment_for_multiple_fields=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_selector_in_method_invocation=16
+org.eclipse.jdt.core.formatter.alignment_for_superclass_in_type_declaration=64
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_enum_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_superinterfaces_in_type_declaration=64
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration=16
+org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration=16
+org.eclipse.jdt.core.formatter.blank_lines_after_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_after_package=0
+org.eclipse.jdt.core.formatter.blank_lines_before_field=0
+org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration=1
+org.eclipse.jdt.core.formatter.blank_lines_before_imports=1
+org.eclipse.jdt.core.formatter.blank_lines_before_member_type=1
+org.eclipse.jdt.core.formatter.blank_lines_before_method=1
+org.eclipse.jdt.core.formatter.blank_lines_before_new_chunk=1
+org.eclipse.jdt.core.formatter.blank_lines_before_package=0
+org.eclipse.jdt.core.formatter.blank_lines_between_import_groups=1
+org.eclipse.jdt.core.formatter.blank_lines_between_type_declarations=1
+org.eclipse.jdt.core.formatter.brace_position_for_annotation_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_anonymous_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_array_initializer=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_block_in_case=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_constructor_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_constant=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_enum_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_method_declaration=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_switch=end_of_line
+org.eclipse.jdt.core.formatter.brace_position_for_type_declaration=end_of_line
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines=true
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_block_comment=false
+org.eclipse.jdt.core.formatter.comment.clear_blank_lines_in_javadoc_comment=false
+org.eclipse.jdt.core.formatter.comment.format_block_comments=true
+org.eclipse.jdt.core.formatter.comment.format_comments=true
+org.eclipse.jdt.core.formatter.comment.format_header=true
+org.eclipse.jdt.core.formatter.comment.format_html=true
+org.eclipse.jdt.core.formatter.comment.format_javadoc_comments=true
+org.eclipse.jdt.core.formatter.comment.format_line_comments=true
+org.eclipse.jdt.core.formatter.comment.format_source_code=true
+org.eclipse.jdt.core.formatter.comment.indent_parameter_description=false
+org.eclipse.jdt.core.formatter.comment.indent_root_tags=false
+org.eclipse.jdt.core.formatter.comment.insert_new_line_before_root_tags=do not insert
+org.eclipse.jdt.core.formatter.comment.insert_new_line_for_parameter=do not insert
+org.eclipse.jdt.core.formatter.comment.line_length=90
+org.eclipse.jdt.core.formatter.compact_else_if=true
+org.eclipse.jdt.core.formatter.continuation_indentation=1
+org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer=1
+org.eclipse.jdt.core.formatter.format_guardian_clause_on_one_line=false
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_annotation_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_constant_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_enum_declaration_header=true
+org.eclipse.jdt.core.formatter.indent_body_declarations_compare_to_type_header=true
+org.eclipse.jdt.core.formatter.indent_breaks_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_empty_lines=false
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_block=true
+org.eclipse.jdt.core.formatter.indent_statements_compare_to_body=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_cases=true
+org.eclipse.jdt.core.formatter.indent_switchstatements_compare_to_switch=true
+org.eclipse.jdt.core.formatter.indentation.size=4
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_field=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_local_variable=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_method=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_package=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_parameter=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_annotation_on_type=insert
+org.eclipse.jdt.core.formatter.insert_new_line_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_at_end_of_file_if_missing=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_catch_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_else_in_if_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_before_while_in_do_statement=do not insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_annotation_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_block=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_method_body=insert
+org.eclipse.jdt.core.formatter.insert_new_line_in_empty_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_after_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_after_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_at_in_annotation_type_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_angle_bracket_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_after_closing_paren_in_cast=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_annotation=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_array_initializer=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_constant_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_enum_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_explicitconstructorcall_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_inits=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_declaration_throws=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_method_invocation_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_field_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_multiple_local_declarations=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_parameterized_type_reference=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_superinterfaces=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments=insert
+org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_parameters=insert
+org.eclipse.jdt.core.formatter.insert_space_after_ellipsis=insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_after_question_in_wildcard=insert
+org.eclipse.jdt.core.formatter.insert_space_after_semicolon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_after_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_and_in_type_parameter=insert
+org.eclipse.jdt.core.formatter.insert_space_before_assignment_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_at_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_binary_operator=insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_cast=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_catch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_if=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_switch=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_synchronized=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_closing_paren_in_while=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_assert=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement=insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_constructor_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_constant_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_enum_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_explicitconstructorcall_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_increments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_for_inits=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_invocation_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_local_declarations=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_superinterfaces=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_comma_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_ellipsis=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_parameterized_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_arguments=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_angle_bracket_in_type_parameters=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_annotation_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_anonymous_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_block=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_constructor_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_constant=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_enum_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_method_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_brace_in_type_declaration=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_bracket_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_catch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_for=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_if=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_parenthesized_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_switch=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_synchronized=insert
+org.eclipse.jdt.core.formatter.insert_space_before_opening_paren_in_while=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_return=insert
+org.eclipse.jdt.core.formatter.insert_space_before_parenthesized_expression_in_throw=insert
+org.eclipse.jdt.core.formatter.insert_space_before_postfix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_prefix_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional=insert
+org.eclipse.jdt.core.formatter.insert_space_before_question_in_wildcard=insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_semicolon_in_for=do not insert
+org.eclipse.jdt.core.formatter.insert_space_before_unary_operator=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_brackets_in_array_type_reference=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_braces_in_array_initializer=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_brackets_in_array_allocation_expression=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_constructor_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_enum_constant=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_declaration=do not insert
+org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_method_invocation=do not insert
+org.eclipse.jdt.core.formatter.keep_else_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.keep_empty_array_initializer_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_imple_if_on_one_line=false
+org.eclipse.jdt.core.formatter.keep_then_statement_on_same_line=false
+org.eclipse.jdt.core.formatter.lineSplit=80
+org.eclipse.jdt.core.formatter.never_indent_block_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.never_indent_line_comments_on_first_column=false
+org.eclipse.jdt.core.formatter.number_of_blank_lines_at_beginning_of_method_body=0
+org.eclipse.jdt.core.formatter.number_of_empty_lines_to_preserve=1
+org.eclipse.jdt.core.formatter.put_empty_statement_on_new_line=false
+org.eclipse.jdt.core.formatter.tabulation.char=space
+org.eclipse.jdt.core.formatter.tabulation.size=4
+org.eclipse.jdt.core.formatter.use_tabs_only_for_leading_indentations=false
+org.eclipse.jdt.core.formatter.wrap_before_binary_operator=true
diff --git a/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.ui.prefs b/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.ui.prefs
new file mode 100644
index 0000000..eb81692
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/.settings/org.eclipse.jdt.ui.prefs
@@ -0,0 +1,136 @@
+cleanup.add_default_serial_version_id=true
+cleanup.add_generated_serial_version_id=false
+cleanup.add_missing_annotations=true
+cleanup.add_missing_deprecated_annotations=true
+cleanup.add_missing_methods=false
+cleanup.add_missing_nls_tags=false
+cleanup.add_missing_override_annotations=true
+cleanup.add_missing_override_annotations_interface_methods=true
+cleanup.add_serial_version_id=false
+cleanup.always_use_blocks=true
+cleanup.always_use_parentheses_in_expressions=false
+cleanup.always_use_this_for_non_static_field_access=false
+cleanup.always_use_this_for_non_static_method_access=false
+cleanup.convert_functional_interfaces=false
+cleanup.convert_to_enhanced_for_loop=false
+cleanup.correct_indentation=false
+cleanup.format_source_code=false
+cleanup.format_source_code_changes_only=false
+cleanup.insert_inferred_type_arguments=false
+cleanup.make_local_variable_final=false
+cleanup.make_parameters_final=false
+cleanup.make_private_fields_final=true
+cleanup.make_type_abstract_if_missing_method=false
+cleanup.make_variable_declarations_final=true
+cleanup.never_use_blocks=false
+cleanup.never_use_parentheses_in_expressions=true
+cleanup.organize_imports=true
+cleanup.qualify_static_field_accesses_with_declaring_class=false
+cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=true
+cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=true
+cleanup.qualify_static_member_accesses_with_declaring_class=true
+cleanup.qualify_static_method_accesses_with_declaring_class=false
+cleanup.remove_private_constructors=true
+cleanup.remove_redundant_type_arguments=true
+cleanup.remove_trailing_whitespaces=true
+cleanup.remove_trailing_whitespaces_all=true
+cleanup.remove_trailing_whitespaces_ignore_empty=false
+cleanup.remove_unnecessary_casts=true
+cleanup.remove_unnecessary_nls_tags=true
+cleanup.remove_unused_imports=true
+cleanup.remove_unused_local_variables=false
+cleanup.remove_unused_private_fields=true
+cleanup.remove_unused_private_members=false
+cleanup.remove_unused_private_methods=true
+cleanup.remove_unused_private_types=true
+cleanup.sort_members=false
+cleanup.sort_members_all=false
+cleanup.use_anonymous_class_creation=false
+cleanup.use_blocks=true
+cleanup.use_blocks_only_for_return_and_throw=false
+cleanup.use_lambda=true
+cleanup.use_parentheses_in_expressions=false
+cleanup.use_this_for_non_static_field_access=false
+cleanup.use_this_for_non_static_field_access_only_if_necessary=true
+cleanup.use_this_for_non_static_method_access=false
+cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+cleanup.use_type_arguments=false
+cleanup_profile=_BCO
+cleanup_settings_version=2
+comment_clear_blank_lines=true
+comment_format_comments=true
+comment_format_header=true
+comment_format_html=true
+comment_format_source_code=true
+comment_indent_parameter_description=false
+comment_indent_root_tags=false
+comment_line_length=90
+comment_new_line_for_parameter=false
+comment_separate_root_tags=false
+eclipse.preferences.version=1
+editor_save_participant_org.eclipse.jdt.ui.postsavelistener.cleanup=true
+formatter_settings_version=11
+internal.default.compliance=default
+org.eclipse.jdt.ui.exception.name=e
+org.eclipse.jdt.ui.gettersetter.use.is=true
+org.eclipse.jdt.ui.keywordthis=false
+org.eclipse.jdt.ui.overrideannotation=true
+org.eclipse.jdt.ui.text.custom_code_templates=<?xml version\="1.0" encoding\="UTF-8" standalone\="no"?><templates/>
+sp_cleanup.add_default_serial_version_id=true
+sp_cleanup.add_generated_serial_version_id=false
+sp_cleanup.add_missing_annotations=true
+sp_cleanup.add_missing_deprecated_annotations=true
+sp_cleanup.add_missing_methods=false
+sp_cleanup.add_missing_nls_tags=false
+sp_cleanup.add_missing_override_annotations=true
+sp_cleanup.add_missing_override_annotations_interface_methods=true
+sp_cleanup.add_serial_version_id=false
+sp_cleanup.always_use_blocks=true
+sp_cleanup.always_use_parentheses_in_expressions=false
+sp_cleanup.always_use_this_for_non_static_field_access=false
+sp_cleanup.always_use_this_for_non_static_method_access=false
+sp_cleanup.convert_functional_interfaces=false
+sp_cleanup.convert_to_enhanced_for_loop=false
+sp_cleanup.correct_indentation=false
+sp_cleanup.format_source_code=false
+sp_cleanup.format_source_code_changes_only=false
+sp_cleanup.insert_inferred_type_arguments=false
+sp_cleanup.make_local_variable_final=false
+sp_cleanup.make_parameters_final=false
+sp_cleanup.make_private_fields_final=true
+sp_cleanup.make_type_abstract_if_missing_method=false
+sp_cleanup.make_variable_declarations_final=true
+sp_cleanup.never_use_blocks=false
+sp_cleanup.never_use_parentheses_in_expressions=true
+sp_cleanup.on_save_use_additional_actions=true
+sp_cleanup.organize_imports=true
+sp_cleanup.qualify_static_field_accesses_with_declaring_class=false
+sp_cleanup.qualify_static_member_accesses_through_instances_with_declaring_class=true
+sp_cleanup.qualify_static_member_accesses_through_subtypes_with_declaring_class=true
+sp_cleanup.qualify_static_member_accesses_with_declaring_class=true
+sp_cleanup.qualify_static_method_accesses_with_declaring_class=false
+sp_cleanup.remove_private_constructors=true
+sp_cleanup.remove_redundant_type_arguments=false
+sp_cleanup.remove_trailing_whitespaces=true
+sp_cleanup.remove_trailing_whitespaces_all=true
+sp_cleanup.remove_trailing_whitespaces_ignore_empty=false
+sp_cleanup.remove_unnecessary_casts=true
+sp_cleanup.remove_unnecessary_nls_tags=true
+sp_cleanup.remove_unused_imports=true
+sp_cleanup.remove_unused_local_variables=false
+sp_cleanup.remove_unused_private_fields=true
+sp_cleanup.remove_unused_private_members=false
+sp_cleanup.remove_unused_private_methods=true
+sp_cleanup.remove_unused_private_types=true
+sp_cleanup.sort_members=false
+sp_cleanup.sort_members_all=false
+sp_cleanup.use_anonymous_class_creation=false
+sp_cleanup.use_blocks=true
+sp_cleanup.use_blocks_only_for_return_and_throw=false
+sp_cleanup.use_lambda=false
+sp_cleanup.use_parentheses_in_expressions=false
+sp_cleanup.use_this_for_non_static_field_access=false
+sp_cleanup.use_this_for_non_static_field_access_only_if_necessary=true
+sp_cleanup.use_this_for_non_static_method_access=false
+sp_cleanup.use_this_for_non_static_method_access_only_if_necessary=true
+sp_cleanup.use_type_arguments=false
diff --git a/org.eclipse.jdt.bcoview/LICENSE.txt b/org.eclipse.jdt.bcoview/LICENSE.txt
new file mode 100644
index 0000000..d3087e4
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/LICENSE.txt
@@ -0,0 +1,277 @@
+Eclipse Public License - v 2.0
+
+    THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE
+    PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
+    OF THE PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
+
+1. DEFINITIONS
+
+"Contribution" means:
+
+  a) in the case of the initial Contributor, the initial content
+     Distributed under this Agreement, and
+
+  b) in the case of each subsequent Contributor:
+     i) changes to the Program, and
+     ii) additions to the Program;
+  where such changes and/or additions to the Program originate from
+  and are Distributed by that particular Contributor. A Contribution
+  "originates" from a Contributor if it was added to the Program by
+  such Contributor itself or anyone acting on such Contributor's behalf.
+  Contributions do not include changes or additions to the Program that
+  are not Modified Works.
+
+"Contributor" means any person or entity that Distributes the Program.
+
+"Licensed Patents" mean patent claims licensable by a Contributor which
+are necessarily infringed by the use or sale of its Contribution alone
+or when combined with the Program.
+
+"Program" means the Contributions Distributed in accordance with this
+Agreement.
+
+"Recipient" means anyone who receives the Program under this Agreement
+or any Secondary License (as applicable), including Contributors.
+
+"Derivative Works" shall mean any work, whether in Source Code or other
+form, that is based on (or derived from) the Program and for which the
+editorial revisions, annotations, elaborations, or other modifications
+represent, as a whole, an original work of authorship.
+
+"Modified Works" shall mean any work in Source Code or other form that
+results from an addition to, deletion from, or modification of the
+contents of the Program, including, for purposes of clarity any new file
+in Source Code form that contains any contents of the Program. Modified
+Works shall not include works that contain only declarations,
+interfaces, types, classes, structures, or files of the Program solely
+in each case in order to link to, bind by name, or subclass the Program
+or Modified Works thereof.
+
+"Distribute" means the acts of a) distributing or b) making available
+in any manner that enables the transfer of a copy.
+
+"Source Code" means the form of a Program preferred for making
+modifications, including but not limited to software source code,
+documentation source, and configuration files.
+
+"Secondary License" means either the GNU General Public License,
+Version 2.0, or any later versions of that license, including any
+exceptions or additional permissions as identified by the initial
+Contributor.
+
+2. GRANT OF RIGHTS
+
+  a) Subject to the terms of this Agreement, each Contributor hereby
+  grants Recipient a non-exclusive, worldwide, royalty-free copyright
+  license to reproduce, prepare Derivative Works of, publicly display,
+  publicly perform, Distribute and sublicense the Contribution of such
+  Contributor, if any, and such Derivative Works.
+
+  b) Subject to the terms of this Agreement, each Contributor hereby
+  grants Recipient a non-exclusive, worldwide, royalty-free patent
+  license under Licensed Patents to make, use, sell, offer to sell,
+  import and otherwise transfer the Contribution of such Contributor,
+  if any, in Source Code or other form. This patent license shall
+  apply to the combination of the Contribution and the Program if, at
+  the time the Contribution is added by the Contributor, such addition
+  of the Contribution causes such combination to be covered by the
+  Licensed Patents. The patent license shall not apply to any other
+  combinations which include the Contribution. No hardware per se is
+  licensed hereunder.
+
+  c) Recipient understands that although each Contributor grants the
+  licenses to its Contributions set forth herein, no assurances are
+  provided by any Contributor that the Program does not infringe the
+  patent or other intellectual property rights of any other entity.
+  Each Contributor disclaims any liability to Recipient for claims
+  brought by any other entity based on infringement of intellectual
+  property rights or otherwise. As a condition to exercising the
+  rights and licenses granted hereunder, each Recipient hereby
+  assumes sole responsibility to secure any other intellectual
+  property rights needed, if any. For example, if a third party
+  patent license is required to allow Recipient to Distribute the
+  Program, it is Recipient's responsibility to acquire that license
+  before distributing the Program.
+
+  d) Each Contributor represents that to its knowledge it has
+  sufficient copyright rights in its Contribution, if any, to grant
+  the copyright license set forth in this Agreement.
+
+  e) Notwithstanding the terms of any Secondary License, no
+  Contributor makes additional grants to any Recipient (other than
+  those set forth in this Agreement) as a result of such Recipient's
+  receipt of the Program under the terms of a Secondary License
+  (if permitted under the terms of Section 3).
+
+3. REQUIREMENTS
+
+3.1 If a Contributor Distributes the Program in any form, then:
+
+  a) the Program must also be made available as Source Code, in
+  accordance with section 3.2, and the Contributor must accompany
+  the Program with a statement that the Source Code for the Program
+  is available under this Agreement, and informs Recipients how to
+  obtain it in a reasonable manner on or through a medium customarily
+  used for software exchange; and
+
+  b) the Contributor may Distribute the Program under a license
+  different than this Agreement, provided that such license:
+     i) effectively disclaims on behalf of all other Contributors all
+     warranties and conditions, express and implied, including
+     warranties or conditions of title and non-infringement, and
+     implied warranties or conditions of merchantability and fitness
+     for a particular purpose;
+
+     ii) effectively excludes on behalf of all other Contributors all
+     liability for damages, including direct, indirect, special,
+     incidental and consequential damages, such as lost profits;
+
+     iii) does not attempt to limit or alter the recipients' rights
+     in the Source Code under section 3.2; and
+
+     iv) requires any subsequent distribution of the Program by any
+     party to be under a license that satisfies the requirements
+     of this section 3.
+
+3.2 When the Program is Distributed as Source Code:
+
+  a) it must be made available under this Agreement, or if the
+  Program (i) is combined with other material in a separate file or
+  files made available under a Secondary License, and (ii) the initial
+  Contributor attached to the Source Code the notice described in
+  Exhibit A of this Agreement, then the Program may be made available
+  under the terms of such Secondary Licenses, and
+
+  b) a copy of this Agreement must be included with each copy of
+  the Program.
+
+3.3 Contributors may not remove or alter any copyright, patent,
+trademark, attribution notices, disclaimers of warranty, or limitations
+of liability ("notices") contained within the Program from any copy of
+the Program which they Distribute, provided that Contributors may add
+their own appropriate notices.
+
+4. COMMERCIAL DISTRIBUTION
+
+Commercial distributors of software may accept certain responsibilities
+with respect to end users, business partners and the like. While this
+license is intended to facilitate the commercial use of the Program,
+the Contributor who includes the Program in a commercial product
+offering should do so in a manner which does not create potential
+liability for other Contributors. Therefore, if a Contributor includes
+the Program in a commercial product offering, such Contributor
+("Commercial Contributor") hereby agrees to defend and indemnify every
+other Contributor ("Indemnified Contributor") against any losses,
+damages and costs (collectively "Losses") arising from claims, lawsuits
+and other legal actions brought by a third party against the Indemnified
+Contributor to the extent caused by the acts or omissions of such
+Commercial Contributor in connection with its distribution of the Program
+in a commercial product offering. The obligations in this section do not
+apply to any claims or Losses relating to any actual or alleged
+intellectual property infringement. In order to qualify, an Indemnified
+Contributor must: a) promptly notify the Commercial Contributor in
+writing of such claim, and b) allow the Commercial Contributor to control,
+and cooperate with the Commercial Contributor in, the defense and any
+related settlement negotiations. The Indemnified Contributor may
+participate in any such claim at its own expense.
+
+For example, a Contributor might include the Program in a commercial
+product offering, Product X. That Contributor is then a Commercial
+Contributor. If that Commercial Contributor then makes performance
+claims, or offers warranties related to Product X, those performance
+claims and warranties are such Commercial Contributor's responsibility
+alone. Under this section, the Commercial Contributor would have to
+defend claims against the other Contributors related to those performance
+claims and warranties, and if a court requires any other Contributor to
+pay any damages as a result, the Commercial Contributor must pay
+those damages.
+
+5. NO WARRANTY
+
+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT
+PERMITTED BY APPLICABLE LAW, THE PROGRAM IS PROVIDED ON AN "AS IS"
+BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR
+IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF
+TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS FOR A PARTICULAR
+PURPOSE. Each Recipient is solely responsible for determining the
+appropriateness of using and distributing the Program and assumes all
+risks associated with its exercise of rights under this Agreement,
+including but not limited to the risks and costs of program errors,
+compliance with applicable laws, damage to or loss of data, programs
+or equipment, and unavailability or interruption of operations.
+
+6. DISCLAIMER OF LIABILITY
+
+EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, AND TO THE EXTENT
+PERMITTED BY APPLICABLE LAW, NEITHER RECIPIENT NOR ANY CONTRIBUTORS
+SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST
+PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION OF THE PROGRAM OR THE
+EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+7. GENERAL
+
+If any provision of this Agreement is invalid or unenforceable under
+applicable law, it shall not affect the validity or enforceability of
+the remainder of the terms of this Agreement, and without further
+action by the parties hereto, such provision shall be reformed to the
+minimum extent necessary to make such provision valid and enforceable.
+
+If Recipient institutes patent litigation against any entity
+(including a cross-claim or counterclaim in a lawsuit) alleging that the
+Program itself (excluding combinations of the Program with other software
+or hardware) infringes such Recipient's patent(s), then such Recipient's
+rights granted under Section 2(b) shall terminate as of the date such
+litigation is filed.
+
+All Recipient's rights under this Agreement shall terminate if it
+fails to comply with any of the material terms or conditions of this
+Agreement and does not cure such failure in a reasonable period of
+time after becoming aware of such noncompliance. If all Recipient's
+rights under this Agreement terminate, Recipient agrees to cease use
+and distribution of the Program as soon as reasonably practicable.
+However, Recipient's obligations under this Agreement and any licenses
+granted by Recipient relating to the Program shall continue and survive.
+
+Everyone is permitted to copy and distribute copies of this Agreement,
+but in order to avoid inconsistency the Agreement is copyrighted and
+may only be modified in the following manner. The Agreement Steward
+reserves the right to publish new versions (including revisions) of
+this Agreement from time to time. No one other than the Agreement
+Steward has the right to modify this Agreement. The Eclipse Foundation
+is the initial Agreement Steward. The Eclipse Foundation may assign the
+responsibility to serve as the Agreement Steward to a suitable separate
+entity. Each new version of the Agreement will be given a distinguishing
+version number. The Program (including Contributions) may always be
+Distributed subject to the version of the Agreement under which it was
+received. In addition, after a new version of the Agreement is published,
+Contributor may elect to Distribute the Program (including its
+Contributions) under the new version.
+
+Except as expressly stated in Sections 2(a) and 2(b) above, Recipient
+receives no rights or licenses to the intellectual property of any
+Contributor under this Agreement, whether expressly, by implication,
+estoppel or otherwise. All rights in the Program not expressly granted
+under this Agreement are reserved. Nothing in this Agreement is intended
+to be enforceable by any entity that is not a Contributor or Recipient.
+No third-party beneficiary rights are created under this Agreement.
+
+Exhibit A - Form of Secondary Licenses Notice
+
+"This Source Code may also be made available under the following 
+Secondary Licenses when the conditions for such availability set forth 
+in the Eclipse Public License, v. 2.0 are satisfied: {name license(s),
+version(s), and exceptions or additional permissions here}."
+
+  Simply including a copy of this Agreement, including this Exhibit A
+  is not sufficient to license the Source Code under Secondary Licenses.
+
+  If it is not possible or desirable to put the notice in a particular
+  file, then You may include the notice in a location (such as a LICENSE
+  file in a relevant directory) where a recipient would be likely to
+  look for such a notice.
+
+  You may add additional accurate notices of copyright ownership.
diff --git a/org.eclipse.jdt.bcoview/META-INF/MANIFEST.MF b/org.eclipse.jdt.bcoview/META-INF/MANIFEST.MF
new file mode 100644
index 0000000..fc91f3f
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/META-INF/MANIFEST.MF
@@ -0,0 +1,33 @@
+Manifest-Version: 1.0
+Bundle-ManifestVersion: 2
+Bundle-Name: Bytecode Outline
+Bundle-SymbolicName: org.eclipse.jdt.bcoview;singleton:=true
+Bundle-Version: 1.0.1.qualifier
+Bundle-ClassPath: .
+Bundle-Activator: org.eclipse.jdt.bcoview.BytecodeOutlinePlugin
+Bundle-Vendor: Andrey Loskutov
+Require-Bundle: org.eclipse.ui,
+ org.eclipse.ui.editors,
+ org.eclipse.core.runtime,
+ org.eclipse.jface.text,
+ org.eclipse.jdt.core;bundle-version="3.15.0",
+ org.eclipse.ui.workbench.texteditor,
+ org.eclipse.jdt.ui,
+ org.eclipse.ui.ide,
+ org.eclipse.compare,
+ org.eclipse.ui.console,
+ org.eclipse.help.base,
+ org.eclipse.debug.ui,
+ org.eclipse.jdt.debug,
+ org.junit;resolution:=optional,
+ org.objectweb.asm;bundle-version="7.0.0",
+ org.objectweb.asm.tree;bundle-version="7.0.0",
+ org.objectweb.asm.analysis;bundle-version="7.0.0",
+ org.objectweb.asm.commons;bundle-version="7.0.0",
+ org.objectweb.asm.util;bundle-version="7.0.0",
+ org.eclipse.core.filesystem;bundle-version="1.7.0"
+Eclipse-LazyStart: true
+Bundle-RequiredExecutionEnvironment: JavaSE-1.8
+Bundle-ActivationPolicy: lazy
+Automatic-Module-Name: org.eclipse.jdt.bcoview
+Export-Package: org.eclipse.jdt.bcoview.ui
diff --git a/org.eclipse.jdt.bcoview/README.txt b/org.eclipse.jdt.bcoview/README.txt
new file mode 100644
index 0000000..930eacb
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/README.txt
@@ -0,0 +1,58 @@
+Bytecode Outline plugin for Eclipse
+-----------------------------------------------------------------
+
+Bytecode Outline plugin shows disassembled bytecode of current java editor or
+class file, allows bytecode compare for java/class files and shows ASMifier
+code for current bytecode.
+
+Have you already asked yourselves what the compiler does with your Java code?
+Here is the answer ;)
+
+The main reason for this plugin was my study how Java generates bytecode and my
+interest in ASM framework. ASM is a great, fast and small bytecode manipulation
+framework, licensed under the BSD License.
+
+Bytecode Outline is free, see copyright. ASM is also free and parts of them are
+included to Bytecode Outline plugin distribution. Please visit
+http://asm.ow2.org/index.html to obtain latest information about ASM.
+
+Bytecode Outline currently supports only Eclipse default Java editor.
+
+
+Installation
+-----------------------------------------------------------------
+
+All what you need to install Bytecode Outline plugin is to unzip the zip file
+into you %Eclipse%/dropins directory and restart Eclipse. You don't need to do
+anymore to install Bytecode Outline.
+
+
+Usage
+-----------------------------------------------------------------
+
+Window -> Show View -> Other -> Java -> Bytecode to see bytecode of current
+Java editor/ Class file view.
+
+If "Link with editor" is on, then any selection in Java editor will be followed
+with selection of appropriated bytecode label, and vice - versa.
+
+Note: this bi-directional selection could only works, if your bytecode contains
+source lines/local variables information. Check your compiler settings, if you
+are not sure that your compiler generates debug information.
+
+If "show raw bytecode" is off, than local variable names will be shown instead
+of indexes, full qualified names replaced with simply class names, and
+primitive type abbreviations decoded to readable names.
+
+If "show current element only" is on, then only bytecode of current
+field/method node will be shown (if cursor is placed inside field/method name
+or body).
+
+Select two *.class/*.java files -> right click -> Compare with -> Each Other
+Bytecode
+
+Select one *.class/*.java file -> right click -> Compare with -> Another Class
+Bytecode
+
+to compare bytecode of selected class files. Compare works also for *.class
+files included in any referenced *.jar library.
diff --git a/org.eclipse.jdt.bcoview/about.html b/org.eclipse.jdt.bcoview/about.html
new file mode 100644
index 0000000..164f781
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/about.html
@@ -0,0 +1,36 @@
+<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
+    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml">
+<head>
+<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
+<title>About</title>
+</head>
+<body lang="EN-US">
+	<h2>About This Content</h2>
+
+	<p>November 30, 2017</p>
+	<h3>License</h3>
+
+	<p>
+		The Eclipse Foundation makes available all content in this plug-in
+		(&quot;Content&quot;). Unless otherwise indicated below, the Content
+		is provided to you under the terms and conditions of the Eclipse
+		Public License Version 2.0 (&quot;EPL&quot;). A copy of the EPL is
+		available at <a href="http://www.eclipse.org/legal/epl-2.0">http://www.eclipse.org/legal/epl-2.0</a>.
+		For purposes of the EPL, &quot;Program&quot; will mean the Content.
+	</p>
+
+	<p>
+		If you did not receive this Content directly from the Eclipse
+		Foundation, the Content is being redistributed by another party
+		(&quot;Redistributor&quot;) and different terms and conditions may
+		apply to your use of any object code in the Content. Check the
+		Redistributor's license that was provided with the Content. If no such
+		license exists, contact the Redistributor. Unless otherwise indicated
+		below, the terms and conditions of the EPL still apply to any source
+		code in the Content and such source code may be obtained at <a
+			href="http://www.eclipse.org/">http://www.eclipse.org</a>.
+	</p>
+
+</body>
+</html>
\ No newline at end of file
diff --git a/org.eclipse.jdt.bcoview/about.ini b/org.eclipse.jdt.bcoview/about.ini
new file mode 100644
index 0000000..667726a
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/about.ini
@@ -0,0 +1,14 @@
+# about.ini
+# contains information about a feature
+# java.io.Properties file (ISO 8859-1 with "\" escapes)
+# "%key" are externalized strings defined in about.properties
+# This file does not need to be translated.
+
+# Property "aboutText" contains blurb for "About" dialog (translated)
+aboutText=%featureText
+
+# Property "featureImage" contains path to feature image (32x32)
+featureImage=about32.png
+
+# Property "appName" contains name of the application (translated)
+appName=%featureName
\ No newline at end of file
diff --git a/org.eclipse.jdt.bcoview/about.properties b/org.eclipse.jdt.bcoview/about.properties
new file mode 100644
index 0000000..424d7ba8
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/about.properties
@@ -0,0 +1,5 @@
+featureName=Bytecode Outline
+featureText=Bytecode Outline\
+\n\
+(c) Copyright Andrey Loskutov. All rights reserved. \n\
+Visit https://github.com/iloveeclipse/plugins/
diff --git a/org.eclipse.jdt.bcoview/about32.png b/org.eclipse.jdt.bcoview/about32.png
new file mode 100644
index 0000000000000000000000000000000000000000..41c46f77b7cdb9190774b760b5fbdd032a294453
GIT binary patch
literal 409
zcmeAS@N?(olHy`uVBq!ia0vp^3LwnF3?v&v(vJfv=>VS)S4AL$fuVwd;Xjb9sMxn+
z#f}|2e*F0H|NsBQz|9drImVJ8zhDN3XE)M7oFs2|7lsa2Sq~tGv%n*=n1O*?7=#%a
zX3dcR3bL1Y`ns~;W0PPrV*2?{<N#1ey~H)5#5q4VH#M(>!7;DWH6^noBtJi=SRtvB
z%P}vdD78|-C%-tmv?RYQdEqrZpq3+^E{-7@=X)pmavd@da7)iKP+S^&U3v-gI_n3#
zHjaT;as%J6#(cTqmz1N%eNcxh{!_*0;D-C`CwFR@D{MY{x8rWkeR+ntGisy{+Mawe
zy-q&m(~4;)pD@>mzR-BS=0Nw3l38mGtbSe=IW2M%Q>&#*!t11@G%YUIFG>wBnfy5o
zW8c`HFyr`SsFWr!e}Ykm(#1=2ws-e*MEW_su@mK#S>g0&u56@=3-{G&byHVexUfC@
tXK>dWj@w(Wd~=qco~^Tz?U4L)-tJ0`RXbSQqJjQl@O1TaS?83{1OS$pm`nfw

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/asm-build.properties b/org.eclipse.jdt.bcoview/asm-build.properties
new file mode 100644
index 0000000..915f74c
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/asm-build.properties
@@ -0,0 +1 @@
+eclipse.home=D:/work/eclipse-SDK-4.9/eclipse
\ No newline at end of file
diff --git a/org.eclipse.jdt.bcoview/build.properties b/org.eclipse.jdt.bcoview/build.properties
new file mode 100644
index 0000000..93c5e0d
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/build.properties
@@ -0,0 +1,18 @@
+bin.includes = LICENSE.txt,\
+               README.txt,\
+               META-INF/,\
+               icons/,\
+               plugin.xml,\
+               .,\
+               about.html,\
+               .project,\
+               .settings/,\
+               about.ini,\
+               about.properties,\
+               about32.png
+
+jars.compile.order = .
+source.. = src/,\
+           test/
+output.. = bin/
+
diff --git a/org.eclipse.jdt.bcoview/findbugsExclude.xml b/org.eclipse.jdt.bcoview/findbugsExclude.xml
new file mode 100644
index 0000000..b513f4b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/findbugsExclude.xml
@@ -0,0 +1,19 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<FindBugsFilter>
+  <Match>
+    <Bug pattern="DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"/>
+  </Match>
+  <Match>
+    <Bug category="MALICIOUS_CODE"/>
+  </Match>
+  <Match>
+    <BugCode name="Se"/>
+  </Match>
+  <Match>
+    <Package name="~inner.*"/>
+  </Match>
+  <Match>
+    <Class name="~.*Test.*"/>
+  </Match>
+</FindBugsFilter>
diff --git a/org.eclipse.jdt.bcoview/icons/asm.gif b/org.eclipse.jdt.bcoview/icons/asm.gif
new file mode 100644
index 0000000000000000000000000000000000000000..de97178a3bf98c3dc1468d54e27cad0f01c56ccf
GIT binary patch
literal 253
zcmV<Z00RF<Nk%w1VGsZi0K^{vrint~>iGRzT<r1s=-K4+;pX%8`|`@r_4xaJbWh|R
z5#Q+d^=E9YS~dO@75@bV)Us*(D=hU>SmLyb<LmhPR$1XD6yV5@|J2m;Qdj>93jPTS
zw2(dd`uzU@0RR90A^8LW0018VEC2ui01yBW000Gg;3tk`Npfh4nj+V|FvPJg{7$k7
zbcg2`7aX7jKzIa*hz7wNk^qLIVM=vke4aw@=cyO~9?kKi*bL5*&BHUXcpT&MagbhP
z;R5nz>mhg;3=Iz&c5f7ihaM6X31M*?0g;g&83B!Ad1VWmo0JQeBMG9TqzNpiBOw4g
DZ+mr1

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/bytecodeview.gif b/org.eclipse.jdt.bcoview/icons/bytecodeview.gif
new file mode 100644
index 0000000000000000000000000000000000000000..365e3721618aac27c0756260327a9a6ee2795bd0
GIT binary patch
literal 373
zcmZ?wbhEHb6krfwxN5;5ZWR0e{r3~+?jE}QD6nDGrY-}Gq-hUc{&@H4*Ti{S-+lh|
z`TOsmzy8z|*xi5mBX8Qy_1jN={POGL*Iy^*In?Caeg5|Q>D!+VUj2CV=KHG;KY#rE
z^X<p)=kI^q+FMg!VEg0O@7EuHu52~_`s4SmIsVVy{aD&!a%EG-f+o`kC;F$=m|xwL
z`QzvBZ$JJ#eD%G$!0zSypO4@CXezYnEw`LpZFyx=W=n}pb-rC^nf3qw{~53W#h)yU
z3=9?wIv`1qpBUICIm|I|5RvLXcHn@6gH@r|vn39?Hj7!>ra5j_+Bkoz+vUK@_8Yw3
zTO3P$7CwCN(ZEJbbk9B&bpbg+p~hw*bx%fN4i2vFUM^u*Crt$b22M#%1}4d=0&d3o
zvlwKUX2~paGg4V3wv<V1g_F6#B8hbp8!b$AXL5?K6Q4QH$&j6$@AyeR<%t$@B4)h2
NdY42*<eVHCtO4rJt_c7D

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/hex_mode.gif b/org.eclipse.jdt.bcoview/icons/hex_mode.gif
new file mode 100644
index 0000000000000000000000000000000000000000..866c6cbf28fd4e6259c2f7836081072294aa53d7
GIT binary patch
literal 144
zcmZ?wbhEHb6krfw*v!oU1Zin$GiT0JQc@BW6uf))ZbwJQ?%lhMjg3P?LszX@_5c5W
zkRljR{K>+|z`)I*0}=q4;lN^BaME)%&yqC)%OtLeFsLX@IUu<1O_u~~VS$_l@2O9h
mE?xh3;6eZP557svhnIy|Ol09^Rh)REq{?hzS#&1@gEat~s4%er

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/hide_line_info.gif b/org.eclipse.jdt.bcoview/icons/hide_line_info.gif
new file mode 100644
index 0000000000000000000000000000000000000000..00482f89b65db08b15074b91633f0a31eb59ab0f
GIT binary patch
literal 97
zcmZ?wbhEHb6krfwSj5hd)3rUVd1FG|+KEe#7fskzHf3K-)vEvh|117vVPs%nXV75)
z0+3n;X0?i4cm5ezIX^WzJm(N6hm&(=m}Z#jvcgvOc}q0=m+dNzKXIWbUX8&T0N05m
AVgLXD

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/hide_locals.gif b/org.eclipse.jdt.bcoview/icons/hide_locals.gif
new file mode 100644
index 0000000000000000000000000000000000000000..59944352817aa7a772ccddc6e94a63003329af5f
GIT binary patch
literal 152
zcmZ?wbhEHb6krfw*v!i?Yu3EH{L<sck8jzsrN4i2OKaEOeFs*oSg~;7(sk?B?ccxu
z{Q2|$!GHk_6o0ZXGBEHm=zw@2GZ<K0H=Oibz1QNkZMf3OMVg(PCU9*NU{c=GlA+js
yNaIIi%uz#w<_8N492taqT7))i)?s3A`ywzQl83RuEa8HV0AtHkXT4%225SKC^F8$d

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/link_with_editor.gif b/org.eclipse.jdt.bcoview/icons/link_with_editor.gif
new file mode 100644
index 0000000000000000000000000000000000000000..aabf102acf34019eceb56e18240933057ffcb1e3
GIT binary patch
literal 160
zcmV;R0AK${Nk%w1VGsZi0J9GO{{8R$@x%P;sr~lVx|b&X_}%;LvHtko{`lVf@x%M&
zm;CIprfU$YZxFqN7XSbMA^8LW000jFEC2ui01yBW000C{@X6=gyqE%;u>)IoIY)t1
zXf-B5z$P!;T#aBics^r|qU@qc4@e=1a3hB?IQghNsmfr=kvJBHg?78GJ{aII!>3>{
OzdrMMtX{Vt5db@Ga!tel

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/raw_mode.gif b/org.eclipse.jdt.bcoview/icons/raw_mode.gif
new file mode 100644
index 0000000000000000000000000000000000000000..647455e3977b33baee67caecbf4e39e99b01f44d
GIT binary patch
literal 351
zcmV-l0igazNk%w1VGsZi0M$PL>7yu0V0!=LvGKJp`0JVY;+XgBne@+v_}h~E?zsKr
zj{EDY?W!yN`r-TY!2aZJ{pqv#-<JL9u>Sn-_tuR5<*fMLl<ux9>!>RA(}?}~-TvmJ
z{pz+^a*O=&!}QLB_Suhqk)vy%!|3Ym_rW$<dzoN*ie_|x{PDs3>ahL$>t~j@{P^1W
z#W(Y~G5N$dhL)&jd5rV9G4Qc2o~*oiik#}DDfhxP@Ukxb<*c;6$dRG4>ZB=Ja*Y4~
z|NsC0A^8LW002J#EC2ui01yBW000Jjz@KpVJA4krq%Z?$HZw{gh4&CxA2v!9qu5k(
zm5l<UL@+oINlF6YFc3-0Ws&fpJc-4{l8np<4h<{~4g@$6N&^NO6DkuL1_MzbGCr1;
xE>S`SH<u&@nnEv^EulgsG&><Zravn_BRU<eB0f5@ttK!vF(<7*0l`W^06S}~xN86a

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/reference.gif b/org.eclipse.jdt.bcoview/icons/reference.gif
new file mode 100644
index 0000000000000000000000000000000000000000..ea2f4895016280df2cb025f276fd0c0c22f70b84
GIT binary patch
literal 242
zcmZ?wbhEHb6krfwI3mmN|Nnn+qu5gyZ#5R%<&?JDdZ%U-ckVxV?d6yM&p!UYc<rv0
zNAlcB8L6c`-~Rr8`|ZDtciPPU>`%Y`PwC0~{r`V*QD<RAb6ZQ9t#_JhaBf{=bwy2m
zZ$}Z(SOzdq{K>+|z#z+@1LA?~bYRU-Q145*nK?<xgYg1a<AYs-3z#bOG#svUv@S^W
z;9)bAb>lP0;G5PX-@a(kfs{sx2U(64g4fr6%hKwf<11995Ttj1M@IT2Yng&?ca~h*
oY4ML;S3jyrn!ml#II)SPx0iDQXJ4<RssQ&4Zh^Eps)`KO0BKKWI{*Lx

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/selected_only.gif b/org.eclipse.jdt.bcoview/icons/selected_only.gif
new file mode 100644
index 0000000000000000000000000000000000000000..c27efb42ffd8af3b776c64f67e6ce1512cc4e772
GIT binary patch
literal 379
zcmV->0fhcXNk%w1VGsZi0M$PL;_LX{>Gy_|u5*d9hn&Fj_4<aBuJ-u*g_Ex8@cDa@
zw}F<s^!NMX>-XpH`Q_~R;Oh8#kGJvm`}X(y;_UcohOvT|yzKJ&@ALXJZ>HYp_uuLF
z_xby5fvrV&tcjMatfqfrZh*6|kS1uNMR=>3lW^ng_flSMp`@IqsF|y(m5rFGgn(e)
z>G-^~iG`G}@%8$5gqo3?r<tFj?ehA$vy9;C_xSny^7Z>?eW@E`p7!|sZ;iRXwut%q
z{Qv*|A^8LW002J#EC2ui01yBW000J<z@KnPEDC$bq!LN&`JT`yi0I<vID|!H(8=9O
z#M*8=K9F}TqKJ`W@ZRt^?<bNJB$cSX@>5}Qe+M}e1QrThJ2^io7c>_hdQl`lC<!?U
z8G?j{h#5aK4xuAB1vsXpI4~oh4>=Dyu(7f_KQav_4FI|T6uc)yD-bylSzBE;Aw(Ym
Z%p1)bEgCUI2nGlO0x#JD2G&DC06W+X#{U2S

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/source.gif b/org.eclipse.jdt.bcoview/icons/source.gif
new file mode 100644
index 0000000000000000000000000000000000000000..27ee7863064da61e28bd5b7290f643376b856e13
GIT binary patch
literal 582
zcmZ?wbhEHb6krfwc*el+^XKoc-+q7p@#n|SKi_}+e*5v)tM@-Yef|CI$Dgm?fB*dT
z=jofDFW&up^YPc~4?jPA`ThR$uZc^KKY01$`MaOb-u`&|>DQZ&KR<u_eecEhhp&D-
zdi~?++n-O~{CN4{*YkHjUIR`0@bl&SA0NN|{_y2j(ZrqiUw(h^>igq2K&hYaKL2|A
z>F4wJKVN?M`TonVPv3sO`uNkmZ0Xk@zrX+dt&udXrogVcz^<jlrY7I6v&_1q%(}JM
zrm4`TvCyWzz;;r##pG(szH-ana?2HM#!FjFmNc6zXfmBsZ?=7k!?YUnqYFJZO>%m0
zqJLAD!TJuvHSI<#TaB-5%DA#A^VZ&)tD7?a|NqZ0&_MAg3nK$V2!jsDA)q*6U|-x2
z($w72+TzpE+0oYI%hk`!Vi@St<HyC!#K9pR6g;)niNVO2lT*(-D8RqfWeKCWpo*rJ
zmUF8+r?I$_vM8&DhHI;*F+0ERCIdx9w^lE9V*yby1s*v$k5)T=V_x}F($e;=4w}aL
zI@%&KQc{ksmb`q%!lxu9En2N)uXDeZRPopl*wN0&#qF125Xi*bCfizdXMy8lH&-e1
Nye|ny3Ih}vtN~Xz@Kyi-

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/stackmap.gif b/org.eclipse.jdt.bcoview/icons/stackmap.gif
new file mode 100644
index 0000000000000000000000000000000000000000..f1e585bdf727a4a0c6b99516d0eacb6dff499214
GIT binary patch
literal 104
zcmZ?wbhEHb6krfwSj4~}5HlydXIEIy&Tt^=-FfcbtN;K1GcYhH{$ycfU|?g=0kVNA
z1sE8Zbu)I|`Nwy{Q<b}=!`4cYCAcTW(&<Ie+5=N_o!FZeWiHo@-YNC`BKK`xcO5Zd
G25SI7CnLZB

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/stackmapexp.gif b/org.eclipse.jdt.bcoview/icons/stackmapexp.gif
new file mode 100644
index 0000000000000000000000000000000000000000..0f7608560810c628896dd3b4d6807d23a0badada
GIT binary patch
literal 114
zcmZ?wbhEHb6krfw_{G5R@87?$zFk6b^UmFSWz`qNmuGeAT2kMkBE_F9j0`}a10q0b
znV8KvcHQ~scfwPZ+ami++y4dZz22!@*O!$o^ssU{GlM%(U?tlTv-Ml7n*%zUMf%#4
PABKAD6Y+9oVz34Pbdf4f

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/th_automatic.gif b/org.eclipse.jdt.bcoview/icons/th_automatic.gif
new file mode 100644
index 0000000000000000000000000000000000000000..45469ad67c4066af8a77b8d0a10d7343e4a58171
GIT binary patch
literal 358
zcmZ?wbhEHb6krfwxXQq=W%tF-8N1VKSC({aXq&RGW9pio>8q|k{?b2dMR@OtS-bDo
zbkAv?FmKA7rIwX@uRVG_ecqz?zy4qS{Qupr|1;(<`uO|**FXP%{Qdvv`~Nq;{(t!W
z|I45MuYdi2|NH;vKmWh~{l9$G>aTzQ|N8ged`7~GbK7fn)XrNpZ_(1(i<iz`v10nV
zHIvt_o^t)#>5c0qZr#v#^4O-mTRV4d>e;cWcmKAI<x?g;$c}qGv2965>;M1%8L$Dx
zpDc_F3>FMJAW4v)7}%N}<`j77NOf*rQdA~#NF_jHO=q_!U*}<Uw^C0LzN5!oYdvLN
z1azM|6yq}cY?f#Et*m)hbWZi3%P<vHHxg1&R*~uKGBP)nQqvMrR#lc^VrFEJ(Nd6=
z713yIpC>p^R)dFKm{&lkP^@sHv;a4kBnQjRUAuR3^GULW@C$Xxu!ii}>BwLW0L<>J
A3jhEB

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/th_horizontal.gif b/org.eclipse.jdt.bcoview/icons/th_horizontal.gif
new file mode 100644
index 0000000000000000000000000000000000000000..d590470446f37e7d83ccbcf3f3a85f82e4fc344b
GIT binary patch
literal 374
zcmZ?wbhEHb6krfwxXQrLHf3GM)HOZRS6zSnrGM6n@ZJ-%cHf^eXQ^f7-fw^YfBOCZ
z>gWIOe*K>@f6>R^|G)nE|K`{Kx4-^>`2GLOpZ~9a{eSoS|NGznKmYmv{qO&`zyE&%
z3Idh={XhBWCi58yE6#1N*-<-h(Y!@VXRlZ>eeLQg8`n+Tx}k6H*3O-qdiHPYcsFnI
zgY3B16Wjj(|Ia`cQ2fcl$iSe>paaqk@)HBw<O9<RJaqViPb@LAw9%dCuU=9pwMb0<
zJbSUM2-}^7nGYE&g_4;MH5l@GN4#b3TT$%gd@1SB{1@`ID$dG<@?0%CI@;pO&Ppk1
zQvEtw+I&jRimiOJwC4#aI`eXiiY;5bY`HT#x2&A3<eE5U9(HGz337rvve*PzoSD|H
fmp)X=A;9F!$SrbC<jnaC&J0(tUB9O5$Y2cs@QR>T

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/th_vertical.gif b/org.eclipse.jdt.bcoview/icons/th_vertical.gif
new file mode 100644
index 0000000000000000000000000000000000000000..dee0cbca025e70a1b11297b49c9f32e4325f8cd3
GIT binary patch
literal 352
zcmZ?wbhEHb6krfwxXQq=W%tF-8N27NKAv8?vZP}}+mv-3Q`huNU)4Wr#gsWq-~al5
z_4EH3^A~;n^Z&=+|6l(6fBozK```b~XC$mRx4mXZ?Yu?v7A>8<V#V~etEX&SH*xER
zzP(#JcW&z0zpdllyvYx;<6ci}`~Uwx1I>WqPZmZ721N!PkPRR|F|gGhm{8!M!)JYB
ziIL?Uop~2tBpE-^QJch>a=NvkZB}cGQX>xsBO}8i$+UGhJzNy0r?<^G`uO6F-`^#i
z#ku)f+uFsQ#kzZXdz?jsCW$)paL3LN;Bn^UR#1?iDZuH>F;7ljFg=q&ki(gsTYhtW
X9lJAIOZ#p%XV(1(4jxc+WUvMR=0bUJ

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/icons/verify.gif b/org.eclipse.jdt.bcoview/icons/verify.gif
new file mode 100644
index 0000000000000000000000000000000000000000..96028b369df54b722750daf87a3f92885717afed
GIT binary patch
literal 374
zcmV-+0g3)cNk%w1VGsZi0M!5h@$>rl`TX_w{Os`ghm@_1ma6CN`SA4o^Y;Ap_xt+$
z{rLI&UUs8xgsoq5mSA(1ae|=V==kF5_<)qOft0kHt;~Xvs+Xt0n5V#wo3O9C%<l91
zuDZ<i_xh5Xru+Q;`uqGprvIzK)BuY309BR%Mthl`p`oOlsi~IG(8RE<k+-sqwy}-7
zw2IKIc+{|a;mfMUnqkhVcE_S}%B6JEu6o<Vq`{kP#GY@ym}{+pQoNRGwUB4z*2dJq
zumAu5A^8LW002J#EC2ui01yBW000J)z@KnPEE<OyktlN{S~wgH$8zk&Vi3&bf`RB_
zJ>u*2pim}eieoHpE#B~V>qV@&7oX4v-l`E@EO;R#9}El&D=tJbDhh)kARQeEDl$SL
zKQt+i0TqS-C^SEhFpmNQsHi71mn9=5AqWNyh71NKI76=^2NJ%&5*{~1BO4LN$j1da
UL^cG^(9t_YK0Maf*gio3JF8p3UjP6A

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/plugin.xml b/org.eclipse.jdt.bcoview/plugin.xml
new file mode 100644
index 0000000..3de2f47
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/plugin.xml
@@ -0,0 +1,177 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<?eclipse version="3.0"?>
+<plugin>
+   <extension
+         point="org.eclipse.ui.views">
+      <view
+            name="Bytecode"
+            icon="icons/bytecodeview.gif"
+            category="org.eclipse.jdt.ui.java"
+            class="org.eclipse.jdt.bcoview.views.BytecodeOutlineView"
+            id="org.eclipse.jdt.bcoview.views.BytecodeOutlineView"/>
+      <view
+            name="Bytecode Reference"
+            icon="icons/reference.gif"
+            category="org.eclipse.jdt.ui.java"
+            class="org.eclipse.jdt.bcoview.views.BytecodeReferenceView"
+            id="org.eclipse.jdt.bcoview.views.BytecodeReferenceView"/>
+   </extension>
+
+   <extension point="org.eclipse.core.runtime.preferences">
+      <initializer class="org.eclipse.jdt.bcoview.preferences.BCOPreferenceInitializer"/>
+   </extension>
+
+   <extension
+         point="org.eclipse.ui.popupMenus">
+      <objectContribution
+            objectClass="org.eclipse.jdt.core.IOpenable"
+            id="org.eclipse.jdt.bcoview.CompareBytecodeActionContribution1">
+
+         <visibility>
+            <or>
+               <objectClass name="org.eclipse.jdt.core.IClassFile"/>
+               <objectClass name="org.eclipse.jdt.core.ICompilationUnit"/>
+            </or>
+         </visibility>
+         <menu
+               label="Compare With ..."
+               path="additions"
+               id="compareWithMenu">
+            <separator
+                  name="compareWithGroup">
+            </separator>
+         </menu>
+
+         <action
+               enablesFor="1"
+               label="Another Class Bytecode"
+               icon="icons/bytecodeview.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.OpenAction"
+               menubarPath="compareWithMenu/compareWithGroup"
+               id="org.eclipse.jdt.bcoview.CompareBytecodeAction">
+         </action>
+         <action
+               enablesFor="2"
+               label="Each Other Bytecode"
+               icon="icons/bytecodeview.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.CompareBytecodeAction"
+               menubarPath="compareWithMenu/compareWithGroup"
+               id="org.eclipse.jdt.bcoview.OpenAction">
+         </action>
+       </objectContribution>
+
+      <objectContribution
+            objectClass="org.eclipse.core.resources.IFile"
+            nameFilter="*.class"
+            id="org.eclipse.jdt.bcoview.CompareBytecodeActionContribution2">
+
+         <visibility>
+            <not>
+             <or>
+                   <objectClass name="org.eclipse.jdt.core.IClassFile"/>
+                   <objectClass name="org.eclipse.jdt.core.ICompilationUnit"/>
+               </or>
+            </not>
+         </visibility>
+         <menu
+               label="Compare With ..."
+               path="additions"
+               id="compareWithMenu">
+            <separator
+                  name="compareWithGroup">
+            </separator>
+         </menu>
+
+         <action
+               enablesFor="1"
+               label="Another Class Bytecode"
+               icon="icons/bytecodeview.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.OpenAction"
+               menubarPath="compareWithMenu/compareWithGroup"
+               id="org.eclipse.jdt.bcoview.CompareBytecodeAction">
+         </action>
+         <action
+               enablesFor="2"
+               label="Each Other Bytecode"
+               icon="icons/bytecodeview.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.CompareBytecodeAction"
+               menubarPath="compareWithMenu/compareWithGroup"
+               id="org.eclipse.jdt.bcoview.OpenAction">
+         </action>
+       </objectContribution>
+
+      <objectContribution
+            objectClass="org.eclipse.jdt.core.IMember"
+            nameFilter="*"
+            id="org.eclipse.jdt.bcoview.CompareBytecodeActionContribution3">
+
+         <visibility>
+            <not>
+             <or>
+                   <objectClass name="org.eclipse.jdt.core.IField"/>
+                   <objectClass name="org.eclipse.jdt.core.IType"/>
+               </or>
+            </not>
+         </visibility>
+         <menu
+               label="Compare With ..."
+               path="additions"
+               id="compareWithMenu">
+            <separator
+                  name="compareWithGroup">
+            </separator>
+         </menu>
+
+         <action
+               enablesFor="2"
+               label="Each Other Bytecode"
+               icon="icons/bytecodeview.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.CompareMemberBytecodeAction"
+               menubarPath="compareWithMenu/compareWithGroup"
+               id="org.eclipse.jdt.bcoview.OpenAction">
+         </action>
+       </objectContribution>
+
+   </extension>
+
+   <extension
+         point="org.eclipse.ui.popupMenus">
+      <viewerContribution
+            targetID="org.eclipse.jdt.bcoview.views.BytecodeOutlineView#ContextMenu"
+            id="org.eclipse.jdt.bcoview.OpenBytecodeReference">
+
+         <action
+               enablesFor="*"
+               label="Open bytecode reference"
+               icon="icons/reference.gif"
+               class="org.eclipse.jdt.bcoview.ui.actions.OpenBytecodeReferenceAction"
+               menubarPath="additions"
+               id="org.eclipse.jdt.bcoview.OpenReferenceAction"/>
+      </viewerContribution>
+   </extension>
+
+   <extension
+         point="org.eclipse.ui.perspectiveExtensions">
+      <perspectiveExtension
+          targetID="org.eclipse.jdt.ui.JavaPerspective">
+         <view
+               relative="org.eclipse.ui.views.ContentOutline"
+               visible="false"
+               id="org.eclipse.jdt.bcoview.views.BytecodeOutlineView"
+               relationship="stack">
+         </view>
+         <viewShortcut id="org.eclipse.jdt.bcoview.views.BytecodeOutlineView"/>
+      </perspectiveExtension>
+
+   </extension>
+
+   <extension
+        point="org.eclipse.ui.preferencePages">
+     <page
+           category="org.eclipse.jdt.ui.preferences.JavaBasePreferencePage"
+           class="org.eclipse.jdt.bcoview.preferences.BCOPreferencePage"
+           id="org.eclipse.jdt.bcoview.ByteCodeOutline.page"
+           name="Bytecode Outline">
+     </page>
+  </extension>
+</plugin>
diff --git a/org.eclipse.jdt.bcoview/raw_images/asm.psd b/org.eclipse.jdt.bcoview/raw_images/asm.psd
new file mode 100644
index 0000000000000000000000000000000000000000..10bca4244c370922d751892bf81853b97e27c809
GIT binary patch
literal 361560
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
A{Qv*}

literal 0
HcmV?d00001

diff --git a/org.eclipse.jdt.bcoview/site/feature.xml b/org.eclipse.jdt.bcoview/site/feature.xml
new file mode 100644
index 0000000..9010034
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/site/feature.xml
@@ -0,0 +1,49 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<feature
+      id="org.eclipse.jdt.bcoview.feature"
+      label="Bytecode Outline"
+      version="@FEATURE_VERSION@"
+      provider-name="Andrey Loskutov"
+      plugin="org.eclipse.jdt.bcoview">
+
+   <description url="https://github.com/iloveeclipse/plugins/wiki/Bytecode-Outline">
+      Bytecode outline and bytecode comparison view for java/class files.
+   </description>
+
+   <copyright url="..">
+      Copyright (c) 2004-2020 by Andrey Loskutov Loskutov@gmx.de
+	  All rights reserved.
+   </copyright>
+
+   <license url="https://www.eclipse.org/legal/epl-2.0/">
+      Copyright (c) 2004 - 2020 Andrey Loskutov, licensed under the Eclipse Public License 2.0.
+   </license>
+
+   <url>
+      <discovery label="Andrey Loskutov plugins" url="https://raw.githubusercontent.com/iloveeclipse/plugins/latest/"/>
+   </url>
+
+   <requires>
+      <import plugin="org.eclipse.ui"/>
+      <import plugin="org.eclipse.ui.editors"/>
+      <import plugin="org.eclipse.core.runtime"/>
+      <import plugin="org.eclipse.jface.text"/>
+      <import plugin="org.eclipse.ui.workbench.texteditor"/>
+      <import plugin="org.eclipse.jdt.ui"/>
+      <import plugin="org.eclipse.ui.ide"/>
+      <import plugin="org.eclipse.compare"/>
+      <import plugin="org.eclipse.ui.console"/>
+      <import plugin="org.eclipse.help.base"/>
+      <import plugin="org.eclipse.debug.ui"/>
+      <import plugin="org.eclipse.jdt.debug"/>
+      <import plugin="org.eclipse.jdt.core" version="3.6.0" match="greaterOrEqual"/>
+   </requires>
+
+   <plugin
+         id="org.eclipse.jdt.bcoview"
+         download-size="710"
+         install-size="710"
+         version="@PLUGIN_VERSION@"
+         unpack="false"/>
+
+</feature>
diff --git a/org.eclipse.jdt.bcoview/site/site.xml b/org.eclipse.jdt.bcoview/site/site.xml
new file mode 100644
index 0000000..81b2089
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/site/site.xml
@@ -0,0 +1,47 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<site>
+   <description url="http://asm.objectweb.org/eclipse/bco/index.html">
+      Bytecode Outline Plugin Update Site
+   </description>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.1.3.jar" id="de.loskutov.BytecodeOutline.feature" version="2.1.3">
+      <category name="Bytecode Outline for Eclipse 3.1"/>
+   </feature>
+   <category-def name="Bytecode Outline for Eclipse 3.1" label="Bytecode Outline for Eclipse 3.2"/>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.1.3.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.1.3.jar"/>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.2.3.jar" id="de.loskutov.BytecodeOutline.feature" version="2.2.3">
+      <category name="Bytecode Outline for Eclipse 3.3"/>
+   </feature>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.2.3.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.2.3.jar"/>
+   <category-def name="Bytecode Outline for Eclipse 3.3" label="Bytecode Outline for Eclipse 3.3"/>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.2.6.jar" id="de.loskutov.BytecodeOutline.feature" version="2.2.6">
+      <category name="Bytecode Outline for Eclipse 3.4"/>
+   </feature>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.2.12.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.2.12.jar"/>
+   <category-def name="Bytecode Outline for Eclipse 3.4" label="Bytecode Outline for Eclipse 3.4"/>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.3.0.jar" id="de.loskutov.BytecodeOutline.feature" version="2.3.0">
+      <category name="Bytecode Outline for Eclipse 3.5"/>
+   </feature>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.3.0.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.3.0.jar"/>
+   <category-def name="Bytecode Outline for Eclipse 3.5" label="Bytecode Outline for Eclipse 3.5"/>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.3.1.jar" id="de.loskutov.BytecodeOutline.feature" version="2.3.1">
+      <category name="Bytecode Outline for Eclipse 3.6-3.7"/>
+   </feature>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.3.1.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.3.1.jar"/>
+
+   <feature url="features/de.loskutov.BytecodeOutline.feature_2.4.3.jar" id="de.loskutov.BytecodeOutline.feature" version="2.4.3">
+      <category name="Bytecode Outline for Eclipse 3.6-4.4"/>
+   </feature>
+   <archive path="plugins/de.loskutov.BytecodeOutline_2.4.3.jar" url="http://download.forge.objectweb.org/asm/de.loskutov.BytecodeOutline_2.4.3.jar"/>
+   <category-def name="Bytecode Outline for Eclipse 3.6-4.4" label="Bytecode Outline for Eclipse 3.6-4.4"/>
+
+   <feature url="features/org.eclipse.jdt.bcoview.feature_@FEATURE_VERSION@.jar" id="org.eclipse.jdt.bcoview.feature" version="@FEATURE_VERSION@">
+      <category name="Bytecode Outline for Eclipse 4.7-4.10"/>
+   </feature>
+   <category-def name="Bytecode Outline for Eclipse 4.7-4.10" label="Bytecode Outline for Eclipse 4.7-4.10"/>
+
+</site>
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePlugin.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePlugin.java
new file mode 100644
index 0000000..cd851a6
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePlugin.java
@@ -0,0 +1,143 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview;
+
+import java.util.MissingResourceException;
+import java.util.ResourceBundle;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.jface.dialogs.MessageDialog;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.osgi.framework.BundleContext;
+
+/**
+ * The main plugin class to be used in the desktop.
+ */
+public class BytecodeOutlinePlugin extends AbstractUIPlugin {
+    //The shared instance.
+    private static BytecodeOutlinePlugin plugin;
+    //Resource bundle.
+    private ResourceBundle resourceBundle;
+    public static boolean DEBUG;
+
+    /**
+     * The constructor.
+     */
+    public BytecodeOutlinePlugin() {
+        super();
+        if(plugin != null){
+            throw new IllegalStateException("Bytecode outline plugin is a singleton!");
+        }
+        plugin = this;
+        try {
+            resourceBundle = ResourceBundle
+                .getBundle("org.eclipse.jdt.bcoview.BytecodeOutlinePluginResources"); //$NON-NLS-1$
+        } catch (MissingResourceException x) {
+            resourceBundle = null;
+        }
+    }
+
+    /**
+     * This method is called upon plug-in activation
+     * @param context
+     * @throws Exception
+     */
+    @Override
+    public void start(BundleContext context) throws Exception {
+        super.start(context);
+        DEBUG = isDebugging();
+    }
+
+    /**
+     * Returns the shared instance.
+     * @return plugin
+     */
+    public static BytecodeOutlinePlugin getDefault() {
+        return plugin;
+    }
+
+    /**
+     * Returns the string from the plugin's resource bundle, or 'key' if not found.
+     * @param key
+     * @return translation
+     */
+    public static String getResourceString(String key) {
+        ResourceBundle bundle = BytecodeOutlinePlugin.getDefault()
+            .getResourceBundle();
+        try {
+            return (bundle != null)
+                ? bundle.getString(key)
+                : key;
+        } catch (MissingResourceException e) {
+            return key;
+        }
+    }
+
+    /**
+     * Returns the plugin's resource bundle,
+     */
+    public ResourceBundle getResourceBundle() {
+        return resourceBundle;
+    }
+
+    /**
+     * Returns the workspace instance.
+     * @return shell object
+     */
+    public static Shell getShell() {
+        return getDefault().getWorkbench().getActiveWorkbenchWindow()
+            .getShell();
+    }
+
+    /**
+     * @param messageID
+     * @param error
+     */
+    public static void error(String messageID, Throwable error) {
+        Shell shell = getShell();
+        String message = getResourceString("BytecodeOutline.Error"); //$NON-NLS-1$
+        if (messageID != null) {
+            message = getResourceString(messageID);
+        }
+        if (error != null) {
+            message += " " + error.getMessage();
+        }
+        MessageDialog.openError(
+            shell, getResourceString("BytecodeOutline.Title"), //$NON-NLS-1$
+            message);
+
+        getDefault().getLog().log(
+            new Status(IStatus.ERROR, "BytecodeOutline", 0, message, error)); //$NON-NLS-1$
+    }
+
+    /**
+     * @param statusID one of IStatus. constants like IStatus.ERROR etc
+     * @param error
+     */
+    public static void log(Throwable error, int statusID) {
+        String message = error.getMessage();
+        if(message == null){
+            message = error.toString();
+        }
+        getDefault().getLog()
+            .log(
+                new Status(
+                    statusID,
+                    "BytecodeOutline", 0, message, error)); //$NON-NLS-1$
+    }
+
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePluginResources.properties b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePluginResources.properties
new file mode 100644
index 0000000..dfbcb4b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/BytecodeOutlinePluginResources.properties
@@ -0,0 +1,102 @@
+################################################################################
+# Copyright (c) 2018 Andrey Loskutov and others.
+#
+# This program and the accompanying materials
+# are made available under the terms of the Eclipse Public License 2.0
+# which accompanies this distribution, and is available at
+# https://www.eclipse.org/legal/epl-2.0/
+#
+# SPDX-License-Identifier: EPL-2.0
+#
+# Contributors:
+#     Andrey Loskutov - initial API and implementation
+################################################################################
+BytecodeOutline.Title=Bytecode Outline
+BytecodeOutline.Error=Error (Bytecode Outline)
+BytecodeOutlineView.lvt.tooltip=LVT
+BytecodeOutlineView.stack.tooltip=STACK
+BytecodeOutlineView.lvt.header=Vars
+BytecodeOutlineView.stack.header=Stack
+BytecodeOutlineView.select_all.label=Select &All@Ctrl+A
+BytecodeOutlineView.select_all.tooltip=Select All
+BytecodeOutlineView.select_all.description=Select All
+BytecodeOutlineView.copy.label=Copy
+BytecodeOutlineView.copy.tooltip=Copy
+BytecodeOutlineView.copy.description=Copy
+BytecodeOutlineView.find_replace.label=&Find...@Ctrl+F
+BytecodeOutlineView.find_replace.tooltip=Find in bytecode
+BytecodeOutlineView.find_replace.description=Find in bytecode
+BytecodeOutlineView.find_replace.image=
+
+BytecodeOutlineView.toggle.vertical.label=&Vertical View Orientation
+BytecodeOutlineView.toggle.horizontal.label=&Horizontal View Orientation
+BytecodeOutlineView.toggle.automatic.label=&Automatic View Orientation
+
+BytecodeReferenceView.empty.selection.text=<html><head><title>Bytecode reference</title></head><body bgcolor='#D3D3D3'>Please select any bytecode instruction in the bytecode outline view.</body></html>
+
+BCOPreferencePage.description=Bytecode Outline View Settings
+BCOPreferencePage.defaultsGroup=Outline
+BCOPreferencePage.compareGroup=Compare
+
+BCOPreferencePage.showVariables=Show variables
+BCOPreferencePage.showLineInfo=Show line info
+BCOPreferencePage.showStackMap=Show stack map
+BCOPreferencePage.expandStackMap=Expand stack map
+BCOPreferencePage.recalculateStackMap=Recalculate stack map
+BCOPreferencePage.showRawBytecode=Show internal types
+BCOPreferencePage.showAnalyzer=Show analyzer pane
+BCOPreferencePage.showAsmifierCode=Show ASMifier code
+BCOPreferencePage.showOnlySelected=Show bytecode for selected element only
+BCOPreferencePage.linkViewToEditor=Link Bytecode Outline view to editor
+BCOPreferencePage.linkRefViewToEditor=Link Bytecode Reference view to editor
+BCOPreferencePage.showHexValues=Show hex values for numeric constants
+
+BCOPreferencePage.diffExpandStackMap=Expand stack map
+BCOPreferencePage.diffShowStackMap=Show stack map
+BCOPreferencePage.diffShowLineInfo=Show line info
+BCOPreferencePage.diffShowVariables=Show variables
+BCOPreferencePage.diffShowAsmifierCode=Show ASMifier code
+
+action.showVariables.text=Show local variables
+action.showVariables.toolTipText=Show local variables (if available in bytecode)
+action.showVariables.image=icons/hide_locals.gif
+
+action.showLineInfo.text=Show line info
+action.showLineInfo.toolTipText=Show line info (if available in bytecode)
+action.showLineInfo.image=icons/hide_line_info.gif
+
+action.showStackmap.text=Show StackMap
+action.showStackmap.toolTipText=Show StackMap info (if available in bytecode)
+action.showStackmap.image=icons/stackmap.gif
+
+action.expandStackmap.text=Expand StackMap
+action.expandStackmap.toolTipText=Expand StackMap frames (if StackMap is available in bytecode)
+action.expandStackmap.image=icons/stackmapexp.gif
+
+action.showASMifierCode.text=Toggle ASMifier mode on/off
+action.showASMifierCode.toolTipText=Show ASMified code
+action.showASMifierCode.image=icons/asm.gif
+
+action.showAnalyzer.text=Show bytecode analyzer pane
+action.showAnalyzer.toolTipText=Show state of the execution stack frames
+action.showAnalyzer.image=icons/verify.gif
+
+action.showRawBytecode.text=Show readable bytecode
+action.showRawBytecode.toolTipText=Show internal types
+action.showRawBytecode.image=icons/raw_mode.gif
+
+action.showOnlySelectedElement.text=Show current element only
+action.showOnlySelectedElement.toolTipText=Show bytecode for current field/method only
+action.showOnlySelectedElement.image=icons/selected_only.gif
+
+action.linkViewToEditor.text=Link with editor
+action.linkViewToEditor.toolTipText=Link With Editor
+action.linkViewToEditor.image=icons/link_with_editor.gif
+
+action.linkRefViewToEditor.text=Link with editor
+action.linkRefViewToEditor.toolTipText=Link With Editor
+action.linkRefViewToEditor.image=icons/link_with_editor.gif
+
+action.showHexValues.text=Show values in hex format
+action.showHexValues.toolTipText=Show numerical constant values in hex format
+action.showHexValues.image=icons/hex_mode.gif
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedASMifierClassVisitor.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedASMifierClassVisitor.java
new file mode 100644
index 0000000..3fbd963
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedASMifierClassVisitor.java
@@ -0,0 +1,348 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.InsnList;
+import org.objectweb.asm.tree.LabelNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.util.ASMifier;
+import org.objectweb.asm.util.TraceMethodVisitor;
+
+public class CommentedASMifierClassVisitor extends ASMifier implements ICommentedClassVisitor {
+
+    protected final boolean showLines;
+    protected final boolean showLocals;
+    protected final boolean showStackMap;
+    private final DecompilerOptions options;
+    private JavaVersion javaVersion;
+    private int accessFlags;
+    private LabelNode currentLabel;
+    private int currentInsn;
+    private ASMifier dummyAnnVisitor;
+    private DecompiledMethod currMethod;
+    private String className;
+    private final ClassNode classNode;
+
+    private CommentedASMifierClassVisitor(ClassNode classNode, final DecompilerOptions options, String name, int id) {
+        super(DecompilerOptions.LATEST_ASM_VERSION, name, id);
+        this.classNode = classNode;
+        this.options = options;
+        showLines = options.modes.get(BCOConstants.F_SHOW_LINE_INFO);
+        showLocals = options.modes.get(BCOConstants.F_SHOW_VARIABLES);
+        showStackMap = options.modes.get(BCOConstants.F_SHOW_STACKMAP);
+    }
+
+    public CommentedASMifierClassVisitor(ClassNode classNode, final DecompilerOptions options) {
+        this(classNode, options, "cw", 0);
+    }
+
+
+    @Override
+    protected ASMifier createASMifier(String name1, int id1) {
+        CommentedASMifierClassVisitor classVisitor = new CommentedASMifierClassVisitor(
+            classNode, options, name1, id1);
+        classVisitor.currMethod = currMethod;
+        return classVisitor;
+    }
+
+    private void addIndex(final int opcode) {
+        text.add(new Index(currentLabel, currentInsn++, opcode));
+    }
+
+    void setCurrentLabel(LabelNode currentLabel) {
+        this.currentLabel = currentLabel;
+    }
+
+    private boolean decompilingEntireClass() {
+        return options.methodFilter == null && options.fieldFilter == null;
+    }
+
+    @Override
+    public void visit(int version, int access, String name1, String signature,
+        String superName, String[] interfaces) {
+        if(decompilingEntireClass()) {
+            super.visit(version, access, name1, signature, superName, interfaces);
+        }
+        this.className = name;
+        javaVersion = new JavaVersion(version);
+        this.accessFlags = access;
+    }
+
+    @Override
+    public ASMifier visitClassAnnotation(String desc, boolean visible) {
+        if (decompilingEntireClass()) {
+            return super.visitClassAnnotation(desc, visible);
+        }
+        return getDummyVisitor();
+    }
+
+    @Override
+    public void visitClassAttribute(Attribute attr) {
+        if (decompilingEntireClass()) {
+            super.visitClassAttribute(attr);
+        }
+    }
+
+    @Override
+    public void visitClassEnd() {
+        if (decompilingEntireClass()) {
+            super.visitClassEnd();
+        }
+    }
+
+    @Override
+    public void visitInnerClass(String name1, String outerName,
+        String innerName, int access) {
+        if (decompilingEntireClass()) {
+            super.visitInnerClass(name1, outerName, innerName, access);
+        }
+    }
+
+    @Override
+    public void visitOuterClass(String owner, String name1, String desc) {
+        if (decompilingEntireClass()) {
+            super.visitOuterClass(owner, name1, desc);
+        }
+    }
+
+    @Override
+    public void visitSource(String file, String debug) {
+        if (decompilingEntireClass()) {
+            super.visitSource(file, debug);
+        }
+    }
+
+    @Override
+    public ASMifier visitMethod(int access, String name1, String desc,
+        String signature, String[] exceptions) {
+        if(options.fieldFilter != null || options.methodFilter != null && !options.methodFilter.equals(name1 + desc)) {
+            return getDummyVisitor();
+        }
+
+        MethodNode meth = null;
+        List<String> exList = Arrays.asList(exceptions);
+        for (MethodNode mn : classNode.methods) {
+            if(mn.name.equals(name1) && mn.desc.equals(desc) && mn.exceptions.equals(exList)) {
+                meth = mn;
+                break;
+            }
+        }
+        assert meth != null;
+
+        currMethod = new DecompiledMethod(className, new HashMap<Label, Integer>(), meth, options, access);
+        ASMifier textifier = super.visitMethod(access, name1, desc, signature, exceptions);
+        TraceMethodVisitor tm = new TraceMethodVisitor(textifier);
+        meth.accept(tm);
+
+        Object methodEnd = text.remove(text.size() - 1);
+        Object methodtext = text.remove(text.size() - 1);
+        currMethod.setText((List<?>) methodtext);
+        text.add(currMethod);
+        text.add(methodEnd);
+        return textifier;
+    }
+
+    @Override
+    public ASMifier visitField(int access, String name1, String desc,
+        String signature, Object value) {
+        if (options.methodFilter != null) {
+            return getDummyVisitor();
+        }
+        if (options.fieldFilter != null && !name1.equals(options.fieldFilter)) {
+            return getDummyVisitor();
+        }
+        return super.visitField(access, name1, desc, signature, value);
+    }
+
+    @Override
+    public void visitFieldInsn(final int opcode, final String owner1,
+        final String name1, final String desc) {
+        addIndex(opcode);
+        super.visitFieldInsn(opcode, owner1, name1, desc);
+    }
+
+
+    @Override
+    public void visitFrame(final int type, final int nLocal,
+        final Object[] local, final int nStack, final Object[] stack) {
+        if (showStackMap) {
+            addIndex(-1);
+            super.visitFrame(type, nLocal, local, nStack, stack);
+        }
+    }
+
+    @Override
+    public void visitInsn(final int opcode) {
+        addIndex(opcode);
+        super.visitInsn(opcode);
+    }
+
+    @Override
+    public void visitIntInsn(int opcode, int operand) {
+        addIndex(opcode);
+       super.visitIntInsn(opcode, operand);
+    }
+
+
+    @Override
+    public void visitJumpInsn(final int opcode, final Label label) {
+        addIndex(opcode);
+        super.visitJumpInsn(opcode, label);
+    }
+
+    @Override
+    public void visitLabel(Label label) {
+        addIndex(-1);
+        super.visitLabel(label);
+
+        InsnList instructions = currMethod.meth.instructions;
+        LabelNode currLabel = null;
+        for (int i = 0; i < instructions.size(); i++) {
+            AbstractInsnNode insnNode = instructions.get(i);
+            if(insnNode instanceof LabelNode) {
+                LabelNode labelNode = (LabelNode) insnNode;
+                if(labelNode.getLabel() == label) {
+                    currLabel = labelNode;
+                }
+            }
+        }
+        setCurrentLabel(currLabel);
+    }
+
+    @Override
+    public void visitLdcInsn(final Object cst) {
+        addIndex(Opcodes.LDC);
+       super.visitLdcInsn(cst);
+    }
+
+    @Override
+    public void visitInvokeDynamicInsn(String name1, String desc, Handle bsm,
+        Object... bsmArgs) {
+        addIndex(Opcodes.INVOKEDYNAMIC);
+        super.visitInvokeDynamicInsn(name1, desc, bsm, bsmArgs);
+    }
+
+    @Override
+    public void visitIincInsn(final int var, final int increment) {
+        addIndex(Opcodes.IINC);
+        super.visitIincInsn(var, increment);
+    }
+
+    @Override
+    public void visitLineNumber(int line, Label start) {
+        if (showLines) {
+            addIndex(-1);
+            currMethod.addLineNumber(start, Integer.valueOf(line));
+            super.visitLineNumber(line, start);
+        }
+    }
+
+    @Override
+    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
+        final Label[] labels) {
+        addIndex(Opcodes.LOOKUPSWITCH);
+        super.visitLookupSwitchInsn(dflt, keys, labels);
+    }
+
+    @Override
+    public void visitLocalVariable(String name1, String desc,
+        String signature, Label start, Label end, int index) {
+        if (showLocals) {
+            super.visitLocalVariable(
+                name1, desc, signature, start, end, index);
+        }
+    }
+
+    @Override
+    public void visitMaxs(int maxStack, int maxLocals) {
+        super.visitMaxs(maxStack, maxLocals);
+    }
+
+    @Override
+    public void visitMethodInsn(final int opcode, final String owner,
+        final String name1, final String desc, boolean itf) {
+        addIndex(opcode);
+        super.visitMethodInsn(opcode, owner, name1, desc, itf);
+    }
+
+    @Override
+    public void visitMultiANewArrayInsn(final String desc, final int dims) {
+        addIndex(Opcodes.MULTIANEWARRAY);
+        super.visitMultiANewArrayInsn(desc, dims);
+    }
+
+    @Override
+    public void visitTableSwitchInsn(final int min, final int max,
+        final Label dflt, final Label... labels) {
+        addIndex(Opcodes.TABLESWITCH);
+        super.visitTableSwitchInsn(min, max, dflt, labels);
+    }
+
+    @Override
+    public void visitTypeInsn(final int opcode, final String desc) {
+        addIndex(opcode);
+        super.visitTypeInsn(opcode, desc);
+    }
+
+    @Override
+    public void visitVarInsn(final int opcode, final int var) {
+        addIndex(opcode);
+        super.visitVarInsn(opcode, var);
+    }
+
+
+
+    @Override
+    public DecompiledClassInfo getClassInfo() {
+        return new DecompiledClassInfo(javaVersion, accessFlags);
+    }
+
+    private ASMifier getDummyVisitor(){
+        if (dummyAnnVisitor == null) {
+            dummyAnnVisitor = new ASMifier(DecompilerOptions.LATEST_ASM_VERSION, "", -1) {
+                @Override
+                public void visitAnnotationEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitClassEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitFieldEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitMethodEnd() {
+                    text.clear();
+                }
+            };
+        }
+        return dummyAnnVisitor;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedClassVisitor.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedClassVisitor.java
new file mode 100644
index 0000000..32e5cbf
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/CommentedClassVisitor.java
@@ -0,0 +1,601 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eric Bruneton - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.objectweb.asm.Attribute;
+import org.objectweb.asm.Handle;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.AbstractInsnNode;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.InsnList;
+import org.objectweb.asm.tree.LabelNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.util.Printer;
+import org.objectweb.asm.util.Textifier;
+import org.objectweb.asm.util.TraceMethodVisitor;
+
+public class CommentedClassVisitor extends Textifier implements ICommentedClassVisitor {
+
+    protected final boolean raw;
+    protected final boolean showLines;
+    protected final boolean showLocals;
+    protected final boolean showStackMap;
+    protected final boolean showHex;
+    private final DecompilerOptions options;
+
+    private DecompiledMethod currMethod;
+    private String className;
+    private JavaVersion javaVersion;
+    private int accessFlags;
+    private Textifier dummyAnnVisitor;
+    private final ClassNode classNode;
+
+    private LabelNode currentLabel;
+
+    private int currentInsn;
+
+    public CommentedClassVisitor(ClassNode classNode, final DecompilerOptions options) {
+        super(DecompilerOptions.LATEST_ASM_VERSION);
+        this.classNode = classNode;
+        this.options = options;
+        raw = !options.modes.get(BCOConstants.F_SHOW_RAW_BYTECODE);
+        showLines = options.modes.get(BCOConstants.F_SHOW_LINE_INFO);
+        showLocals = options.modes.get(BCOConstants.F_SHOW_VARIABLES);
+        showStackMap = options.modes.get(BCOConstants.F_SHOW_STACKMAP);
+        showHex = options.modes.get(BCOConstants.F_SHOW_HEX_VALUES);
+        javaVersion = new JavaVersion(0);
+    }
+
+    private boolean decompilingEntireClass() {
+        return options.methodFilter == null && options.fieldFilter == null;
+    }
+
+    @Override
+    public void visit(int version, int access, String name, String signature,
+        String superName, String[] interfaces) {
+        if(decompilingEntireClass()) {
+            super.visit(version, access, name, signature, superName, interfaces);
+        }
+        this.className = name;
+        javaVersion = new JavaVersion(version);
+        this.accessFlags = access;
+    }
+
+    @Override
+    public Textifier visitClassAnnotation(String desc, boolean visible) {
+        if (decompilingEntireClass()) {
+            return super.visitClassAnnotation(desc, visible);
+        }
+        return getDummyVisitor();
+    }
+
+    @Override
+    public void visitClassAttribute(Attribute attr) {
+        if (decompilingEntireClass()) {
+            super.visitClassAttribute(attr);
+        }
+    }
+
+    @Override
+    public void visitClassEnd() {
+        if (decompilingEntireClass()) {
+            super.visitClassEnd();
+        }
+    }
+
+    @Override
+    public Textifier visitField(int access, String name, String desc,
+        String signature, Object value) {
+        if (options.methodFilter != null) {
+            return getDummyVisitor();
+        }
+        if (options.fieldFilter != null && !name.equals(options.fieldFilter)) {
+            return getDummyVisitor();
+        }
+        return super.visitField(access, name, desc, signature, value);
+    }
+
+    @Override
+    public void visitInnerClass(String name, String outerName,
+        String innerName, int access) {
+        if (decompilingEntireClass()) {
+            super.visitInnerClass(name, outerName, innerName, access);
+        }
+    }
+
+    @Override
+    public void visitOuterClass(String owner, String name, String desc) {
+        if (decompilingEntireClass()) {
+            super.visitOuterClass(owner, name, desc);
+        }
+    }
+
+    @Override
+    public void visitSource(String file, String debug) {
+        if (decompilingEntireClass()) {
+            super.visitSource(file, debug);
+        }
+    }
+
+    @Override
+    public Textifier visitMethod(int access, String name, String desc,
+        String signature, String[] exceptions) {
+        if(options.fieldFilter != null || options.methodFilter != null && !options.methodFilter.equals(name + desc)) {
+            return getDummyVisitor();
+        }
+
+        MethodNode meth = null;
+        List<String> exList = Arrays.asList(exceptions);
+        for (MethodNode mn : classNode.methods) {
+            if(mn.name.equals(name) && mn.desc.equals(desc) && mn.exceptions.equals(exList)) {
+                meth = mn;
+                break;
+            }
+        }
+        assert meth != null;
+
+        currMethod = new DecompiledMethod(className, new HashMap<Label, Integer>(), meth, options, access);
+        Textifier textifier = super.visitMethod(access, name, desc, signature, exceptions);
+        TraceMethodVisitor tm = new TraceMethodVisitor(textifier);
+        meth.accept(tm);
+
+        Object methodtext = text.remove(text.size() - 1);
+        currMethod.setText((List<?>) methodtext);
+        text.add(currMethod);
+        return textifier;
+    }
+
+    @Override
+    protected void appendDescriptor(final int type, final String desc) {
+        appendDescriptor(stringBuilder, type, desc, raw);
+    }
+
+    protected void appendDescriptor(final StringBuilder buf1, final int type,
+        final String desc, final boolean raw1) {
+        if (desc == null) {
+            return;
+        }
+        if (raw1) {
+            if (type == CLASS_SIGNATURE || type == FIELD_SIGNATURE
+                || type == METHOD_SIGNATURE) {
+                buf1.append("// signature ").append(desc).append('\n');
+            } else {
+                buf1.append(desc);
+            }
+        } else {
+            switch (type) {
+                case INTERNAL_NAME :
+                    buf1.append(eatPackageNames(desc, '/'));
+                    break;
+                case METHOD_DESCRIPTOR :
+                case HANDLE_DESCRIPTOR :
+                    buf1.append("(");
+                    Type[] types = Type.getArgumentTypes(desc);
+                    for (int i = 0; i < types.length; ++i) {
+                        if (i > 0) {
+                            buf1.append(", ");
+                        }
+                        buf1.append(getSimpleName(types[i]));
+                    }
+                    buf1.append(") : ");
+                    Type returnType = Type.getReturnType(desc);
+                    buf1.append(getSimpleName(returnType));
+                    break;
+                case FIELD_DESCRIPTOR :
+                    if ("T".equals(desc)) {
+                        buf1.append("top");
+                    } else if ("N".equals(desc)) {
+                        buf1.append("null");
+                    } else if ("U".equals(desc)) {
+                        buf1.append("uninitialized_this");
+                    } else {
+                        buf1.append(getSimpleName(Type.getType(desc)));
+                    }
+                    break;
+
+                case METHOD_SIGNATURE :
+                case FIELD_SIGNATURE :
+                    // fine tuning of identation - we have two tabs in this case
+                    if (stringBuilder.lastIndexOf(tab) == stringBuilder.length() - tab.length()) {
+                        stringBuilder.delete(stringBuilder.lastIndexOf(tab), stringBuilder.length());
+                    }
+                    break;
+
+                case CLASS_SIGNATURE :
+                    // ignore - show only in "raw" mode
+                    break;
+                default :
+                    buf1.append(desc);
+            }
+        }
+    }
+
+    /**
+     * @param t
+     * @return simply class name without any package/outer class information
+     */
+    public static String getSimpleName(Type t) {
+        String name = t.getClassName();
+        return eatPackageNames(name, '.');
+    }
+
+    /**
+     * @param name Java type name(s).
+     * @return simply class name(s) without any package/outer class information, but with
+     * "generics" information from given name parameter.
+     */
+    private static String eatPackageNames(String name, char separator) {
+        int lastPoint = name.lastIndexOf(separator);
+        if (lastPoint < 0) {
+            return name;
+        }
+        StringBuffer sb = new StringBuffer(name);
+        do {
+            int start = getPackageStartIndex(sb, separator, lastPoint);
+            sb.delete(start, lastPoint + 1);
+            lastPoint = lastIndexOf(sb, separator, start);
+        } while (lastPoint > 0);
+
+        return sb.toString();
+    }
+
+    private static int lastIndexOf(StringBuffer chars, char c, int lastPoint) {
+        for (int i = lastPoint - 1; i > 0; i--) {
+            if (chars.charAt(i) == c) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
+    private static int getPackageStartIndex(StringBuffer chars, char c,
+        int firstPoint) {
+        for (int i = firstPoint - 1; i >= 0; i--) {
+            char curr = chars.charAt(i);
+            if (curr != c && !Character.isJavaIdentifierPart(curr)) {
+                return i + 1;
+            }
+        }
+        return 0;
+    }
+
+
+    /**
+     * control chars names
+     */
+    private static final String[] CHAR_NAMES = {"NUL", "SOH", "STX", "ETX",
+        "EOT", "ENQ", "ACK", "BEL", "BS", "HT", "LF", "VT", "FF", "CR", "SO",
+        "SI", "DLE", "DC1", "DC2", "DC3", "DC4", "NAK", "SYN", "ETB", "CAN",
+        "EM", "SUB", "ESC", "FS", "GS", "RS", "US", // "Sp"
+    };
+
+    private Index getIndex(Label label) {
+        Index index;
+        for (int i = 0; i < text.size(); i++) {
+            Object o = text.get(i);
+            if (o instanceof Index) {
+                index = (Index) o;
+                if (index.labelNode != null
+                    && index.labelNode.getLabel() == label) {
+                    return index;
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public void visitFrame(int type, int nLocal, Object[] local,
+        int nStack, Object[] stack) {
+        if (showStackMap) {
+            addIndex(-1);
+            super.visitFrame(type, nLocal, local, nStack, stack);
+        }
+    }
+
+    @Override
+    public void visitMethodInsn(final int opcode, final String owner,
+        final String name, final String desc, boolean itf) {
+        addIndex(opcode);
+        stringBuilder.setLength(0);
+        stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ');
+        appendDescriptor(INTERNAL_NAME, owner);
+        stringBuilder.append('.').append(name);
+        appendDescriptor(METHOD_DESCRIPTOR, desc);
+        stringBuilder.append('\n');
+        text.add(stringBuilder.toString());
+    }
+
+    @Override
+    public void visitVarInsn(final int opcode, final int var) {
+        addIndex(opcode);
+        text.add(tab2 + OPCODES[opcode] + " " + var);
+        if (!raw) {
+            text.add(Integer.valueOf(var));
+        }
+        text.add("\n");
+    }
+
+    @Override
+    public void visitLabel(Label label) {
+        addIndex(-1);
+        stringBuilder.setLength(0);
+        stringBuilder.append(ltab);
+        appendLabel(label);
+        Index index = getIndex(label);
+        if (index != null) {
+            stringBuilder.append(" (").append(index.insn).append(")");
+        }
+        stringBuilder.append('\n');
+        text.add(stringBuilder.toString());
+        InsnList instructions = currMethod.meth.instructions;
+        LabelNode currLabel = null;
+        for (int i = 0; i < instructions.size(); i++) {
+            AbstractInsnNode insnNode = instructions.get(i);
+            if(insnNode instanceof LabelNode) {
+                LabelNode labelNode = (LabelNode) insnNode;
+                if(labelNode.getLabel() == label) {
+                    currLabel = labelNode;
+                }
+            }
+        }
+        setCurrentLabel(currLabel);
+    }
+
+    @Override
+    public void visitInvokeDynamicInsn(String name, String desc, Handle bsm,
+        Object... bsmArgs) {
+        addIndex(Opcodes.INVOKEDYNAMIC);
+        super.visitInvokeDynamicInsn(name, desc, bsm, bsmArgs);
+    }
+
+    @Override
+    public void visitIincInsn(final int var, final int increment) {
+        addIndex(Opcodes.IINC);
+        text.add(tab2 + "IINC " + var);
+        if (!raw) {
+            text.add(Integer.valueOf(var));
+        }
+        text.add(" " + increment + "\n");
+    }
+
+    @Override
+    public void visitIntInsn(int opcode, int operand) {
+        addIndex(opcode);
+        stringBuilder.setLength(0);
+        stringBuilder.append(tab2).append(OPCODES[opcode]).append(' ').append(
+            opcode == Opcodes.NEWARRAY
+            ? TYPES[operand]
+                : formatValue(operand)).append('\n');
+        text.add(stringBuilder.toString());
+    }
+
+    private String formatValue(int operand) {
+        if (showHex) {
+            String intStr = Integer.toHexString(operand).toUpperCase();
+            return intStr + getAsCharComment(operand);
+        }
+        return Integer.toString(operand);
+    }
+
+    /**
+     * @param value
+     * @return char value from int, together with char name if it is a control char,
+     * or an empty string
+     */
+    private static String getAsCharComment(int value) {
+        if (Character.MAX_VALUE < value || Character.MIN_VALUE > value) {
+            return "";
+        }
+        StringBuffer sb = new StringBuffer("    // '");
+        switch (value) {
+            case '\t' :
+                sb.append("\\t");
+                break;
+            case '\r' :
+                sb.append("\\r");
+                break;
+            case '\n' :
+                sb.append("\\n");
+                break;
+            case '\f' :
+                sb.append("\\f");
+                break;
+            default :
+                sb.append((char) value);
+                break;
+        }
+
+        if (value >= CHAR_NAMES.length) {
+            if (value == 127) {
+                return sb.append("' (DEL)").toString();
+            }
+            return sb.append("'").toString();
+        }
+        return sb.append("' (").append(CHAR_NAMES[value]).append(")")
+            .toString();
+    }
+
+    private String formatValue(Object operand) {
+        if (operand == null) {
+            return "null";
+        }
+        if (showHex) {
+            if (operand instanceof Integer) {
+                String intStr = Integer.toHexString(
+                    ((Integer) operand).intValue()).toUpperCase();
+                return intStr
+                    + getAsCharComment(((Integer) operand).intValue());
+            } else if (operand instanceof Long) {
+                return Long.toHexString(((Long) operand).longValue())
+                    .toUpperCase();
+            } else if (operand instanceof Double) {
+                return Double.toHexString(((Double) operand).doubleValue());
+            } else if (operand instanceof Float) {
+                return Float.toHexString(((Float) operand).floatValue());
+            }
+        }
+        return operand.toString();
+    }
+
+    @Override
+    public void visitLocalVariable(final String name, final String desc,
+        final String signature, final Label start, final Label end,
+        final int index) {
+        if (showLocals) {
+            super.visitLocalVariable(
+                name, desc, signature, start, end, index);
+        }
+    }
+
+    @Override
+    public void visitLdcInsn(final Object cst) {
+        addIndex(Opcodes.LDC);
+        stringBuilder.setLength(0);
+        stringBuilder.append(tab2).append("LDC ");
+        if (cst instanceof String) {
+            Printer.appendString(stringBuilder, (String) cst);
+        } else if (cst instanceof Type) {
+            Type type = (Type) cst;
+            String descriptor = type.getDescriptor();
+            if(type.getSort() == Type.METHOD){
+                appendDescriptor(METHOD_DESCRIPTOR, descriptor);
+            } else {
+                String descr = raw? descriptor : descriptor.substring(0, descriptor.length() - 1);
+                appendDescriptor(INTERNAL_NAME, descr + ".class");
+            }
+        } else {
+            stringBuilder.append(formatValue(cst));
+        }
+        stringBuilder.append('\n');
+        text.add(stringBuilder.toString());
+    }
+
+    @Override
+    public void visitMaxs(final int maxStack, final int maxLocals) {
+        if (showLocals) {
+            super.visitMaxs(maxStack, maxLocals);
+        }
+    }
+
+    @Override
+    public void visitInsn(final int opcode) {
+        addIndex(opcode);
+        super.visitInsn(opcode);
+    }
+
+    @Override
+    public void visitTypeInsn(final int opcode, final String desc) {
+        addIndex(opcode);
+        super.visitTypeInsn(opcode, desc);
+    }
+
+    @Override
+    public void visitFieldInsn(final int opcode, final String owner1,
+        final String name, final String desc) {
+        addIndex(opcode);
+        super.visitFieldInsn(opcode, owner1, name, desc);
+    }
+
+    @Override
+    public void visitJumpInsn(final int opcode, final Label label) {
+        addIndex(opcode);
+        super.visitJumpInsn(opcode, label);
+    }
+
+    @Override
+    public void visitTableSwitchInsn(final int min, final int max,
+        final Label dflt, final Label... labels) {
+        addIndex(Opcodes.TABLESWITCH);
+        super.visitTableSwitchInsn(min, max, dflt, labels);
+    }
+
+    @Override
+    public void visitLookupSwitchInsn(final Label dflt, final int[] keys,
+        final Label[] labels) {
+        addIndex(Opcodes.LOOKUPSWITCH);
+        super.visitLookupSwitchInsn(dflt, keys, labels);
+    }
+
+    @Override
+    public void visitMultiANewArrayInsn(final String desc, final int dims) {
+        addIndex(Opcodes.MULTIANEWARRAY);
+        super.visitMultiANewArrayInsn(desc, dims);
+    }
+
+
+    @Override
+    public void visitLineNumber(final int line, final Label start) {
+        if (showLines) {
+            addIndex(-1);
+            currMethod.addLineNumber(start, Integer.valueOf(line));
+            super.visitLineNumber(line, start);
+        }
+    }
+
+    private void addIndex(final int opcode) {
+        text.add(new Index(currentLabel, currentInsn++, opcode));
+    }
+
+    void setCurrentLabel(LabelNode currentLabel) {
+        this.currentLabel = currentLabel;
+    }
+
+    @Override
+    protected Textifier createTextifier() {
+        CommentedClassVisitor classVisitor = new CommentedClassVisitor(classNode, options);
+        classVisitor.currMethod = currMethod;
+        return classVisitor;
+    }
+
+    @Override
+    public DecompiledClassInfo getClassInfo() {
+        return new DecompiledClassInfo(javaVersion, accessFlags);
+    }
+
+    private Textifier getDummyVisitor(){
+        if (dummyAnnVisitor == null) {
+            dummyAnnVisitor = new Textifier(DecompilerOptions.LATEST_ASM_VERSION) {
+                @Override
+                public void visitAnnotationEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitClassEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitFieldEnd() {
+                    text.clear();
+                }
+
+                @Override
+                public void visitMethodEnd() {
+                    text.clear();
+                }
+            };
+        }
+        return dummyAnnVisitor;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClass.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClass.java
new file mode 100644
index 0000000..12b5191
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClass.java
@@ -0,0 +1,441 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Eric Bruneton and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eric Bruneton - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.jdt.bcoview.ui.JdtUtils;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jface.text.ITextSelection;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.tree.ClassNode;
+
+public class DecompiledClass {
+
+    /** key is DecompiledMethod, value is IJavaElement (Member) */
+    private final Map<DecompiledMethod, IJavaElement> methodToJavaElt;
+    private final List<Object> text;
+
+    private String value;
+    private final ClassNode classNode;
+    private int classSize;
+    private final DecompiledClassInfo classInfo;
+
+    public DecompiledClass(final List<Object> text, DecompiledClassInfo classInfo, ClassNode classNode) {
+        this.text = text;
+        this.classInfo = classInfo;
+        this.classNode = classNode;
+        methodToJavaElt = new HashMap<>();
+    }
+
+    /**
+     * @return the class's access flags (see {@link Opcodes}). This parameter also
+     * indicates if the class is deprecated.
+     */
+    public int getAccessFlags() {
+        return classInfo.accessFlags;
+    }
+
+    /**
+     * @return true if the class is either abstract or interface
+     */
+    public boolean isAbstractOrInterface() {
+        int accessFlags = classInfo.accessFlags;
+        return (accessFlags & Opcodes.ACC_ABSTRACT) != 0
+            || ((accessFlags & Opcodes.ACC_INTERFACE) != 0);
+    }
+
+    public boolean isDefaultMethodPossible(){
+        return classInfo.major >= 8;
+    }
+
+    public String getText() {
+        if (value == null) {
+            StringBuffer buf = new StringBuffer();
+            for (int i = 0; i < text.size(); ++i) {
+                Object o = text.get(i);
+                if (o instanceof DecompiledMethod) {
+                    buf.append(((DecompiledMethod) o).getText());
+                } else {
+                    buf.append(o);
+                }
+            }
+            value = buf.toString();
+        }
+        return value;
+    }
+
+    public String[][] getTextTable() {
+        List<String[]> lines = new ArrayList<>();
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                String[][] mlines = ((DecompiledMethod) o).getTextTable();
+                for (int j = 0; j < mlines.length; ++j) {
+                    lines.add(mlines[j]);
+                }
+            } else {
+                lines.add(new String[]{"", "", "", o.toString(), ""});
+            }
+        }
+        return lines.toArray(new String[lines.size()][]);
+    }
+
+    public int getBytecodeOffset(final int decompiledLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                Integer offset = m.getBytecodeOffset(decompiledLine
+                    - currentDecompiledLine);
+                if (offset != null) {
+                    return offset.intValue();
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return -1;
+    }
+
+    public int getBytecodeInsn(final int decompiledLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                Integer opcode = m.getBytecodeInsn(decompiledLine
+                    - currentDecompiledLine);
+                if (opcode != null) {
+                    return opcode.intValue();
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return -1;
+    }
+
+    public int getSourceLine(final int decompiledLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                int l = m.getSourceLine(decompiledLine - currentDecompiledLine);
+                if (l != -1) {
+                    return l;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return -1;
+    }
+
+    public DecompiledMethod getMethod(final int decompiledLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                int l = m.getSourceLine(decompiledLine - currentDecompiledLine);
+                if (l != -1) {
+                    return m;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return null;
+    }
+
+    public DecompiledMethod getMethod(final String signature) {
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                if (signature.equals(m.getSignature())) {
+                    return m;
+                }
+            }
+        }
+        return null;
+    }
+
+    public IJavaElement getJavaElement(int decompiledLine, IClassFile clazz) {
+        DecompiledMethod method = getMethod(decompiledLine);
+        if (method != null) {
+            IJavaElement javaElement = methodToJavaElt
+                .get(method);
+            if (javaElement == null) {
+                javaElement = JdtUtils.getMethod(clazz, method.getSignature());
+                if (javaElement != null) {
+                    methodToJavaElt.put(method, javaElement);
+                } else {
+                    javaElement = clazz;
+                }
+            }
+            return javaElement;
+        }
+        return clazz;
+    }
+
+    public int getDecompiledLine(String methSignature) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                if (methSignature.equals(m.getSignature())) {
+                    return currentDecompiledLine;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return 0;
+    }
+
+    /**
+     * @param decompiledLine
+     * @return array with two elements, first is the local variables table, second is the
+     * operands stack content. "null" value could be returned too.
+     */
+    public String[] getFrame(final int decompiledLine,
+        final boolean showQualifiedNames) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                String[] frame = m.getFrame(decompiledLine
+                    - currentDecompiledLine, showQualifiedNames);
+                if (frame != null) {
+                    return frame;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return null;
+    }
+
+    public String[][][] getFrameTablesForInsn(final int insn,
+        boolean useQualifiedNames) {
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                String[][][] frame = m.getFrameTablesForInsn(insn, useQualifiedNames);
+                if (frame != null) {
+                    return frame;
+                }
+            }
+        }
+        return null;
+    }
+    public String[][][] getFrameTables(final int decompiledLine,
+        boolean useQualifiedNames) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                String[][][] frame = m.getFrameTables(decompiledLine
+                    - currentDecompiledLine, useQualifiedNames);
+                if (frame != null) {
+                    return frame;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return null;
+    }
+
+    public int getDecompiledLine(final int sourceLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                int l = m.getDecompiledLine(sourceLine);
+                if (l != -1) {
+                    return l + currentDecompiledLine;
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Converts method relative decompiled line to class absolute decompiled position
+     * @param m1 method for which we need absolute line position
+     * @param decompiledLine decompiled line, relative to given method (non global coord)
+     * @return
+     */
+    public int getDecompiledLine(final DecompiledMethod m1, final int decompiledLine) {
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                if (o == m1){
+                    return currentDecompiledLine + decompiledLine;
+                }
+                DecompiledMethod m = (DecompiledMethod) o;
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return -1;
+    }
+
+    public List<Integer> getErrorLines() {
+        List<Integer> errors = new ArrayList<>();
+        int currentDecompiledLine = 0;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                int l = m.getErrorLine();
+                if (l != -1) {
+                    errors.add(Integer.valueOf(l + currentDecompiledLine));
+                }
+                currentDecompiledLine += m.getLineCount();
+            } else {
+                currentDecompiledLine++;
+            }
+        }
+        return errors;
+    }
+
+    public DecompiledMethod getBestDecompiledMatch(int sourceLine) {
+        DecompiledMethod bestM = null;
+
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof DecompiledMethod) {
+                DecompiledMethod m = (DecompiledMethod) o;
+                int line = m.getBestDecompiledLine(sourceLine);
+                if (line > 0) {
+                    // doesn't work if it is a <init> or <cinit> which spawns over
+                    // multiple locations in code
+                    if(m.isInit()){
+                        if(bestM != null){
+                            int d1 = sourceLine - bestM.getFirstSourceLine();
+                            int d2 = sourceLine - m.getFirstSourceLine();
+                            if(d2 < d1){
+                                bestM = m;
+                            }
+                        } else {
+                            bestM = m;
+                        }
+                    } else {
+                        return m;
+                    }
+                } else {
+                    // check for init blocks which composed from different code lines
+                    if(bestM != null && bestM.isInit()){
+                        if(bestM.getFirstSourceLine() < m.getFirstSourceLine()
+                            && bestM.getLastSourceLine() > m.getLastSourceLine()){
+                            bestM = null;
+                        }
+                    }
+                }
+            }
+        }
+        return bestM;
+    }
+
+    public LineRange getDecompiledRange(ITextSelection sourceRange) {
+        int startLine = sourceRange.getStartLine() + 1;
+        int endLine = sourceRange.getEndLine() + 1;
+        int startDecompiledLine = getDecompiledLine(startLine);
+        DecompiledMethod m1 = null;
+        DecompiledMethod m2 = null;
+        if (startDecompiledLine < 0) {
+            m1 = getBestDecompiledMatch(startLine);
+            m2 = getBestDecompiledMatch(endLine);
+            if (m1 != null && m1.equals(m2)) {
+                int methodStartLine = getDecompiledLine(m1.getSignature());
+                startDecompiledLine = m1.getBestDecompiledLine(startLine);
+                if (startDecompiledLine >= 0) {
+                    startDecompiledLine = methodStartLine + startDecompiledLine;
+                } else {
+                    startDecompiledLine = methodStartLine + m1.getLineCount();
+                }
+            }
+        }
+        int endDecompiledLine = getDecompiledLine(endLine);
+        if (endDecompiledLine < 0) {
+            if(m2 == null) {
+                m2 = getBestDecompiledMatch(endLine);
+            }
+            if (m2 != null && m2.equals(m1)) {
+                int methodStartLine = getDecompiledLine(m2.getSignature());
+                endDecompiledLine = m2.getBestDecompiledLine(endLine);
+                if (endDecompiledLine >= 0) {
+                    endDecompiledLine = methodStartLine + endDecompiledLine;
+                } else {
+                    endDecompiledLine = methodStartLine + m2.getLineCount();
+                }
+                // TODO dirty workaround
+                if(endDecompiledLine < startDecompiledLine){
+                    endDecompiledLine = startDecompiledLine + 1;
+                }
+            }
+        }
+        return new LineRange(startDecompiledLine, endDecompiledLine);
+    }
+
+    public LineRange getSourceRange(LineRange decompiledRange) {
+        int startSourceLine = getSourceLine(decompiledRange.startLine);
+        int endSourceLine = getSourceLine(decompiledRange.endLine);
+        return new LineRange(startSourceLine, endSourceLine);
+    }
+
+    public ClassNode getClassNode() {
+        return classNode;
+    }
+
+    public void setClassSize(int classSize) {
+        this.classSize = classSize;
+    }
+
+    public int getClassSize() {
+        return classSize;
+    }
+
+    public String getJavaVersion() {
+        return classInfo.javaVersion.humanReadable();
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClassInfo.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClassInfo.java
new file mode 100644
index 0000000..481de38
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledClassInfo.java
@@ -0,0 +1,27 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+
+public class DecompiledClassInfo {
+    public final JavaVersion javaVersion;
+    public final int accessFlags;
+    public final int major;
+
+    public DecompiledClassInfo(JavaVersion javaVersion, int accessFlags) {
+        this.javaVersion = javaVersion;
+        this.accessFlags = accessFlags;
+        major = javaVersion.major;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledMethod.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledMethod.java
new file mode 100644
index 0000000..610c65a
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompiledMethod.java
@@ -0,0 +1,635 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Eric Bruneton and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eric Bruneton - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.objectweb.asm.Label;
+import org.objectweb.asm.Opcodes;
+import org.objectweb.asm.Type;
+import org.objectweb.asm.tree.LocalVariableNode;
+import org.objectweb.asm.tree.MethodNode;
+import org.objectweb.asm.tree.analysis.Analyzer;
+import org.objectweb.asm.tree.analysis.AnalyzerException;
+import org.objectweb.asm.tree.analysis.BasicValue;
+import org.objectweb.asm.tree.analysis.BasicVerifier;
+import org.objectweb.asm.tree.analysis.Frame;
+import org.objectweb.asm.tree.analysis.Interpreter;
+import org.objectweb.asm.tree.analysis.SimpleVerifier;
+import org.objectweb.asm.tree.analysis.Value;
+
+public class DecompiledMethod {
+
+    private final List<Object> text;
+
+    private final List<LocalVariableNode> localVariables;
+
+    /**
+     * decompiled line -> source line
+     */
+    private final Map<Integer, Integer> sourceLines;
+
+    /**
+     * source line -> decompiled line
+     */
+    private final Map<Integer, Integer> decompiledLines;
+
+    /**
+     * decompiled line -> insn
+     */
+    private final Map<Integer, Integer> insns;
+
+    /**
+     *  decompiled line -> opcode
+     */
+    private final Map<Integer, Integer> opcodes;
+
+    /**
+     * insn -> decompile line
+     */
+    private final Map<Integer, Integer> insnLines;
+
+    private int lineCount;
+
+    /**
+     * first source line, if any
+     */
+    private int firstSourceLine;
+
+    /**
+     * last source line, if any
+     */
+    private int lastSourceLine;
+
+    MethodNode meth;
+
+    private Frame<?>[] frames;
+
+    private String error;
+
+    private int errorInsn;
+
+    private final String owner;
+
+
+    private final Map<Label, Integer> lineNumbers;
+
+    private final DecompilerOptions options;
+
+    private final int access;
+
+
+    public DecompiledMethod(final String owner,
+        final Map<Label, Integer> lineNumbers, final MethodNode meth, DecompilerOptions options, int access) {
+        this.meth = meth;
+        this.owner = owner;
+        this.lineNumbers = lineNumbers;
+        this.options = options;
+        this.access = access;
+        this.text = new ArrayList<>();
+        this.localVariables = meth.localVariables;
+        this.sourceLines = new HashMap<>();
+        this.decompiledLines = new HashMap<>();
+        this.insns = new HashMap<>();
+        this.opcodes = new HashMap<>();
+        this.insnLines = new HashMap<>();
+    }
+
+    void setText(final List<?> inputText) {
+        formatText(inputText, new HashMap<Integer, String>(), new StringBuffer(), this.text);
+        computeMaps(lineNumbers);
+
+        if (options.modes.get(BCOConstants.F_SHOW_ANALYZER)
+            && (access & Opcodes.ACC_ABSTRACT) == 0) {
+            analyzeMethod(options.cl);
+        }
+    }
+
+    void addLineNumber(Label start, Integer integer) {
+        lineNumbers.put(start, integer);
+    }
+
+    public boolean isInit() {
+        return ("<init>".equals(meth.name) && "()V".equals(meth.desc))
+            || "<clinit>".equals(meth.name);
+    }
+
+    public boolean hasSourceLinesInfo(){
+        return ! sourceLines.isEmpty();
+    }
+
+    public boolean hasLocalVariablesInfo(){
+        return ! localVariables.isEmpty();
+    }
+
+    public String getSignature(){
+        return meth.name + meth.desc;
+    }
+
+    public boolean containsSource(int sourceLine){
+        return sourceLine >= getFirstSourceLine() && sourceLine <= getLastSourceLine();
+    }
+
+    /**
+     * @param sourceLine
+     * @return nearest match above given source line or the given line for perfect match
+     * or -1 for no match. The return value is method-relative, and need to be transformed
+     * to class absolute
+     */
+    public int getBestDecompiledLine(final int sourceLine){
+        if(!containsSource(sourceLine)){
+            return -1;
+        }
+        Set<Integer> set = decompiledLines.keySet();
+        if(set.size() == 0){
+            return -1;
+        }
+        int bestMatch = -1;
+        for (Iterator<Integer> iter = set.iterator(); iter.hasNext();) {
+            int line = iter.next().intValue();
+            int delta = sourceLine - line;
+            if(delta < 0){
+                continue;
+            } else if(delta == 0){
+                return line;
+            }
+            if(bestMatch < 0 || delta < sourceLine - bestMatch){
+                bestMatch = line;
+            }
+        }
+        if(bestMatch < 0){
+            return -1;
+        }
+        return decompiledLines.get(Integer.valueOf(bestMatch)).intValue();
+    }
+
+    private void analyzeMethod(final ClassLoader cl) {
+        Interpreter<BasicValue> interpreter;
+        try {
+            Type type = Type.getType(owner);
+            interpreter = new SimpleVerifier(
+                DecompilerOptions.LATEST_ASM_VERSION, type, null,
+                null, false) {
+                //
+            };
+        } catch (Exception e) {
+            interpreter = new BasicVerifier();
+        }
+
+        Analyzer<BasicValue> a = new Analyzer<>(interpreter);
+        try {
+            a.analyze(owner, meth);
+        } catch (AnalyzerException e) {
+            error = e.getMessage();
+            if (error.startsWith("Error at instruction ")) {
+                error = error.substring("Error at instruction ".length());
+                errorInsn = Integer.parseInt(error.substring(0, error
+                    .indexOf(':')));
+                error = error.substring(error.indexOf(':') + 2);
+            } else {
+                BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+                error = null;
+            }
+        }
+        frames = a.getFrames();
+    }
+
+    private void formatText(final List<?> input, final Map<Integer, String> locals, StringBuffer line,
+        final List<Object> result) {
+        for (int i = 0; i < input.size(); ++i) {
+            Object o = input.get(i);
+            if (o instanceof List) {
+                formatText((List<?>) o, locals, line, result);
+            } else if (o instanceof Index) {
+                result.add(o);
+                updateLocals((Index) o, locals);
+            } else if (o instanceof Integer) {
+                String localVariableName = locals.get(o);
+                if (localVariableName == null) {
+                    Index index = getNextIndex(input, i);
+                    if(index != null){
+                        updateLocals(index, locals);
+                        localVariableName = locals.get(o);
+                    }
+                }
+                if(localVariableName != null) {
+                    line.append(": ").append(localVariableName);
+                }
+            } else {
+                String s = o.toString();
+                int p;
+                do {
+                    p = s.indexOf('\n');
+                    if (p == -1) {
+                        line.append(s);
+                    } else {
+                        result.add(line.toString() + s.substring(0, p + 1));
+                        s = s.substring(p + 1);
+                        line.setLength(0);
+                    }
+                } while (p != -1);
+            }
+        }
+    }
+
+    private static Index getNextIndex(List<?> input, int startOffset) {
+        for (int i = startOffset + 1; i < input.size(); i++) {
+            Object object = input.get(i);
+            if(object instanceof Index){
+                return (Index)object;
+            }
+        }
+        return null;
+    }
+
+    private void updateLocals(final Index index, final Map<Integer, String> locals) {
+        for (int i = 0; i < localVariables.size(); ++i) {
+            LocalVariableNode lvNode = localVariables.get(i);
+            if (lvNode.start == index.labelNode) {
+                locals.put(Integer.valueOf(lvNode.index), lvNode.name);
+            } else if (lvNode.end == index.labelNode) {
+                locals.remove(Integer.valueOf(lvNode.index));
+            }
+        }
+    }
+
+    private void computeMaps(final Map<Label, Integer> lineNumbers1) {
+        int currentDecompiledLine = 0;
+        int firstLine = -1;
+        int lastLine = -1;
+        for (int i = 0; i < text.size(); ++i) {
+            int currentOpcode = -1;
+            int currentInsn1 = -1;
+            int currentSourceLine = -1;
+            Object o = text.get(i);
+            if (o instanceof Index) {
+                Index index = (Index) o;
+                Integer sourceLine = null;
+                if(index.labelNode != null) {
+                    sourceLine = lineNumbers1.get(index.labelNode.getLabel());
+                }
+                if (sourceLine != null) {
+                    currentSourceLine = sourceLine.intValue();
+                    if(firstLine == -1 || currentSourceLine < firstLine){
+                        firstLine = currentSourceLine;
+                    }
+                    if(lastLine == -1 || currentSourceLine > lastLine){
+                        lastLine = currentSourceLine;
+                    }
+                }
+                currentInsn1 = index.insn;
+                currentOpcode = index.opcode;
+            } else {
+                ++currentDecompiledLine;
+            }
+            Integer cdl = Integer.valueOf(currentDecompiledLine);
+            Integer ci = Integer.valueOf(currentInsn1);
+            Integer co = Integer.valueOf(currentOpcode);
+            if(currentSourceLine >= 0){
+                Integer csl = Integer.valueOf(currentSourceLine);
+                sourceLines.put(cdl, csl);
+                if (decompiledLines.get(csl) == null) {
+                    decompiledLines.put(csl, cdl);
+                }
+            }
+            insns.put(cdl, ci);
+            opcodes.put(cdl, co);
+            if (insnLines.get(ci) == null) {
+                insnLines.put(ci, cdl);
+            }
+        }
+        lineCount = currentDecompiledLine;
+        firstSourceLine = firstLine;
+        lastSourceLine = lastLine;
+    }
+
+    public String getText() {
+        StringBuffer buf = new StringBuffer();
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (!(o instanceof Index)) {
+                buf.append((String) o);
+            }
+        }
+        return buf.toString();
+    }
+
+    public String[][] getTextTable() {
+        Frame<?> frame = null;
+        String error1 = "";
+        List<String[]> lines = new ArrayList<>();
+        String offsStr = null;
+        for (int i = 0; i < text.size(); ++i) {
+            Object o = text.get(i);
+            if (o instanceof Index) {
+                Index index = (Index) o;
+                int insn = index.insn;
+
+                offsStr = "" + insn;
+                if (frames != null && insn < frames.length) {
+                    frame = frames[insn];
+                    if (this.error != null && insn == this.errorInsn) {
+                      error1 = this.error;
+                    }
+                }
+            } else {
+                if(offsStr == null){
+                    offsStr = "";
+                }
+                String locals = " ";
+                String stack = " ";
+                if (frame != null) {
+                    StringBuffer buf = new StringBuffer();
+                    appendFrame(buf, frame);
+                    int p = buf.indexOf(" ");
+                    locals = buf.substring(0, p);
+                    if("".equals(locals)){
+                        locals = " ";
+                    }
+                    stack = buf.substring(p + 1);
+                    if("".equals(stack)){
+                        stack = " ";
+                    }
+                }
+
+                lines.add(new String[]{offsStr, locals, stack, o.toString(), error1});
+                frame = null;
+                error1 = "";
+                offsStr = null;
+            }
+        }
+        return lines.toArray(new String[lines.size()][]);
+    }
+
+    public int getLineCount() {
+        return lineCount;
+    }
+
+    public String getError() {
+        return error;
+    }
+
+    public int getErrorLine() {
+        if (error == null) {
+            return -1;
+        }
+        Integer i = insnLines.get(Integer.valueOf(errorInsn));
+        return i == null
+            ? -1
+            : i.intValue();
+    }
+
+    private static void appendFrame(final StringBuffer buf, final Frame<?> f) {
+        try {
+            for (int i = 0; i < f.getLocals(); ++i) {
+                appendValue(buf, f.getLocal(i));
+            }
+            buf.append(' ');
+            for (int i = 0; i < f.getStackSize(); ++i) {
+                appendValue(buf, f.getStack(i));
+            }
+        } catch (IndexOutOfBoundsException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+    }
+
+    private static void appendValue(final StringBuffer buf, final Value v) {
+        if (((BasicValue) v).isReference()) {
+            buf.append("R");
+        } else {
+            buf.append(v.toString());
+        }
+    }
+
+    public int getFirstSourceLine(){
+        return firstSourceLine;
+    }
+
+    public int getLastSourceLine(){
+        return lastSourceLine;
+    }
+
+    public int getSourceLine(final int decompiledLine) {
+        Integer i = sourceLines.get(Integer.valueOf(decompiledLine));
+        return i == null
+            ? -1
+            : i.intValue();
+    }
+
+    /**
+     *
+     * @param decompiledLine
+     * @return array with two elements, first is the local variables table,
+     * second is the operands stack content. "null" value could be returned too.
+     */
+    public String[] getFrame(final int decompiledLine, final boolean useQualifiedNames) {
+        Integer insn = getBytecodeOffset(decompiledLine);
+        if (error != null && insn != null && insn.intValue() == errorInsn) {
+            return new String [] {error,error};
+        }
+        if (frames != null && insn != null) {
+            Frame<?> f = frames[insn.intValue()];
+            if (f == null) {
+                return null;
+            }
+
+            try {
+                StringBuffer localsBuf = new StringBuffer();
+
+                for (int i = 0; i < f.getLocals(); ++i) {
+                    String s = f.getLocal(i).toString();
+                    appendTypeName(i, useQualifiedNames, localsBuf, s);
+
+                    for (Iterator<LocalVariableNode> it = localVariables.iterator(); it.hasNext();) {
+                        LocalVariableNode lvnode = it.next();
+                        int n = lvnode.index;
+                        if( n==i) {
+                          localsBuf.append( " : ").append( lvnode.name);
+                        }
+                    }
+
+                    localsBuf.append('\n');
+                }
+                StringBuffer stackBuf = new StringBuffer();
+                for (int i = 0; i < f.getStackSize(); ++i) {
+                    String s = f.getStack(i).toString();
+                    appendTypeName(i, useQualifiedNames, stackBuf, s);
+                    stackBuf.append('\n');
+                }
+                return new String[] {localsBuf.toString(), stackBuf.toString()};
+            } catch (IndexOutOfBoundsException e) {
+                BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+            }
+        }
+        return null;
+    }
+
+    public Integer getBytecodeOffset(final int decompiledLine) {
+        Integer insn = insns.get(Integer.valueOf(decompiledLine));
+        return insn;
+    }
+
+    public Integer getBytecodeInsn(final int decompiledLine) {
+        Integer insn = opcodes.get(Integer.valueOf(decompiledLine));
+        return insn;
+    }
+
+    public String[][][] getFrameTables(final int decompiledLine, boolean useQualifiedNames) {
+        Integer insn = getBytecodeOffset(decompiledLine);
+        if(insn == null){
+            return null;
+        }
+        return getFrameTablesForInsn(insn.intValue(), useQualifiedNames);
+    }
+
+    public String[][][] getFrameTablesForInsn(final int insn, boolean useQualifiedNames) {
+        if (error != null && insn == errorInsn) {
+            return null;
+        }
+        if (frames != null && insn >= 0 && insn < frames.length) {
+            Frame<?> f = frames[insn];
+            if (f == null) {
+                return null;
+            }
+
+            try {
+                ArrayList<String[]> locals = new ArrayList<>();
+                for (int i = 0; i < f.getLocals(); ++i) {
+                    String varName = "";
+                    for (Iterator<LocalVariableNode> it = localVariables.iterator(); it.hasNext();) {
+                        LocalVariableNode lvnode = it.next();
+                        int n = lvnode.index;
+                        if( n==i) {
+                            varName = lvnode.name;
+                            // TODO take into account variable scope!
+                            break;
+                        }
+                    }
+
+                    locals.add( new String[] {
+                        ""+i,
+                        getTypeName( useQualifiedNames, f.getLocal(i).toString()),
+                        varName});
+                }
+
+                ArrayList<String[]> stack = new ArrayList<>();
+                for (int i = 0; i < f.getStackSize(); ++i) {
+                    stack.add( new String[] {
+                        ""+i,
+                        getTypeName( useQualifiedNames, f.getStack(i).toString())});
+                }
+                return new String[][][] {
+                    locals.toArray( new String[ 3][]),
+                    stack.toArray( new String[ 2][])};
+            } catch (IndexOutOfBoundsException e) {
+                BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+            }
+        }
+        return null;
+    }
+
+
+    /**
+     * Appends full type name or only simply name, depends on boolean flag.
+     *
+     * @param useQualifiedNames if false, then e.g. "Object" will be appended to
+     * buffer instead of "Ljava/lang/Object;" etc
+     * @param buf buffer to append
+     * @param s string with bytecode type name, like "Ljava/lang/Object;"
+     */
+    private static void appendTypeName(int n, final boolean useQualifiedNames, StringBuffer buf, String s) {
+        buf.append(n).append( " ");
+        if(!useQualifiedNames) {
+            int idx = s.lastIndexOf('/');
+            if(idx > 0){
+                // from "Ljava/lang/Object;" to "Object"
+                buf.append(s.substring(idx + 1, s.length() - 1));
+                return;
+            }
+        }
+        if("Lnull;".equals(s)){
+            buf.append("null");
+        } else {
+            buf.append(s);
+        }
+    }
+
+    private static String getTypeName(final boolean useQualifiedNames, String s) {
+      if (!useQualifiedNames) {
+          // get leading array symbols
+          String arraySymbols = "";
+          while (s.startsWith("[")){
+              arraySymbols += "[";
+              s = s.substring(1);
+          }
+
+          int idx = s.lastIndexOf('/');
+          if (idx > 0) {
+              // from "Ljava/lang/Object;" to "Object"
+              return arraySymbols  + s.substring(idx + 1, s.length() - 1);
+          }
+          // this is the case on LVT view - ignore it
+          if("." == s){
+              return arraySymbols  + s;
+          }
+          // XXX Unresolved type
+          if("R" == s){
+              return arraySymbols  + s;
+          }
+          // resolve primitive types
+          return arraySymbols +
+              CommentedClassVisitor.getSimpleName(Type.getType(s));
+      }
+      return "Lnull;".equals(s) ? "null" : s;
+    }
+
+    public int getDecompiledLine(final int sourceLine) {
+        Integer i = decompiledLines.get(Integer.valueOf(sourceLine));
+        return i == null
+            ? -1
+            : i.intValue();
+    }
+
+    /**
+     * Returns <code>true</code> if this <code>DecompiledMethod</code> is the same as the o argument.
+     *
+     * @return <code>true</code> if this <code>DecompiledMethod</code> is the same as the o argument.
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) {
+            return true;
+        }
+        if (!(o instanceof DecompiledMethod)) {
+            return false;
+        }
+        DecompiledMethod another = (DecompiledMethod) o;
+        return getSignature().equals(another.getSignature())
+            && (owner != null? owner.equals(another.owner) : true);
+    }
+
+    @Override
+    public int hashCode() {
+        return getSignature().hashCode() + (owner != null? owner.hashCode() : 0);
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerHelper.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerHelper.java
new file mode 100644
index 0000000..68b9086
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerHelper.java
@@ -0,0 +1,85 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Eric Bruneton and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eric Bruneton - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.objectweb.asm.ClassReader;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.util.Printer;
+import org.objectweb.asm.util.TraceClassVisitor;
+
+public class DecompilerHelper  {
+
+    public static DecompiledClass getDecompiledClass(final byte[] bytes,
+        DecompilerOptions options) throws UnsupportedClassVersionError {
+        ClassReader cr = new ClassReader(bytes);
+        ClassNode cn = new ClassNode(DecompilerOptions.LATEST_ASM_VERSION);
+        int crFlags = 0;
+        if(options.modes.get(BCOConstants.F_EXPAND_STACKMAP)) {
+            crFlags |= ClassReader.EXPAND_FRAMES;
+        }
+        cr.accept(cn, crFlags);
+        ICommentedClassVisitor printer;
+        if (options.modes.get(BCOConstants.F_SHOW_ASMIFIER_CODE)) {
+            printer = new CommentedASMifierClassVisitor(cn, options);
+        } else {
+            printer = new CommentedClassVisitor(cn, options);
+        }
+        TraceClassVisitor dcv = new TraceClassVisitor(null, (Printer) printer, null);
+        cn.accept(dcv);
+        return getResult(printer, options, cn);
+    }
+
+    private static DecompiledClass getResult(ICommentedClassVisitor printer,  DecompilerOptions options, ClassNode classNode) {
+        List<Object> classText = new ArrayList<>();
+        formatText(printer.getText(), new StringBuffer(), classText, options.cl);
+        while (classText.size() > 0 && classText.get(0).equals("\n")) {
+            classText.remove(0);
+        }
+
+        DecompiledClassInfo classInfo = printer.getClassInfo();
+        return new DecompiledClass(classText, classInfo, classNode);
+    }
+
+    private static void formatText(final List<?> input, final StringBuffer line, final List<Object> result,
+        final ClassLoader cl) {
+        for (int i = 0; i < input.size(); ++i) {
+            Object o = input.get(i);
+            if (o instanceof List) {
+                formatText((List<?>) o, line, result, cl);
+            } else if (o instanceof DecompiledMethod) {
+                result.add(o);
+            } else {
+                String s = o.toString();
+                int p;
+                do {
+                    p = s.indexOf('\n');
+                    if (p == -1) {
+                        line.append(s);
+                    } else {
+                        result.add(line.toString() + s.substring(0, p + 1));
+                        s = s.substring(p + 1);
+                        line.setLength(0);
+                    }
+                } while (p != -1);
+            }
+        }
+    }
+
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerOptions.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerOptions.java
new file mode 100644
index 0000000..92f589e
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/DecompilerOptions.java
@@ -0,0 +1,36 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.BitSet;
+
+import org.objectweb.asm.Opcodes;
+
+public class DecompilerOptions {
+
+    public static int LATEST_ASM_VERSION = Opcodes.ASM7;
+
+    public final String fieldFilter;
+    public final String methodFilter;
+    public final BitSet modes;
+    public final ClassLoader cl;
+
+    public DecompilerOptions(final String fieldFilter, final String methodFilter,
+        final BitSet modes, final ClassLoader cl) {
+            this.fieldFilter = fieldFilter;
+            this.methodFilter = methodFilter;
+            this.modes = modes;
+            this.cl = cl;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/ICommentedClassVisitor.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/ICommentedClassVisitor.java
new file mode 100644
index 0000000..af9a356
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/ICommentedClassVisitor.java
@@ -0,0 +1,22 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import java.util.List;
+
+public interface ICommentedClassVisitor {
+    List<?> getText();
+
+    DecompiledClassInfo getClassInfo();
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/Index.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/Index.java
new file mode 100644
index 0000000..e62bac7
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/Index.java
@@ -0,0 +1,32 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Eric Bruneton and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eric Bruneton - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+import org.objectweb.asm.tree.LabelNode;
+
+public class Index {
+
+    public final LabelNode labelNode;
+
+    public final int insn;
+
+    public final int opcode;
+
+    public Index(final LabelNode label, final int insn, final int opcode) {
+        this.labelNode = label;
+        this.insn = insn;
+        this.opcode = opcode;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/JavaVersion.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/JavaVersion.java
new file mode 100644
index 0000000..5e52492
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/JavaVersion.java
@@ -0,0 +1,48 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+public class JavaVersion {
+
+    private final int version;
+    public final int major;
+    public final int minor;
+
+    public JavaVersion(int version) {
+        this.version = version;
+        major = version & 0xFFFF;
+        minor = version >>> 16;
+    }
+
+    public String humanReadable() {
+        // 1.1 is 45, 1.2 is 46 etc.
+        int javaV = major % 44;
+        String javaVersion;
+        if (javaV > 0) {
+            if(javaV > 8) {
+                javaVersion = javaV + "." + minor;
+            } else {
+                javaVersion = "1." + javaV;
+            }
+        } else {
+            javaVersion = "? " + major;
+        }
+        return javaVersion;
+    }
+
+    @Override
+    public String toString() {
+        return version + " : " + humanReadable();
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/LineRange.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/LineRange.java
new file mode 100644
index 0000000..fae2b7b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/asm/LineRange.java
@@ -0,0 +1,25 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.asm;
+
+public class LineRange {
+    public final int startLine;
+    public final int endLine;
+
+    public LineRange(int startLine, int endLine) {
+        super();
+        this.startLine = startLine;
+        this.endLine = endLine;
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/BytecodeCompare.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/BytecodeCompare.java
new file mode 100644
index 0000000..37e8839
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/BytecodeCompare.java
@@ -0,0 +1,298 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.compare;
+
+import java.lang.reflect.Field;
+
+import org.eclipse.compare.CompareConfiguration;
+import org.eclipse.compare.CompareEditorInput;
+import org.eclipse.compare.CompareUI;
+import org.eclipse.compare.CompareViewerPane;
+import org.eclipse.compare.CompareViewerSwitchingPane;
+import org.eclipse.compare.structuremergeviewer.Differencer;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.OperationCanceledException;
+import org.eclipse.core.runtime.SubMonitor;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.eclipse.jdt.bcoview.ui.actions.DefaultToggleAction;
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.action.ToolBarManager;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.ui.IReusableEditor;
+
+public class BytecodeCompare extends CompareEditorInput {
+
+    /** Stores reference to the element displayed on the left side of the viewer. */
+    protected TypedElement left;
+    /** Stores reference to the element displayed on the right side of the viewer. */
+    protected TypedElement right;
+    /** Action used in compare view/bytecode view to toggle asmifier mode on/off */
+    protected Action toggleAsmifierModeAction;
+    /** Action used in compare view/bytecode view to hide/show line info.  */
+    protected Action hideLineInfoAction;
+    /** Action used in compare view/bytecode view to hide/show local variables. */
+    protected Action hideLocalsAction;
+    protected Action hideStackMapAction;
+    protected Action expandStackMapAction;
+
+    protected IReusableEditor myEditor;
+
+    /**
+     * Constructor for PerforceCompareEditorInput.
+     * @param left element displayed on the left.
+     * @param right element displayed on the right.
+     */
+    public BytecodeCompare(final TypedElement left, final TypedElement right) {
+        super(new CompareConfiguration());
+        this.left = left;
+        this.right = right;
+        toggleAsmifierModeAction = new DefaultToggleAction(
+            BCOConstants.DIFF_SHOW_ASMIFIER_CODE, false) {
+
+            @Override
+            public void run(final boolean newState) {
+                toggleMode(
+                    BCOConstants.F_SHOW_ASMIFIER_CODE, newState, newState);
+            }
+        };
+
+        hideLineInfoAction = new DefaultToggleAction(
+            BCOConstants.DIFF_SHOW_LINE_INFO, false) {
+
+            @Override
+            public void run(final boolean newState) {
+                toggleMode(
+                    BCOConstants.F_SHOW_LINE_INFO, newState,
+                    toggleAsmifierModeAction.isChecked());
+            }
+        };
+
+        hideLocalsAction = new DefaultToggleAction(
+            BCOConstants.DIFF_SHOW_VARIABLES, false) {
+
+            @Override
+            public void run(final boolean newState) {
+                toggleMode(
+                    BCOConstants.F_SHOW_VARIABLES, newState,
+                    toggleAsmifierModeAction.isChecked());
+            }
+        };
+
+        hideStackMapAction = new DefaultToggleAction(
+            BCOConstants.DIFF_SHOW_STACKMAP, false) {
+
+            @Override
+            public void run(final boolean newState) {
+                toggleMode(
+                    BCOConstants.F_SHOW_STACKMAP, newState,
+                    toggleAsmifierModeAction.isChecked());
+            }
+        };
+
+        expandStackMapAction = new DefaultToggleAction(
+            BCOConstants.DIFF_EXPAND_STACKMAP, false) {
+
+            @Override
+            public void run(final boolean newState) {
+                toggleMode(
+                    BCOConstants.F_EXPAND_STACKMAP, newState,
+                    toggleAsmifierModeAction.isChecked());
+            }
+        };
+    }
+
+    /** @see CompareEditorInput#prepareInput(IProgressMonitor) */
+    @Override
+    protected Object prepareInput(final IProgressMonitor monitor)
+        throws InterruptedException {
+        if (right == null || left == null) {
+            return null;
+        }
+
+        try {
+            initLabels();
+            Differencer differencer = new Differencer();
+            monitor.beginTask("Bytecode Outline: comparing...", 30); //$NON-NLS-1$
+            IProgressMonitor sub = SubMonitor.convert(monitor, 10);
+            try {
+                sub.beginTask("Bytecode Outline: comparing...", 100); //$NON-NLS-1$
+
+                return differencer.findDifferences(
+                    false, sub, null, null, left, right);
+            } finally {
+                sub.done();
+            }
+        } catch (OperationCanceledException e) {
+            throw new InterruptedException(e.getMessage());
+        } finally {
+            monitor.done();
+        }
+    }
+
+    /**
+     * Sets up the title and pane labels for the comparison view.
+     */
+    private void initLabels() {
+        CompareConfiguration cc = getCompareConfiguration();
+
+        cc.setLeftLabel(left.getName());
+        cc.setLeftImage(left.getImage());
+
+        cc.setRightLabel(right.getName());
+        cc.setRightImage(right.getImage());
+
+        setTitle("Bytecode compare: "  //$NON-NLS-1$
+            + left.getElementName() + " - " + right.getElementName()); //$NON-NLS-1$
+    }
+
+    public CompareViewerSwitchingPane getInputPane() {
+        try {
+            Field field = CompareEditorInput.class.getDeclaredField("fContentInputPane");
+            field.setAccessible(true);
+            Object object = field.get(this);
+            if(object instanceof CompareViewerSwitchingPane) {
+                return (CompareViewerSwitchingPane) object;
+            }
+        } catch (Exception e) {
+            // ignore
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+
+        // does not work after changing content: this is a bug in CompareEditorInput, because
+        // navigator instance holds old (not up to date) instance of the input pane
+//        ICompareNavigator navigator = getNavigator();
+//        if(navigator instanceof CompareNavigator) {
+//            CompareNavigator compareNavigator = (CompareNavigator) navigator;
+//            try {
+//                Method method = compareNavigator.getClass().getDeclaredMethod(
+//                    "getPanes", null);
+//                method.setAccessible(true);
+//                Object object = method.invoke(compareNavigator, null);
+//                if(object instanceof Object[]) {
+//                    Object[] panes = (Object[]) object;
+//                    if(panes.length == 4 && panes[3] instanceof CompareViewerSwitchingPane) {
+//                        // there are 4 panels, last one is the input pane that we search for
+//                        // see org.eclipse.compare.CompareEditorInput.getNavigator()
+//                        return (CompareViewerSwitchingPane) panes[3];
+//                    }
+//                }
+//            } catch (Exception e) {
+//                // ignore.
+//            }
+//        }
+        return null;
+    }
+
+    /**
+     * @see org.eclipse.compare.CompareEditorInput#createContents(org.eclipse.swt.widgets.Composite)
+     */
+    @Override
+    public Control createContents(final Composite parent) {
+        Object obj = parent.getData();
+        if(obj == null) {
+            obj = parent.getParent().getData();
+        }
+        // dirty hook on this place to get reference to editor
+        // CompareEditor extends EditorPart implements IReusableEditor
+        if(obj instanceof IReusableEditor){
+            myEditor = (IReusableEditor)obj;
+        }
+
+        Control control = super.createContents(parent);
+
+        CompareViewerSwitchingPane inputPane = getInputPane();
+        if (inputPane != null) {
+            ToolBarManager toolBarManager2 = CompareViewerPane
+                .getToolBarManager(inputPane);
+            if(toolBarManager2 == null) {
+                return control;
+            }
+            boolean separatorExist = false;
+            if (toolBarManager2.find(hideLineInfoAction.getId()) == null) {
+                if(!separatorExist) {
+                    separatorExist = true;
+                    toolBarManager2.insert(0, new Separator("bco")); //$NON-NLS-1$
+                }
+                toolBarManager2.insertBefore("bco", hideLineInfoAction); //$NON-NLS-1$
+//                toolBarManager2.update(true);
+            }
+            if (toolBarManager2.find(hideLocalsAction.getId()) == null) {
+                if(!separatorExist) {
+                    separatorExist = true;
+                    toolBarManager2.insert(0, new Separator("bco")); //$NON-NLS-1$
+                }
+                toolBarManager2.insertBefore("bco", hideLocalsAction); //$NON-NLS-1$
+//                toolBarManager2.update(true);
+            }
+
+            if (toolBarManager2.find(hideStackMapAction.getId()) == null) {
+                if(!separatorExist) {
+                    separatorExist = true;
+                    toolBarManager2.insert(0, new Separator("bco")); //$NON-NLS-1$
+                }
+                toolBarManager2.insertBefore("bco", hideStackMapAction); //$NON-NLS-1$
+//                toolBarManager2.update(true);
+            }
+            if (toolBarManager2.find(expandStackMapAction.getId()) == null) {
+                if(!separatorExist) {
+                    separatorExist = true;
+                    toolBarManager2.insert(0, new Separator("bco")); //$NON-NLS-1$
+                }
+                toolBarManager2.insertBefore("bco", expandStackMapAction); //$NON-NLS-1$
+//                toolBarManager2.update(true);
+            }
+
+            if (toolBarManager2.find(toggleAsmifierModeAction.getId()) == null) {
+                if(!separatorExist) {
+                    toolBarManager2.insert(0, new Separator("bco")); //$NON-NLS-1$
+                    separatorExist = true;
+                }
+                toolBarManager2.insertBefore("bco", toggleAsmifierModeAction); //$NON-NLS-1$
+//                toolBarManager2.update(true);
+            }
+            try {
+                toolBarManager2.update(true);
+                toolBarManager2.getControl().getParent().layout(true);
+                toolBarManager2.getControl().getParent().update();
+            } catch (NullPointerException e) {
+                // ignore, i'm just curios why we need this code in 3.2 and expect
+                // some unwanted side effects...
+            }
+        }
+        return control;
+    }
+
+    protected void toggleMode(final int mode, final boolean value, final boolean isASMifierMode) {
+        String contentType = isASMifierMode
+            ? TypedElement.TYPE_ASM_IFIER
+            : TypedElement.TYPE_BYTECODE;
+
+        left.setMode(mode, value);
+        left.setMode(BCOConstants.F_SHOW_ASMIFIER_CODE, isASMifierMode);
+        left.setType(contentType);
+
+        right.setMode(mode, value);
+        right.setMode(BCOConstants.F_SHOW_ASMIFIER_CODE, isASMifierMode);
+        right.setType(contentType);
+
+//        createDiffViewer.refresh();
+//        myEditor.setInput(this);
+        CompareUI.reuseCompareEditor(new BytecodeCompare(left, right), myEditor);
+//        CompareUI.reuseCompareEditor(this, myEditor);
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/TypedElement.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/TypedElement.java
new file mode 100644
index 0000000..af292cc
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/compare/TypedElement.java
@@ -0,0 +1,155 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.compare;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.util.BitSet;
+
+import org.eclipse.compare.BufferedContent;
+import org.eclipse.compare.CompareUI;
+import org.eclipse.compare.ITypedElement;
+import org.eclipse.compare.structuremergeviewer.IStructureComparator;
+import org.eclipse.core.runtime.CoreException;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.core.runtime.Status;
+import org.eclipse.jdt.bcoview.asm.DecompiledClass;
+import org.eclipse.jdt.bcoview.asm.DecompilerHelper;
+import org.eclipse.jdt.bcoview.asm.DecompilerOptions;
+import org.eclipse.jdt.bcoview.ui.JdtUtils;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.swt.graphics.Image;
+import org.eclipse.swt.widgets.Display;
+
+public class TypedElement extends BufferedContent
+    implements
+        ITypedElement,
+        IStructureComparator {
+
+    private final String name;
+
+    private String type;
+
+    private final String methodName;
+
+    private final IJavaElement element;
+
+    /** used by Eclipse to recognize appropriated viewer */
+    public static final String TYPE_BYTECODE = "bytecode";
+
+    /** used by Eclipse to recognize appropriated viewer */
+    public static final String TYPE_ASM_IFIER = "java";
+
+    private final BitSet modes;
+
+    /**
+     * Constructor for TypedElement.
+     * @param name
+     * @param type
+     * @param element
+     * @param modes
+     */
+    public TypedElement(String name, String methodName, String type, IJavaElement element, BitSet modes) {
+        super();
+        this.name = name;
+        this.methodName = methodName;
+        this.type = type;
+        this.element = element;
+        this.modes = modes;
+    }
+
+    /**
+     * @see org.eclipse.compare.ITypedElement#getName()
+     */
+    @Override
+    public String getName() {
+        return name;
+    }
+
+
+    /**
+     * @see org.eclipse.compare.ITypedElement#getType()
+     */
+    @Override
+    public String getType() {
+        return type;
+    }
+
+    /**
+     * @param type The type to set.
+     */
+    protected void setType(String type) {
+        this.type = type;
+    }
+
+    /**
+     * @return name
+     */
+    public String getElementName() {
+        return JdtUtils.getElementName(element);
+    }
+
+    @Override
+    public Image getImage() {
+        // default image for .class files
+        return CompareUI.getImage("class");
+    }
+
+    @Override
+    public Object[] getChildren() {
+        return new TypedElement[0];
+    }
+
+    @Override
+    protected InputStream createStream() throws CoreException {
+        byte[] classBytes = JdtUtils.readClassBytes(element);
+        if (classBytes == null) {
+            throw new CoreException(new Status(
+                IStatus.ERROR, "org.eclipse.jdt.bcoview", -1,
+                "Can't read bytecode for: " + element, null));
+        }
+        DecompiledClass decompiledClass = null;
+        try {
+            decompiledClass = DecompilerHelper.getDecompiledClass(
+                classBytes, new DecompilerOptions(null, methodName, modes, null));
+        } catch (UnsupportedClassVersionError e){
+            throw new CoreException(new Status(
+                IStatus.ERROR, "org.eclipse.jdt.bcoview", -1,
+                "Error caused by attempt to load class compiled with Java version which"
+                + " is not supported by current JVM", e));
+        }
+        final byte[] bytes = decompiledClass.getText().getBytes(Charset.forName("UTF-8"));
+        // use internal buffering to prevent multiple calls to this method
+        Display.getDefault().syncExec(new Runnable(){
+            @Override
+            public void run() {
+                setContent(bytes);
+            }
+        });
+
+        return new ByteArrayInputStream(bytes);
+    }
+
+    /**
+     *
+     * @param mode one of BCOConstants.F_* modes
+     * @param value
+     */
+    public void setMode(int mode, boolean value){
+        modes.set(mode, value);
+        // force create new stream
+        discardBuffer();
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOConstants.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOConstants.java
new file mode 100644
index 0000000..37258e7
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOConstants.java
@@ -0,0 +1,145 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.preferences;
+
+import java.util.HashMap;
+import java.util.Map;
+
+
+/**
+ * Keys for preferences store used in BCO
+ */
+public interface BCOConstants {
+    /**
+     * toggle BCO "view content/selection follows editor selection"
+     */
+    String LINK_VIEW_TO_EDITOR = "linkViewToEditor";
+
+    /**
+     * toggle reference "view content/selection follows editor selection"
+     */
+    String LINK_REF_VIEW_TO_EDITOR = "linkRefViewToEditor";
+
+    /**
+     * show bytecode only for selected element in editor
+     */
+    String SHOW_ONLY_SELECTED_ELEMENT = "showOnlySelectedElement";
+
+    /**
+     * show ASMifier java code instead of bytecode
+     */
+    String SHOW_ASMIFIER_CODE = "showASMifierCode";
+
+    /**
+     * show ASMifier java code instead of bytecode in compare pane
+     */
+    String DIFF_SHOW_ASMIFIER_CODE = "diff_showASMifierCode";
+
+    /**
+     * show raw bytecode (without any additional help like readable class names etc)
+     */
+    String SHOW_RAW_BYTECODE = "showRawBytecode";
+
+    /**
+     * show line information (if available)
+     */
+    String SHOW_LINE_INFO = "showLineInfo";
+
+    /**
+     * show line information (if available) in compare pane
+     */
+    String DIFF_SHOW_LINE_INFO = "diff_showLineInfo";
+
+    /**
+     * show variables information (if available)
+     */
+    String SHOW_VARIABLES = "showVariables";
+
+    /**
+     * show variables information (if available) in compare pane
+     */
+    String DIFF_SHOW_VARIABLES = "diff_showVariables";
+
+    /**
+     * recalculate stackmap (to see computed frames, works for all classes even before MUSTANG)
+     */
+    String SHOW_STACKMAP = "showStackmap";
+
+    /**
+     * recalculate stackmap (to see computed frames, works for all classes even before MUSTANG) in compare
+     */
+    String DIFF_SHOW_STACKMAP = "diff_showStackmap";
+
+    /**
+     * expand stackmap frames
+     */
+    String EXPAND_STACKMAP = "expandStackmap";
+
+    /**
+     * expand stackmap frames in compare pane
+     */
+    String DIFF_EXPAND_STACKMAP = "diff_expandStackmap";
+
+    /**
+     * recalculate stackmap (to see computed frames, works for all classes even before MUSTANG)
+     */
+    String RECALCULATE_STACKMAP = "recalculateStackmap";
+
+    /**
+     * show "analyzer" - LVT and stack tables (for current bytecode selection)
+     */
+    String SHOW_ANALYZER = "showAnalyzer";
+
+    /**
+     * Show non decimal values for numeric constants in the bytecode
+     */
+    String SHOW_HEX_VALUES = "showHexValues";
+
+    int F_LINK_VIEW_TO_EDITOR = 0;
+    int F_SHOW_ONLY_SELECTED_ELEMENT = 1;
+    int F_SHOW_ASMIFIER_CODE = 2;
+    int F_SHOW_RAW_BYTECODE = 3;
+    int F_SHOW_LINE_INFO = 4;
+    int F_SHOW_VARIABLES = 5;
+    int F_RECALCULATE_STACKMAP = 6;
+    int F_EXPAND_STACKMAP = 7;
+    int F_SHOW_ANALYZER = 8;
+    int F_SHOW_STACKMAP = 9;
+    int F_SHOW_HEX_VALUES = 10;
+
+    /**
+     * Value is Integer value from one of F_* constants, key is the String value of one of corresponding
+     * preference keys. It is not intended that the map would be modified by clients.
+     */
+    Map<String, Integer> NAME_TO_FLAG_MAP = new ConstantsMap();
+
+    final class ConstantsMap extends HashMap<String, Integer> {
+        private static final long serialVersionUID = 1L;
+
+        private ConstantsMap() {
+            super();
+            put(EXPAND_STACKMAP, Integer.valueOf(F_EXPAND_STACKMAP));
+            put(LINK_VIEW_TO_EDITOR, Integer.valueOf(F_LINK_VIEW_TO_EDITOR));
+            put(RECALCULATE_STACKMAP, Integer.valueOf(F_RECALCULATE_STACKMAP));
+            put(SHOW_ANALYZER, Integer.valueOf(F_SHOW_ANALYZER));
+            put(SHOW_ASMIFIER_CODE, Integer.valueOf(F_SHOW_ASMIFIER_CODE));
+            put(SHOW_HEX_VALUES, Integer.valueOf(F_SHOW_HEX_VALUES));
+            put(SHOW_LINE_INFO, Integer.valueOf(F_SHOW_LINE_INFO));
+            put(SHOW_ONLY_SELECTED_ELEMENT, Integer.valueOf(F_SHOW_ONLY_SELECTED_ELEMENT));
+            put(SHOW_RAW_BYTECODE, Integer.valueOf(F_SHOW_RAW_BYTECODE));
+            put(SHOW_STACKMAP, Integer.valueOf(F_SHOW_STACKMAP));
+            put(SHOW_VARIABLES, Integer.valueOf(F_SHOW_VARIABLES));
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferenceInitializer.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferenceInitializer.java
new file mode 100644
index 0000000..7d780a0
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferenceInitializer.java
@@ -0,0 +1,56 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.preferences;
+
+import org.eclipse.core.runtime.preferences.AbstractPreferenceInitializer;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jface.preference.IPreferenceStore;
+
+/**
+ * Initalizer of default values for BCO preferences
+ */
+public class BCOPreferenceInitializer extends AbstractPreferenceInitializer {
+
+    @Override
+    public void initializeDefaultPreferences() {
+        IPreferenceStore store = BytecodeOutlinePlugin.getDefault().getPreferenceStore();
+        store.setDefault(BCOConstants.LINK_VIEW_TO_EDITOR, true);
+        store.setDefault(BCOConstants.LINK_REF_VIEW_TO_EDITOR, true);
+
+        store.setDefault(BCOConstants.SHOW_ONLY_SELECTED_ELEMENT, true);
+
+        store.setDefault(BCOConstants.SHOW_RAW_BYTECODE, false);
+
+        store.setDefault(BCOConstants.SHOW_ASMIFIER_CODE, false);
+        store.setDefault(BCOConstants.DIFF_SHOW_ASMIFIER_CODE, false);
+
+        store.setDefault(BCOConstants.SHOW_ANALYZER, false);
+
+        store.setDefault(BCOConstants.SHOW_VARIABLES, true);
+        store.setDefault(BCOConstants.DIFF_SHOW_VARIABLES, true);
+
+        store.setDefault(BCOConstants.SHOW_LINE_INFO, true);
+        store.setDefault(BCOConstants.DIFF_SHOW_LINE_INFO, true);
+
+        store.setDefault(BCOConstants.SHOW_STACKMAP, true);
+        store.setDefault(BCOConstants.DIFF_SHOW_STACKMAP, true);
+
+        store.setDefault(BCOConstants.EXPAND_STACKMAP, false);
+        store.setDefault(BCOConstants.DIFF_EXPAND_STACKMAP, false);
+
+        store.setDefault(BCOConstants.RECALCULATE_STACKMAP, false);
+        store.setDefault(BCOConstants.SHOW_HEX_VALUES, false);
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferencePage.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferencePage.java
new file mode 100644
index 0000000..faca3c5
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/preferences/BCOPreferencePage.java
@@ -0,0 +1,179 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.preferences;
+
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jface.preference.BooleanFieldEditor;
+import org.eclipse.jface.preference.FieldEditorPreferencePage;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Group;
+import org.eclipse.swt.widgets.TabFolder;
+import org.eclipse.swt.widgets.TabItem;
+import org.eclipse.ui.IWorkbench;
+import org.eclipse.ui.IWorkbenchPreferencePage;
+
+/**
+ * This class represents a preference page that is contributed to the Preferences dialog.
+ * By subclassing <samp>FieldEditorPreferencePage</samp>, we can use the field support
+ * built into JFace that allows us to create a page that is small and knows how to save,
+ * restore and apply itself.
+ * <p>
+ * This page is used to modify preferences only. They are stored in the preference store
+ * that belongs to the main plug-in class. That way, preferences can be accessed directly
+ * via the preference store.
+ */
+public class BCOPreferencePage extends FieldEditorPreferencePage
+    implements
+        IWorkbenchPreferencePage {
+
+    public BCOPreferencePage() {
+        super(GRID);
+        setPreferenceStore(BytecodeOutlinePlugin.getDefault()
+            .getPreferenceStore());
+        setDescription(BytecodeOutlinePlugin
+            .getResourceString("BCOPreferencePage.description"));
+    }
+
+    @Override
+    public void setVisible(boolean visible) {
+        super.setVisible(visible);
+    }
+
+    @Override
+    protected void adjustGridLayout() {
+        super.adjustGridLayout();
+    }
+
+    /*
+     * Creates the field editors. Field editors are abstractions of the common GUI blocks
+     * needed to manipulate various types of preferences. Each field editor knows how to
+     * save and restore itself.
+     */
+    @Override
+    public void createFieldEditors() {
+
+        Composite fieldEditorParent = getFieldEditorParent();
+
+        TabFolder tabFolder = new TabFolder(fieldEditorParent, SWT.TOP);
+        tabFolder.setLayoutData(new GridData(GridData.FILL_BOTH));
+
+        TabItem tabPrefs = new TabItem(tabFolder, SWT.NONE);
+        tabPrefs.setText(BytecodeOutlinePlugin
+          .getResourceString("BCOPreferencePage.defaultsGroup"));
+
+        TabItem tabCompare = new TabItem(tabFolder, SWT.NONE);
+        tabCompare.setText(BytecodeOutlinePlugin
+            .getResourceString("BCOPreferencePage.compareGroup"));
+
+        Group viewGroup = new Group(tabFolder, SWT.NONE);
+        viewGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+        tabPrefs.setControl(viewGroup);
+
+        Group compareGroup = new Group(tabFolder, SWT.NONE);
+        compareGroup.setLayoutData(new GridData(GridData.FILL_BOTH));
+        tabCompare.setControl(compareGroup);
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.LINK_VIEW_TO_EDITOR, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.linkViewToEditor"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.LINK_REF_VIEW_TO_EDITOR, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.linkRefViewToEditor"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_ONLY_SELECTED_ELEMENT, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showOnlySelected"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_RAW_BYTECODE, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showRawBytecode"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_ASMIFIER_CODE, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showAsmifierCode"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_ANALYZER, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showAnalyzer"), viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_LINE_INFO, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showLineInfo"), viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_VARIABLES, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showVariables"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_STACKMAP, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showStackMap"), viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.SHOW_HEX_VALUES, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.showHexValues"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.EXPAND_STACKMAP, BytecodeOutlinePlugin
+            .getResourceString("BCOPreferencePage.expandStackMap"),
+            viewGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.DIFF_SHOW_ASMIFIER_CODE, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.diffShowAsmifierCode"),
+            compareGroup));
+        addField(new BooleanFieldEditor(
+            BCOConstants.DIFF_SHOW_LINE_INFO, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.diffShowLineInfo"),
+            compareGroup));
+        addField(new BooleanFieldEditor(
+            BCOConstants.DIFF_SHOW_VARIABLES, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.diffShowVariables"),
+            compareGroup));
+        addField(new BooleanFieldEditor(
+            BCOConstants.DIFF_SHOW_STACKMAP, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.diffShowStackMap"),
+            compareGroup));
+
+        addField(new BooleanFieldEditor(
+            BCOConstants.DIFF_EXPAND_STACKMAP, BytecodeOutlinePlugin
+                .getResourceString("BCOPreferencePage.diffExpandStackMap"),
+            compareGroup));
+
+        // addField( new BooleanFieldEditor( BCOConstants.RECALCULATE_STACKMAP,
+        // BytecodeOutlinePlugin.getResourceString(
+        // "BCOPreferencePage.recalculateStackMap" ),
+        // getFieldEditorParent() ) );
+    }
+
+    /*
+     * (non-Javadoc)
+     *
+     * @see org.eclipse.ui.IWorkbenchPreferencePage#init(org.eclipse.ui.IWorkbench)
+     */
+    @Override
+    public void init(IWorkbench workbench) {
+        //
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/EclipseUtils.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/EclipseUtils.java
new file mode 100644
index 0000000..7b3b5bd
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/EclipseUtils.java
@@ -0,0 +1,124 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.internal.ui.javaeditor.EditorUtility;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.ISelectionProvider;
+import org.eclipse.ui.IEditorInput;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IWorkbenchPage;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.eclipse.ui.texteditor.ITextEditor;
+
+public class EclipseUtils {
+
+    /**
+     * don't call me ;)
+     */
+    private EclipseUtils() {
+        super();
+    }
+
+    /**
+     * @return current active editor in workbench
+     */
+    public static IEditorPart getActiveEditor() {
+        IWorkbenchWindow window = BytecodeOutlinePlugin.getDefault()
+            .getWorkbench().getActiveWorkbenchWindow();
+        if (window != null) {
+            IWorkbenchPage page = window.getActivePage();
+            if (page != null) {
+                return page.getActiveEditor();
+            }
+        }
+        return null;
+    }
+
+    /**
+     * @param part
+     * @return editor input as IJavaElement
+     */
+    public static IJavaElement getJavaInput(IEditorPart part) {
+        IJavaElement input = part.getAdapter(IJavaElement.class);
+        if (input != null) {
+            return input;
+        }
+        IEditorInput editorInput = part.getEditorInput();
+        if (editorInput != null) {
+            input = editorInput.getAdapter(IJavaElement.class);
+        }
+        if (input != null) {
+            return input;
+        }
+        input = EditorUtility.getEditorInputJavaElement(part, false);
+        return input;
+    }
+
+    /**
+     * @param editor
+     * @param offset
+     * @param length
+     */
+    public static void selectInEditor(ITextEditor editor, int offset, int length) {
+        IEditorPart active = getActiveEditor();
+        if (active != editor) {
+            editor.getSite().getPage().activate(editor);
+        }
+        editor.selectAndReveal(offset, length);
+    }
+
+    /**
+     * @param selectionProvider
+     * @return TextSelection or null, if provider does not provide TextSelection's
+     */
+    public static ITextSelection getSelection(
+        ISelectionProvider selectionProvider) {
+        ISelection selection = selectionProvider.getSelection();
+        if (selection instanceof ITextSelection) {
+            return (ITextSelection) selection;
+        }
+        return null;
+    }
+
+    /**
+     * @param resource
+     * @return full package name in default java notation (with dots)
+     */
+    public static String getJavaPackageName(IJavaElement resource) {
+        String name;
+        if (resource == null) {
+            return "";
+        }
+        name = resource.getElementName();
+        if (name == null) {
+            return "";
+        }
+        int type = resource.getElementType();
+        if (type == IJavaElement.PACKAGE_FRAGMENT
+            || type == IJavaElement.PACKAGE_FRAGMENT_ROOT) {
+            return name;
+        }
+        IJavaElement ancestor = resource
+            .getAncestor(IJavaElement.PACKAGE_FRAGMENT);
+        if (ancestor != null) {
+            return ancestor.getElementName();
+        }
+        return ""; //$NON-NLS-1$
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/JdtUtils.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/JdtUtils.java
new file mode 100644
index 0000000..3cb3e93
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/JdtUtils.java
@@ -0,0 +1,1500 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+import java.io.File;
+import java.io.IOException;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URL;
+import java.net.URLClassLoader;
+import java.nio.file.Files;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.eclipse.core.filesystem.URIUtil;
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFolder;
+import org.eclipse.core.resources.IPathVariableManager;
+import org.eclipse.core.resources.IProject;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspace;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.IProgressMonitor;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.asm.DecompiledClass;
+import org.eclipse.jdt.core.Flags;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.IClasspathEntry;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IInitializer;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IMember;
+import org.eclipse.jdt.core.IMethod;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IParent;
+import org.eclipse.jdt.core.ISourceRange;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.ITypeParameter;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.Signature;
+import org.eclipse.jdt.core.search.IJavaSearchConstants;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.SearchEngine;
+import org.eclipse.jdt.core.search.SearchPattern;
+import org.eclipse.jdt.core.search.TypeNameRequestor;
+import org.eclipse.jface.text.ITextSelection;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.tree.InnerClassNode;
+
+public class JdtUtils {
+    /** package separator in bytecode notation */
+    private static final char PACKAGE_SEPARATOR = '/';
+    /** type name separator (for inner types) in bytecode notation */
+    private static final char TYPE_SEPARATOR = '$';
+
+    /**
+     *
+     */
+    private JdtUtils() {
+        // don't call
+    }
+
+    public static IJavaElement getMethod(IParent parent, String signature){
+        try {
+            IJavaElement[] children = parent.getChildren();
+            for (int i = 0; i < children.length; i++) {
+                IJavaElement javaElement = children[i];
+                switch (javaElement.getElementType()) {
+                    case IJavaElement.INITIALIZER :
+                        // fall through
+                    case IJavaElement.METHOD :
+                        if(signature.equals(getMethodSignature(javaElement))){
+                            return javaElement;
+                        }
+                        break;
+                    default :
+                        break;
+                }
+                if(javaElement instanceof IParent){
+                    javaElement = getMethod((IParent) javaElement, signature);
+                    if(javaElement != null){
+                        return javaElement;
+                    }
+                }
+            }
+        } catch (JavaModelException e) {
+            // just ignore it. Mostly caused by class files not on the class path
+            // which is not a problem for us, but a big problem for JDT
+        }
+        return null;
+    }
+
+    /**
+     * @param childEl
+     * @return method signature, if given java element is either initializer or method,
+     * otherwise returns null.
+     */
+    public static String getMethodSignature(IJavaElement childEl) {
+        String methodName = null;
+        if (childEl.getElementType() == IJavaElement.INITIALIZER) {
+            IInitializer ini = (IInitializer) childEl;
+            try {
+                if (Flags.isStatic(ini.getFlags())) {
+                    methodName = "<clinit>()V";
+                } else {
+                    methodName = "<init>()";
+                }
+            } catch (JavaModelException e) {
+                // this is compilation problem - don't show the message
+                BytecodeOutlinePlugin.log(e, IStatus.WARNING);
+            }
+        } else if (childEl.getElementType() == IJavaElement.METHOD) {
+            IMethod iMethod = (IMethod) childEl;
+            try {
+                methodName = createMethodSignature(iMethod);
+            } catch (JavaModelException e) {
+                // this is compilation problem - don't show the message
+                BytecodeOutlinePlugin.log(e, IStatus.WARNING);
+            }
+        }
+        return methodName;
+    }
+
+    public static String createMethodSignature(IMethod iMethod)
+        throws JavaModelException {
+        StringBuffer sb = new StringBuffer();
+
+        // Eclipse put class name as constructor name - we change it!
+        if (iMethod.isConstructor()) {
+            sb.append("<init>"); //$NON-NLS-1$
+        } else {
+            sb.append(iMethod.getElementName());
+        }
+
+        if (iMethod.isBinary()) { // iMethod instanceof BinaryMember
+            // binary info should be full qualified
+            return sb.append(iMethod.getSignature()).toString();
+        }
+
+        // start method parameter descriptions list
+        sb.append('(');
+        IType declaringType = iMethod.getDeclaringType();
+        String[] parameterTypes = iMethod.getParameterTypes();
+
+        /*
+         * For non - static inner classes bytecode constructor should contain as first
+         * parameter the enclosing type instance, but in Eclipse AST there are no
+         * appropriated parameter. So we need to create enclosing type signature and
+         * add it as first parameter.
+         */
+        if (iMethod.isConstructor() && isNonStaticInner(declaringType)) {
+            // this is a very special case
+            String typeSignature = getTypeSignature(getFirstAncestor(declaringType));
+            if(typeSignature != null) {
+                String [] newParams = new String [parameterTypes.length + 1];
+                newParams[0] = typeSignature;
+                System.arraycopy(parameterTypes, 0, newParams, 1, parameterTypes.length);
+                parameterTypes = newParams;
+            }
+        }
+
+        // doSomething(Lgenerics/DummyForAsmGenerics;)Lgenerics/DummyForAsmGenerics;
+        for (int i = 0; i < parameterTypes.length; i++) {
+            String resolvedType = getResolvedType(parameterTypes[i], declaringType);
+            if(resolvedType != null && resolvedType.length() > 0){
+                sb.append(resolvedType);
+            } else {
+                // this is a generic type
+                appendGenericType(sb, iMethod, parameterTypes[i]);
+            }
+        }
+        sb.append(')');
+
+        // continue here with adding resolved return type
+        String returnType = iMethod.getReturnType();
+        String resolvedType = getResolvedType(returnType, declaringType);
+        if(resolvedType != null && resolvedType.length() > 0){
+            sb.append(resolvedType);
+        } else {
+            // this is a generic type
+            appendGenericType(sb, iMethod, returnType);
+        }
+
+        return sb.toString();
+    }
+
+    /**
+     * @param type
+     * @return full qualified, resolved type name in bytecode notation
+     */
+    private static String getTypeSignature(IType type) {
+        if(type == null){
+            return null;
+        }
+        /*
+         * getFullyQualifiedName() returns name, where package separator is '.',
+         * but we need '/' for bytecode. The hack with ',' is to use a character
+         * which is not allowed as Java char to be sure not to replace too much
+         */
+        String name = type.getFullyQualifiedName(',');
+        // replace package separators
+        name = name.replace(Signature.C_DOT, PACKAGE_SEPARATOR);
+        // replace class separators
+        name = name.replace(',', TYPE_SEPARATOR);
+        return Signature.C_RESOLVED + name + Signature.C_SEMICOLON;
+    }
+
+    private static void appendGenericType(StringBuffer sb, IMethod iMethod,
+        String unresolvedType) throws JavaModelException{
+        IType declaringType = iMethod.getDeclaringType();
+
+        // unresolvedType is here like "QA;" => we remove "Q" and ";"
+        if(unresolvedType.length() < 3){
+            // ???? something wrong here ....
+            sb.append(unresolvedType);
+            return;
+        }
+        unresolvedType = unresolvedType.substring(1, unresolvedType.length() - 1);
+
+        ITypeParameter typeParameter = iMethod.getTypeParameter(unresolvedType);
+        if(typeParameter == null || !typeParameter.exists()){
+            typeParameter = declaringType.getTypeParameter(unresolvedType);
+        }
+
+        String[] bounds = typeParameter.getBounds();
+        if(bounds.length == 0){
+            sb.append("Ljava/lang/Object;");
+        } else {
+            for (int i = 0; i < bounds.length; i++) {
+                String simplyName = bounds[i];
+                simplyName =  Signature.C_UNRESOLVED + simplyName + Signature.C_NAME_END;
+                String resolvedType = getResolvedType(simplyName, declaringType);
+                sb.append(resolvedType);
+            }
+        }
+    }
+
+    /**
+     * @param typeToResolve
+     * @param declaringType
+     * @return full qualified "bytecode formatted" type
+     * @throws JavaModelException
+     */
+    private static String getResolvedType(String typeToResolve,
+        IType declaringType) throws JavaModelException {
+        StringBuffer sb = new StringBuffer();
+        int arrayCount = Signature.getArrayCount(typeToResolve);
+        // test which letter is following - Q or L are for reference types
+        boolean isPrimitive = isPrimitiveType(typeToResolve.charAt(arrayCount));
+        if (isPrimitive) {
+            // simply add whole string (probably with array chars like [[I etc.)
+            sb.append(typeToResolve);
+        } else {
+            boolean isUnresolvedType = isUnresolvedType(typeToResolve, arrayCount);
+            if(!isUnresolvedType) {
+                sb.append(typeToResolve);
+            } else {
+                // we need resolved types
+                String resolved = getResolvedTypeName(typeToResolve, declaringType);
+                if(resolved != null) {
+                    while (arrayCount > 0) {
+                        sb.append(Signature.C_ARRAY);
+                        arrayCount--;
+                    }
+                    sb.append(Signature.C_RESOLVED);
+                    sb.append(resolved);
+                    sb.append(Signature.C_SEMICOLON);
+                }
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Copied and modified from JavaModelUtil. Resolves a type name in the context of the
+     * declaring type.
+     * @param refTypeSig the type name in signature notation (for example 'QVector') this
+     * can also be an array type, but dimensions will be ignored.
+     * @param declaringType the context for resolving (type where the reference was made
+     * in)
+     * @return returns the fully qualified <b>bytecode </b> type name or build-in-type
+     * name. if a unresoved type couldn't be resolved null is returned
+     */
+    private static String getResolvedTypeName(String refTypeSig,
+        IType declaringType) throws JavaModelException {
+
+        /* the whole method is copied from JavaModelUtil.getResolvedTypeName(...).
+         * The problem is, that JavaModelUtil uses '.' to separate package
+         * names, but we need '/' -> see JavaModelUtil.concatenateName() vs
+         * JdtUtils.concatenateName()
+         */
+        int arrayCount = Signature.getArrayCount(refTypeSig);
+        if (isUnresolvedType(refTypeSig, arrayCount)) {
+            String name= ""; //$NON-NLS-1$
+            int bracket= refTypeSig.indexOf(Signature.C_GENERIC_START, arrayCount + 1);
+            if (bracket > 0) {
+                name= refTypeSig.substring(arrayCount + 1, bracket);
+            } else {
+                int semi= refTypeSig.indexOf(Signature.C_SEMICOLON, arrayCount + 1);
+                if (semi == -1) {
+                    throw new IllegalArgumentException();
+                }
+                name= refTypeSig.substring(arrayCount + 1, semi);
+            }
+            String[][] resolvedNames= declaringType.resolveType(name);
+            if (resolvedNames != null && resolvedNames.length > 0) {
+                return concatenateName(resolvedNames[0][0], resolvedNames[0][1]);
+            }
+            return null;
+        }
+        return refTypeSig.substring(arrayCount);// Signature.toString(substring);
+    }
+
+    /**
+     * @param refTypeSig
+     * @param arrayCount expected array count in the signature
+     * @return true if the given string is an unresolved signature (Eclipse - internal
+     * representation)
+     */
+    private static boolean isUnresolvedType(String refTypeSig, int arrayCount){
+        char type = refTypeSig.charAt(arrayCount);
+        return type == Signature.C_UNRESOLVED;
+    }
+
+    /**
+     * Concatenates package and class name. Both strings can be empty or <code>null</code>.
+     */
+    private static String concatenateName(String packageName, String className) {
+        StringBuffer buf = new StringBuffer();
+        if (packageName != null && packageName.length() > 0) {
+            packageName = packageName.replace(Signature.C_DOT, PACKAGE_SEPARATOR);
+            buf.append(packageName);
+        }
+        if (className != null && className.length() > 0) {
+            if (buf.length() > 0) {
+                buf.append(PACKAGE_SEPARATOR);
+            }
+            className = className.replace(Signature.C_DOT, TYPE_SEPARATOR);
+            buf.append(className);
+        }
+        return buf.toString();
+    }
+
+    /**
+     * Test which letter is following - Q or L are for reference types
+     * @param first
+     * @return true, if character is not a simbol for reference types
+     */
+    private static boolean isPrimitiveType(char first) {
+        return (first != Signature.C_RESOLVED && first != Signature.C_UNRESOLVED);
+    }
+
+    /**
+     * @param childEl may be null
+     * @return first ancestor with IJavaElement.TYPE element type, or null
+     */
+    public static IType getEnclosingType(IJavaElement childEl) {
+        if (childEl == null) {
+            return null;
+        }
+        return (IType) childEl.getAncestor(IJavaElement.TYPE);
+    }
+
+    /**
+     * @param cf
+     * @param dc
+     * @return inner type which has the same name as the given string, or null
+     */
+    public static IOrdinaryClassFile getInnerType(IOrdinaryClassFile cf, DecompiledClass dc,
+        String typeSignature) {
+        if(typeSignature.endsWith(";")){
+            typeSignature = typeSignature.substring(0, typeSignature.length()-1);
+            if(typeSignature.startsWith("L")){
+                typeSignature = typeSignature.substring(1, typeSignature.length());
+            }
+        }
+        /*
+         * For inner and anonymous classes from the blocks or methods
+         * getFullyQualifiedName() does not work if class was compiled with 1.5
+         * and will never match the fullTypeName...
+         * I'm not sure if it is intended or if it is a bug
+         * in Eclipse: instead of A$1B we get A$B for B class from a method in A
+         *
+         * NB: for binary types without source attachment the method elements doesn't
+         * contain source and therefore could not resolve child elements.
+         * So the search for local types will never work...
+         *
+         * Therefore we do not use Eclipse API and use ClassNode->InnerClassNode elements
+         */
+        ClassNode cn = dc.getClassNode();
+        List<InnerClassNode> innerClasses = cn.innerClasses;
+
+        for (int i = 0; i < innerClasses.size(); i++) {
+            InnerClassNode in = innerClasses.get(i);
+            if(typeSignature.equals(in.name)){
+                int idx = typeSignature.lastIndexOf(PACKAGE_SEPARATOR);
+                String className = typeSignature;
+                if (idx > 0) {
+                    className = typeSignature.substring(idx + 1, typeSignature.length());
+                }
+                className += ".class";
+                return (IOrdinaryClassFile) cf.getType().getPackageFragment().getClassFile(className);
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Modified copy from org.eclipse.jdt.internal.ui.actions.SelectionConverter
+     * @param input
+     * @param selection
+     * @return null, if selection is null or could not be resolved to java element
+     * @throws JavaModelException
+     */
+    public static IJavaElement getElementAtOffset(IJavaElement input,
+        ITextSelection selection) throws JavaModelException {
+        if(selection == null){
+            return null;
+        }
+        ICompilationUnit workingCopy = null;
+        if (input instanceof ICompilationUnit) {
+            workingCopy = (ICompilationUnit) input;
+            // be in-sync with model
+            // instead of using internal JavaModelUtil.reconcile(workingCopy);
+            synchronized(workingCopy)  {
+                workingCopy.reconcile(
+                    ICompilationUnit.NO_AST,
+                    false /* don't force problem detection */,
+                    null /* use primary owner */,
+                    null /* no progress monitor */);
+            }
+            IJavaElement ref = workingCopy.getElementAt(selection.getOffset());
+            if (ref != null) {
+                return ref;
+            }
+        } else if (input instanceof IClassFile) {
+            IClassFile iClass = (IClassFile) input;
+            IJavaElement ref = iClass.getElementAt(selection.getOffset());
+            if (ref != null) {
+                // If we are in the inner class, try to refine search result now
+                if(ref instanceof IType){
+                    IType type = (IType) ref;
+                    IClassFile classFile = type.getClassFile();
+                    if(classFile != iClass){
+                        /*
+                         * WORKAROUND it seems that source range for constructors from
+                         * bytecode with source attached from zip files is not computed
+                         * in Eclipse (SourceMapper returns nothing useful).
+                         * Example: HashMap$Entry class with constructor
+                         * <init>(ILjava/lang/Object;Ljava/lang/Object;Ljava/util/HashMap$Entry;)V
+                         * We will get here at least the inner class...
+                         * see https://bugs.eclipse.org/bugs/show_bug.cgi?id=137847
+                         */
+                        ref = classFile.getElementAt(selection.getOffset());
+                    }
+                }
+                return ref;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Modified copy from JavaModelUtil.
+     * @param javaElt
+     * @return true, if corresponding java project has compiler setting to generate
+     * bytecode for jdk 1.5 and above
+     */
+    public static boolean is50OrHigher(IJavaElement javaElt) {
+        IJavaProject project = javaElt.getJavaProject();
+        String option = project.getOption(JavaCore.COMPILER_COMPLIANCE, true);
+        boolean result = JavaCore.VERSION_1_5.equals(option);
+        if(result){
+            return result;
+        }
+        // probably > 1.5?
+        result = JavaCore.VERSION_1_4.equals(option);
+        if(result){
+            return false;
+        }
+        result = JavaCore.VERSION_1_3.equals(option);
+        if(result){
+            return false;
+        }
+        result = JavaCore.VERSION_1_2.equals(option);
+        if(result){
+            return false;
+        }
+        result = JavaCore.VERSION_1_1.equals(option);
+        if(result){
+            return false;
+        }
+        // unknown = > 1.5
+        return true;
+    }
+
+    /**
+     * Cite: jdk1.1.8/docs/guide/innerclasses/spec/innerclasses.doc10.html: For the sake
+     * of tools, there are some additional requirements on the naming of an inaccessible
+     * class N. Its bytecode name must consist of the bytecode name of an enclosing class
+     * (the immediately enclosing class, if it is a member), followed either by `$' and a
+     * positive decimal numeral chosen by the compiler, or by `$' and the simple name of
+     * N, or else by both (in that order). Moreover, the bytecode name of a block-local N
+     * must consist of its enclosing package member T, the characters `$1$', and N, if the
+     * resulting name would be unique.
+     * <br>
+     * Note, that this rule was changed for static blocks after 1.5 jdk.
+     * @param javaElement
+     * @return simply element name
+     */
+    public static String getElementName(IJavaElement javaElement) {
+        if (isAnonymousType(javaElement)) {
+            IType anonType = (IType) javaElement;
+            List<IJavaElement> allAnonymous = new ArrayList<>();
+            /*
+             * in order to resolve anon. class name we need to know about all other
+             * anonymous classes in declaring class, therefore we need to collect all here
+             */
+            collectAllAnonymous(allAnonymous, anonType);
+            int idx = getAnonimousIndex(anonType, allAnonymous
+                .toArray(new IType[allAnonymous.size()]));
+            return Integer.toString(idx);
+        }
+        String name = javaElement.getElementName();
+        if (isLocal(javaElement)) {
+            /*
+             * Compiler have different naming conventions for inner non-anon. classes in
+             * static blocks or any methods, this difference was introduced with 1.5 JDK.
+             * The problem is, that we could have projects with classes, generated
+             * with both 1.5 and earlier settings. One could not see on particular
+             * java element, for which jdk version the existing bytecode was generated.
+             * If we could have a *.class file, but we are just searching for one...
+             * So there could be still a chance, that this code fails, if java element
+             * is not compiled with comiler settings from project, but with different
+             */
+            if(is50OrHigher(javaElement)){
+                name = "1" + name; // compiler output changed for > 1.5 code
+            } else {
+                name = "1$" + name; // see method comment, this was the case for older code
+            }
+        }
+
+        if (name.endsWith(".java")) { //$NON-NLS-1$
+            name = name.substring(0, name.lastIndexOf(".java")); //$NON-NLS-1$
+        } else if (name.endsWith(".class")) { //$NON-NLS-1$
+            name = name.substring(0, name.lastIndexOf(".class")); //$NON-NLS-1$
+        }
+        return name;
+    }
+
+    /**
+     * @param javaElement
+     * @return null, if javaElement is top level class
+     */
+    private static IType getFirstAncestor(IJavaElement javaElement) {
+        IJavaElement parent = javaElement;
+        if (javaElement.getElementType() == IJavaElement.TYPE) {
+            parent = javaElement.getParent();
+        }
+        if (parent != null) {
+            return (IType) parent.getAncestor(IJavaElement.TYPE);
+        }
+        return null;
+    }
+
+    private static IJavaElement getLastAncestor(IJavaElement javaElement,
+        int elementType) {
+        IJavaElement lastFound = null;
+        if (elementType == javaElement.getElementType()) {
+            lastFound = javaElement;
+        }
+        IJavaElement parent = javaElement.getParent();
+        if (parent == null) {
+            return lastFound;
+        }
+        IJavaElement ancestor = parent.getAncestor(elementType);
+        if (ancestor != null) {
+            return getLastAncestor(ancestor, elementType);
+        }
+        return lastFound;
+    }
+
+    /**
+     * @param javaElement
+     * @return distance to given ancestor, 0 if it is the same, -1 if ancestor with type
+     * IJavaElement.TYPE does not exist
+     */
+    private static int getTopAncestorDistance(IJavaElement javaElement,
+        IJavaElement topAncestor) {
+        if (topAncestor == javaElement) {
+            return 0;
+        }
+        IJavaElement ancestor = getFirstAncestor(javaElement);
+        if (ancestor != null) {
+            return 1 + getTopAncestorDistance(ancestor, topAncestor);
+        }
+        // this is not possible, if ancestor exist - which return value we should use?
+        return -1;
+    }
+
+    /**
+     * @param javaElement
+     * @return first non-anonymous ancestor
+     */
+    private static IJavaElement getFirstNonAnonymous(IJavaElement javaElement,
+        IJavaElement topAncestor) {
+        if (javaElement.getElementType() == IJavaElement.TYPE
+            && !isAnonymousType(javaElement)) {
+            return javaElement;
+        }
+        IJavaElement parent = javaElement.getParent();
+        if (parent == null) {
+            return topAncestor;
+        }
+        IJavaElement ancestor = parent.getAncestor(IJavaElement.TYPE);
+        if (ancestor != null) {
+            return getFirstNonAnonymous(ancestor, topAncestor);
+        }
+        return topAncestor;
+    }
+
+    /**
+     * @param javaElement
+     * @return true, if given element is anonymous inner class
+     */
+    private static boolean isAnonymousType(IJavaElement javaElement) {
+        try {
+            return javaElement instanceof IType && ((IType)javaElement).isAnonymous();
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        return false;
+    }
+
+    /**
+     * @param innerType should be inner type.
+     * @return true, if given element is inner class from initializer block or method body
+     */
+    private static boolean isLocal(IJavaElement innerType) {
+        try {
+            return innerType instanceof IType && ((IType)innerType).isLocal();
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        return false;
+    }
+
+    /**
+     * @param elt
+     * @return true, if given element is inner class from initializer block or method body
+     */
+    private static boolean isAnyParentLocal(IJavaElement elt, IJavaElement topParent) {
+        if(isLocal(elt)){
+            return true;
+        }
+        IJavaElement parent = elt.getParent();
+        while(parent != null && parent != topParent){
+            if(isLocal(parent)){
+                return true;
+            }
+            parent = parent.getParent();
+        }
+        return false;
+    }
+
+    /**
+     * @param type
+     * @return true, if given element is non static inner class
+     * @throws JavaModelException
+     */
+    private static boolean isNonStaticInner(IType type) throws JavaModelException {
+        if(type.isMember()){
+            return !Flags.isStatic(type.getFlags());
+        }
+        return false;
+    }
+
+    /**
+     * @param innerType should be inner type.
+     * @return true, if given element is a type defined in the initializer block
+     */
+    private static boolean isFromInitBlock(IType type) {
+        IJavaElement ancestor = type.getAncestor(IJavaElement.INITIALIZER);
+        return ancestor != null;
+    }
+
+    /**
+     * @param javaElement
+     * @return absolute path of generated bytecode package for given element
+     * @throws JavaModelException
+     */
+    private static String getPackageOutputPath(IJavaElement javaElement)
+        throws JavaModelException {
+        String dir = ""; //$NON-NLS-1$
+        if (javaElement == null) {
+            return dir;
+        }
+
+        IJavaProject project = javaElement.getJavaProject();
+
+        if (project == null) {
+            return dir;
+        }
+        // default bytecode location
+        IPath path = project.getOutputLocation();
+
+        IResource resource = javaElement.getUnderlyingResource();
+        if (resource == null) {
+            return dir;
+        }
+        // resolve multiple output locations here
+        if (project.exists() && project.getProject().isOpen()) {
+            IClasspathEntry entries[] = project.getRawClasspath();
+            for (int i = 0; i < entries.length; i++) {
+                IClasspathEntry classpathEntry = entries[i];
+                if (classpathEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
+                    IPath outputPath = classpathEntry.getOutputLocation();
+                    if (outputPath != null
+                        && classpathEntry.getPath().isPrefixOf(
+                            resource.getFullPath())) {
+                        path = outputPath;
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (path == null) {
+            // check the default location if not already included
+            IPath def = project.getOutputLocation();
+            if (def != null && def.isPrefixOf(resource.getFullPath())){
+                path = def;
+            }
+        }
+
+        if(path == null){
+            return dir;
+        }
+
+        IWorkspace workspace = ResourcesPlugin.getWorkspace();
+
+        if (!project.getPath().equals(path)) {
+            IFolder outputFolder = workspace.getRoot().getFolder(path);
+            if (outputFolder != null) {
+                // linked resources will be resolved here!
+                IPath rawPath = outputFolder.getRawLocation();
+                if (rawPath != null) {
+                    path = rawPath;
+                }
+            }
+        } else {
+            path = project.getProject().getLocation();
+        }
+
+        // here we should resolve path variables,
+        // probably existing at first place of path
+        IPathVariableManager pathManager = workspace.getPathVariableManager();
+        URI resolvedURI = pathManager.resolveURI(URIUtil.toURI(path));
+        if(resolvedURI != null) {
+            path = URIUtil.toPath(resolvedURI);
+        }
+
+        if (path == null) {
+            return dir;
+        }
+
+        if (isPackageRoot(project, resource)) {
+            dir = path.toOSString();
+        } else {
+            String packPath = EclipseUtils.getJavaPackageName(javaElement)
+                .replace(Signature.C_DOT, PACKAGE_SEPARATOR);
+            dir = path.append(packPath).toOSString();
+        }
+        return dir;
+    }
+
+    /**
+     * @param project
+     * @param pack
+     * @return true if 'pack' argument is package root
+     * @throws JavaModelException
+     */
+    private static boolean isPackageRoot(IJavaProject project, IResource pack)
+        throws JavaModelException {
+        boolean isRoot = false;
+        if (project == null || pack == null || !(pack instanceof IContainer)) {
+            return isRoot;
+        }
+        IPackageFragmentRoot root = project.getPackageFragmentRoot(pack);
+        IClasspathEntry clPathEntry = null;
+        if (root != null) {
+            clPathEntry = root.getRawClasspathEntry();
+        }
+        isRoot = clPathEntry != null;
+        return isRoot;
+    }
+
+    /**
+     * Works only for eclipse - managed/generated bytecode, ergo not with imported
+     * classes/jars
+     * @param javaElement
+     * @return full os-specific file path to .class resource, containing given element
+     */
+    public static String getByteCodePath(IJavaElement javaElement) {
+        if (javaElement == null) {
+            return "";//$NON-NLS-1$
+        }
+        String packagePath = ""; //$NON-NLS-1$
+        try {
+            packagePath = getPackageOutputPath(javaElement);
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+            return "";
+        }
+        IJavaElement ancestor = getLastAncestor(javaElement, IJavaElement.TYPE);
+        StringBuffer sb = new StringBuffer(packagePath);
+        sb.append(File.separator);
+        sb.append(getClassName(javaElement, ancestor));
+        sb.append(".class"); //$NON-NLS-1$
+        return sb.toString();
+    }
+
+    /**
+     * @param javaElement
+     * @return new generated input stream for given element bytecode class file, or null
+     * if class file cannot be found or this element is not from java source path
+     */
+    public static byte[] readClassBytes(IJavaElement javaElement) {
+        IClassFile classFile = (IClassFile) javaElement
+            .getAncestor(IJavaElement.CLASS_FILE);
+
+        // existing read-only class files
+        if (classFile != null) {
+            try {
+                return classFile.getBytes();
+            } catch (JavaModelException e) {
+                BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+            }
+        } else {
+            // usual eclipse - generated bytecode
+            boolean inJavaPath = isOnClasspath(javaElement);
+            if (!inJavaPath) {
+                return null;
+            }
+            String classPath = getByteCodePath(javaElement);
+            if(classPath.isEmpty()) {
+                return null;
+            }
+            try {
+                return Files.readAllBytes(Paths.get(classPath));
+            } catch (IOException e) {
+                // if autobuild is disabled, we get tons of this errors.
+                // but I think we cannot ignore them, therefore WARNING and not
+                // ERROR status
+                BytecodeOutlinePlugin.log(e, IStatus.WARNING);
+            }
+        }
+        return null;
+    }
+
+    private static boolean isOnClasspath(IJavaElement javaElement) {
+        IJavaProject project = javaElement.getJavaProject();
+        if (project != null) {
+            boolean result = project.isOnClasspath(javaElement);
+            return result;
+        }
+        return false;
+    }
+
+    /**
+     * @param classFile
+     * @return full qualified bytecode name of given class
+     */
+    public static String getFullBytecodeName(IClassFile classFile) {
+        IPackageFragment packageFr = (IPackageFragment) classFile
+            .getAncestor(IJavaElement.PACKAGE_FRAGMENT);
+        if (packageFr == null) {
+            return null;
+        }
+        String packageName = packageFr.getElementName();
+        // switch to java bytecode naming conventions
+        packageName = packageName.replace(Signature.C_DOT, PACKAGE_SEPARATOR);
+
+        String className = classFile.getElementName();
+        if (packageName != null && packageName.length() > 0) {
+            return packageName + PACKAGE_SEPARATOR + className;
+        }
+        return className;
+    }
+
+    /**
+     * @param javaElement
+     * @param topAncestor
+     * @param sb
+     */
+    private static String getClassName(IJavaElement javaElement,
+        IJavaElement topAncestor) {
+        StringBuffer sb = new StringBuffer();
+        if (!javaElement.equals(topAncestor)) {
+            int elementType = javaElement.getElementType();
+            if(elementType == IJavaElement.FIELD
+                || elementType == IJavaElement.METHOD
+                 || elementType == IJavaElement.INITIALIZER) {
+                // it's field or method
+                javaElement = getFirstAncestor(javaElement);
+            } else {
+                boolean is50OrHigher = is50OrHigher(javaElement);
+                if (!is50OrHigher &&
+                    (isAnonymousType(javaElement) || isLocal(javaElement))) {
+                    // it's inner type
+                    sb.append(getElementName(topAncestor));
+                    sb.append(TYPE_SEPARATOR);
+                } else {
+                    /*
+                     * TODO there is an issue with < 1.5 compiler setting and with inner
+                     * classes with the same name but defined in different methods in the same
+                     * source file. Then compiler needs to generate *different* content for
+                     *  A$1$B and A$1$B, which is not possible so therefore compiler generates
+                     *  A$1$B and A$2$B. The naming order is the source range order of inner
+                     *  classes, so the first inner B class will get A$1$B and the second
+                     *  inner B class A$2$B etc.
+                     */
+
+                    // override top ancestor with immediate ancestor
+                    topAncestor = getFirstAncestor(javaElement);
+                    while (topAncestor != null) {
+                        sb.insert(0, getElementName(topAncestor) + TYPE_SEPARATOR);
+                        topAncestor = getFirstAncestor(topAncestor);
+                    }
+                }
+            }
+        }
+        sb.append(getElementName(javaElement));
+        return sb.toString();
+    }
+
+    /**
+     * Collect all anonymous classes which are on the same "name shema level"
+     * as the given element for the compiler. The list could contain different set of
+     * elements for the same source code, depends on the compiler and jdk version
+     * @param list for the found anon. classes, elements instanceof IType.
+     * @param anonType the anon. type
+     */
+    private static void collectAllAnonymous(List<IJavaElement> list, IType anonType) {
+        /*
+         * For JDK >= 1.5 in Eclipse 3.1+ the naming shema for nested anonymous
+         * classes was changed from A$1, A$2, A$3, A$4, ..., A$n
+         * to A$1, A$1$1, A$1$2, A$1$2$1, ..., A$2, A$2$1, A$2$2, ..., A$x$y
+         */
+        boolean allowNested = ! is50OrHigher(anonType);
+
+        IParent declaringType;
+        if(allowNested) {
+            declaringType = (IType) getLastAncestor(anonType, IJavaElement.TYPE);
+        } else {
+            declaringType = anonType.getDeclaringType();
+        }
+
+        try {
+            collectAllAnonymous(list, declaringType, allowNested);
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        sortAnonymous(list, anonType);
+        return;
+    }
+
+    /**
+     * Traverses down the children tree of this parent and collect all child anon. classes
+     * @param list
+     * @param parent
+     * @param allowNested true to search in IType child elements too
+     * @throws JavaModelException
+     */
+    private static void collectAllAnonymous(List<IJavaElement> list, IParent parent,
+        boolean allowNested) throws JavaModelException {
+        IJavaElement[] children = parent.getChildren();
+        for (int i = 0; i < children.length; i++) {
+            IJavaElement childElem = children[i];
+            if (isAnonymousType(childElem)) {
+                list.add(childElem);
+            }
+            if (childElem instanceof IParent) {
+                if(allowNested || !(childElem instanceof IType)) {
+                    collectAllAnonymous(list, (IParent) childElem, allowNested);
+                }
+            }
+        }
+    }
+
+    /**
+     * @param anonType
+     * @param anonymous
+     * @return the index of given java element in the anon. classes list, which was used
+     *  by compiler to generate bytecode name for given element. If the given type is not
+     *  in the list, then return value is '-1'
+     */
+    private static int getAnonimousIndex(IType anonType, IType[] anonymous) {
+
+        for (int i = 0; i < anonymous.length; i++) {
+            if (anonymous[i] == anonType) {
+                // +1 because compiler starts generated classes always with 1
+                return i + 1;
+            }
+        }
+        return -1;
+    }
+
+    /**
+     * Sort given anonymous classes in order like java compiler would generate output
+     * classes, in context of given anonymous type
+     * @param anonymous
+     */
+    private static void sortAnonymous(List<IJavaElement> anonymous, IType anonType) {
+        SourceOffsetComparator sourceComparator = new SourceOffsetComparator();
+
+        final AnonymClassComparator classComparator = new AnonymClassComparator(
+            anonType, sourceComparator);
+        Collections.sort(anonymous, classComparator);
+
+        if(BytecodeOutlinePlugin.DEBUG){
+            debugCompilePrio(classComparator);
+        }
+    }
+
+    private static void debugCompilePrio(
+        final AnonymClassComparator classComparator) {
+        final Map<IType, Integer> map = classComparator.map;
+        Comparator<IType> prioComp = new Comparator<IType>() {
+
+            @Override
+            public int compare(IType e1, IType e2) {
+                int result = map.get(e2).compareTo(map.get(e1));
+                if (result == 0) {
+                    return e1.toString().compareTo(e2.toString());
+                }
+                return result;
+            }
+
+        };
+
+        List<IType> keys = new ArrayList<>(map.keySet());
+        Collections.sort(keys, prioComp);
+        for (Iterator<IType> iterator = keys.iterator(); iterator.hasNext();) {
+            Object key = iterator.next();
+            System.out.println(map.get(key) + " : " + key);
+        }
+    }
+
+    /**
+     * 1) from instance init 2) from deepest inner from instance init (deepest first) 3) from
+     * static init 4) from deepest inner from static init (deepest first) 5) from deepest inner
+     * (deepest first) 6) regular anon classes from main class
+     *
+     * <br>
+     * Note, that nested inner anon. classes which do not have different non-anon. inner class
+     * ancestors, are compiled in they nesting order, opposite to rule 2)
+     *
+     * @param javaElement
+     * @return priority - lesser mean wil be compiled later, a value > 0
+     * @throws JavaModelException
+     */
+    private static int getAnonCompilePriority50(IJavaElement javaElement,
+        IJavaElement firstAncestor, IJavaElement topAncestor) {
+
+        // search for initializer block
+        IJavaElement initBlock = getLastAncestor(javaElement, IJavaElement.INITIALIZER);
+        // test is for anon. classes from initializer blocks
+        if (initBlock != null) {
+            return 10; // from inner from class init
+        }
+
+        // test for anon. classes from "regular" code
+        return 5;
+    }
+
+    private static int getAnonCompilePriority(IJavaElement elt,
+        IJavaElement firstAncestor, IJavaElement topAncestor, boolean is50OrHigher) {
+        if(is50OrHigher){
+            return getAnonCompilePriority50(elt, firstAncestor, topAncestor);
+        }
+
+        IJavaElement firstNonAnon = getFirstNonAnonymous(elt, topAncestor);
+
+        // get rid of children from local types
+        if(topAncestor != firstNonAnon && isLocal(firstNonAnon)){
+            return 5; // local anon. types have same prio as anon. from regular code
+        }
+
+        IJavaElement initBlock = getLastAncestor(elt, IJavaElement.INITIALIZER);
+        // test is for anon. classes from initializer blocks
+        if (initBlock != null) {
+            if(isAnyParentLocal(firstAncestor, topAncestor)){
+                return 5; // init blocks from local types have same prio as regular
+            }
+            if (firstAncestor == topAncestor) {
+                return 10; // instance init from top level type has top prio
+            }
+            if ( /*firstNonAnon != topAncestor && */!isStatic((IMember) firstNonAnon)) {
+                return 8; // init blocks from non static types have top 2 prio
+            }
+            return 7; // init blocks from static classes
+        }
+
+        if (firstNonAnon != topAncestor) {
+            if (!isStatic((IMember) firstNonAnon)) {
+                return 7; // children of member types first
+            }
+            return 6; // childern of static types
+        }
+
+        // anon. types from "regular" code
+        return 5;
+    }
+
+    private static boolean isStatic(IMember firstNonAnon) {
+        int topFlags = 0;
+        try {
+            topFlags = firstNonAnon.getFlags();
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        return Flags.isStatic(topFlags);
+    }
+
+    public static ClassLoader getClassLoader(IJavaElement type) {
+        ClassLoader cl;
+
+        IJavaProject javaProject = type.getJavaProject();
+        List<URL> urls = new ArrayList<>();
+
+        getClassURLs(javaProject, urls);
+
+        if (urls.isEmpty()) {
+            cl = JdtUtils.class.getClassLoader();
+        } else {
+            cl = new URLClassLoader(urls.toArray(new URL[urls.size()]));
+        }
+        return cl;
+    }
+
+    private static void getClassURLs(IJavaProject javaProject, List<URL> urls) {
+        IProject project = javaProject.getProject();
+        IWorkspaceRoot workspaceRoot = project.getWorkspace().getRoot();
+
+        IClasspathEntry[] paths = null;
+        IPath defaultOutputLocation = null;
+        try {
+            paths = javaProject.getResolvedClasspath(true);
+            defaultOutputLocation = javaProject.getOutputLocation();
+        } catch (JavaModelException e) {
+            // don't show message to user neither log it
+            // BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        if (paths != null) {
+            IPath projectPath = javaProject.getProject().getLocation();
+            for (int i = 0; i < paths.length; ++i) {
+                IClasspathEntry cpEntry = paths[i];
+                IPath p = null;
+                if (cpEntry.getEntryKind() == IClasspathEntry.CPE_SOURCE) {
+                    // filter out source container - there are unused for class
+                    // search - add bytecode output location instead
+                    p = cpEntry.getOutputLocation();
+                    if (p == null) {
+                        // default output used:
+                        p = defaultOutputLocation;
+                    }
+                } else if (cpEntry.getEntryKind() == IClasspathEntry.CPE_PROJECT) {
+                    String projName = cpEntry.getPath().toPortableString()
+                        .substring(1);
+                    IProject proj = workspaceRoot.getProject(projName);
+                    IJavaProject projj = JavaCore.create(proj);
+                    getClassURLs(projj, urls);
+                    continue;
+                } else {
+                    p = cpEntry.getPath();
+                }
+
+                if (p == null) {
+                    continue;
+                }
+                if (!p.toFile().exists()) {
+                    // removeFirstSegments: remove project from relative path
+                    p = projectPath.append(p.removeFirstSegments(1));
+                    if (!p.toFile().exists()) {
+                        continue;
+                    }
+                }
+                try {
+                    urls.add(p.toFile().toURI().toURL());
+                } catch (MalformedURLException e) {
+                    // don't show message to user
+                    BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+                }
+            }
+        }
+    }
+
+    /**
+     * Check if java element is an interface or abstract method or a method from
+     * interface.
+     */
+    public static boolean isAbstractOrInterface(IJavaElement javaEl) {
+        if (javaEl == null) {
+            return true;
+        }
+        boolean abstractOrInterface = false;
+        try {
+            switch (javaEl.getElementType()) {
+                case IJavaElement.CLASS_FILE :
+                    IClassFile classFile = (IClassFile) javaEl;
+                    if(isOnClasspath(javaEl)) {
+                        abstractOrInterface = classFile.isInterface();
+                    } /*else {
+                       this is the case for eclipse-generated class files.
+                       if we do not perform the check in if, then we will have java model
+                       exception on classFile.isInterface() call.
+                    }*/
+                    break;
+                case IJavaElement.COMPILATION_UNIT :
+                    ICompilationUnit cUnit = (ICompilationUnit) javaEl;
+                    IType type = cUnit.findPrimaryType();
+                    abstractOrInterface = type != null && type.isInterface();
+                    break;
+                case IJavaElement.TYPE :
+                    abstractOrInterface = ((IType) javaEl).isInterface();
+                    break;
+                case IJavaElement.METHOD :
+                    // test for "abstract" flag on method in a class
+                    abstractOrInterface = Flags.isAbstract(((IMethod) javaEl)
+                        .getFlags());
+                    // "abstract" flags could be not exist on interface methods
+                    if (!abstractOrInterface) {
+                        IType ancestor = (IType) javaEl
+                            .getAncestor(IJavaElement.TYPE);
+                        abstractOrInterface = ancestor != null
+                            && ancestor.isInterface();
+                    }
+                    break;
+                default :
+                    IType ancestor1 = (IType) javaEl
+                        .getAncestor(IJavaElement.TYPE);
+                    abstractOrInterface = ancestor1 != null
+                        && ancestor1.isInterface();
+                    break;
+            }
+        } catch (JavaModelException e) {
+            // No point to log it here
+            // BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+        return abstractOrInterface;
+    }
+
+    static class SourceOffsetComparator implements Comparator<IType> {
+
+        /**
+         * First source occurrence win.
+         * @param o1 should be IType
+         * @param o2 should be IType
+         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+         */
+        @Override
+        public int compare(IType o1, IType o2) {
+            IType m1 = o1;
+            IType m2 = o2;
+            int idx1, idx2;
+            try {
+                ISourceRange sr1 = m1.getSourceRange();
+                ISourceRange sr2 = m2.getSourceRange();
+                if (sr1 == null || sr2 == null) {
+                    return 0;
+                }
+                idx1 = sr1.getOffset();
+                idx2 = sr2.getOffset();
+            } catch (JavaModelException e) {
+                BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+                return 0;
+            }
+            return idx1 - idx2;
+        }
+    }
+
+    static class AnonymClassComparator implements Comparator<IJavaElement> {
+
+        private final IType topAncestorType;
+        private final SourceOffsetComparator sourceComparator;
+        private final boolean is50OrHigher;
+        private final Map<IType, Integer> map;
+
+        /**
+         * @param javaElement
+         * @param sourceComparator
+         */
+        public AnonymClassComparator(IType javaElement,
+            SourceOffsetComparator sourceComparator) {
+            this.sourceComparator = sourceComparator;
+            is50OrHigher = is50OrHigher(javaElement);
+            topAncestorType = (IType) getLastAncestor(javaElement, IJavaElement.TYPE);
+            map = new IdentityHashMap<>();
+        }
+
+        /**
+         * Very simple comparision based on init/not init block decision and then on the
+         * source code position
+         */
+        private int compare50(IType m1, IType m2){
+
+            IJavaElement firstAncestor1 = getFirstAncestor(m1);
+            IJavaElement firstAncestor2 = getFirstAncestor(m2);
+
+            int compilePrio1 = getCompilePrio(m1, firstAncestor1);
+            int compilePrio2 = getCompilePrio(m2, firstAncestor2);
+
+            if (compilePrio1 > compilePrio2) {
+                return -1;
+            } else if (compilePrio1 < compilePrio2) {
+                return 1;
+            } else {
+                return sourceComparator.compare(m1, m2);
+            }
+        }
+
+        /**
+         * If "deep" is the same, then source order win. 1) from instance init 2) from
+         * deepest inner from instance init (deepest first) 3) from static init 4) from
+         * deepest inner from static init (deepest first) 5) from deepest inner (deepest
+         * first) 7) regular anon classes from main class
+         *
+         * <br>
+         * Note, that nested inner anon. classes which do not have different
+         * non-anon. inner class ancestors, are compiled in they nesting order, opposite
+         * to rule 2)
+         *
+         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
+         */
+        @Override
+        public int compare(IJavaElement o1, IJavaElement o2) {
+            if(o1 == o2){
+                return 0;
+            }
+            IType m1 = (IType) o1;
+            IType m2 = (IType) o2;
+            if(is50OrHigher){
+                return compare50(m1, m2);
+            }
+
+            IJavaElement firstAncestor1 = getFirstAncestor(m1);
+            IJavaElement firstAncestor2 = getFirstAncestor(m2);
+
+            int compilePrio1 = getCompilePrio(m1, firstAncestor1);
+            int compilePrio2 = getCompilePrio(m2, firstAncestor2);
+
+            if (compilePrio1 > compilePrio2) {
+                return -1;
+            } else if (compilePrio1 < compilePrio2) {
+                return 1;
+            } else {
+                firstAncestor1 = getFirstNonAnonymous(m1, topAncestorType);
+                firstAncestor2 = getFirstNonAnonymous(m2, topAncestorType);
+
+                if(firstAncestor1 == firstAncestor2){
+                    if(isLocal(firstAncestor1)){
+                        // we have to sort init blocks in local classes before other local class methods
+                        // search for initializer block
+                        boolean fromInitBlock1 = isFromInitBlock(m1);
+                        boolean fromInitBlock2 = isFromInitBlock(m2);
+                        if(fromInitBlock1 ^ fromInitBlock2){
+                            return fromInitBlock1? -1 : 1;
+                        }
+                    }
+                    return sourceComparator.compare(m1, m2);
+                }
+
+                boolean isLocal = isLocal(firstAncestor1) || isLocal(firstAncestor2);
+                if(isLocal){
+                    return sourceComparator.compare(m1, m2);
+                }
+
+                /*
+                 * for anonymous classes which have first non-common non-anonymous ancestor,
+                 * the order is the reversed definition order
+                 */
+                int topAncestorDistance1 = getTopAncestorDistance(
+                    firstAncestor1, topAncestorType);
+                int topAncestorDistance2 = getTopAncestorDistance(
+                    firstAncestor2, topAncestorType);
+                if (topAncestorDistance1 > topAncestorDistance2) {
+                    return -1;
+                } else if (topAncestorDistance1 < topAncestorDistance2) {
+                    return 1;
+                } else {
+                    return sourceComparator.compare(m1, m2);
+                }
+            }
+        }
+
+        private int getCompilePrio(IType anonType, IJavaElement firstAncestor) {
+            int compilePrio;
+            Integer prio;
+            if ((prio = map.get(anonType)) != null) {
+                compilePrio = prio.intValue();
+                if (BytecodeOutlinePlugin.DEBUG) {
+                    System.out.println("Using cache");
+                }
+            } else {
+                compilePrio = getAnonCompilePriority(
+                    anonType, firstAncestor, topAncestorType, is50OrHigher);
+                map.put(anonType, Integer.valueOf(compilePrio));
+                if (BytecodeOutlinePlugin.DEBUG) {
+                    System.out.println("Calculating value!");
+                }
+            }
+            return compilePrio;
+        }
+    }
+
+    /**
+     * Finds a type by the simple name.
+     * see org.eclipse.jdt.internal.corext.codemanipulation.AddImportsOperation
+     * @return null, if no types was found, empty array if more then one type was found,
+     * or only one element, if single match exists
+     */
+    public static IType[] getTypeForName(String simpleTypeName,
+        final IJavaSearchScope searchScope, IProgressMonitor monitor)
+            throws JavaModelException {
+        final List<IType> result = new ArrayList<>();
+        final TypeFactory fFactory = new TypeFactory();
+        TypeNameRequestor requestor = new TypeNameRequestor() {
+            @Override
+            public void acceptType(int modifiers, char[] packageName,
+                char[] simpleTypeName1, char[][] enclosingTypeNames, String path) {
+                IType type = fFactory.create(packageName, simpleTypeName1,
+                    enclosingTypeNames, modifiers, path, searchScope);
+                if (type != null) {
+                    result.add(type);
+                }
+            }
+        };
+        int matchRule = SearchPattern.R_EXACT_MATCH | SearchPattern.R_CASE_SENSITIVE;
+        new SearchEngine().searchAllTypeNames(
+            null, matchRule,
+            simpleTypeName.toCharArray(), matchRule,
+            IJavaSearchConstants.TYPE, searchScope, requestor,
+            IJavaSearchConstants.WAIT_UNTIL_READY_TO_SEARCH, monitor);
+
+        return result.toArray(new IType[result.size()]);
+    }
+
+    /**
+     * Selects the openable elements out of the given ones.
+     *
+     * @param elements the elements to filter
+     * @return the openable elements
+     */
+    public static IJavaElement[] selectOpenableElements(IJavaElement[] elements) {
+        List<IJavaElement> result= new ArrayList<>(elements.length);
+        for (int i= 0; i < elements.length; i++) {
+            IJavaElement element= elements[i];
+            if(element == null) {
+                continue;
+            }
+            switch (element.getElementType()) {
+                case IJavaElement.PACKAGE_DECLARATION:
+                case IJavaElement.PACKAGE_FRAGMENT:
+                case IJavaElement.PACKAGE_FRAGMENT_ROOT:
+                case IJavaElement.JAVA_PROJECT:
+                case IJavaElement.JAVA_MODEL:
+                    break;
+                default:
+                    result.add(element);
+                    break;
+            }
+        }
+        return result.toArray(new IJavaElement[result.size()]);
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/TypeFactory.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/TypeFactory.java
new file mode 100644
index 0000000..cbb5880
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/TypeFactory.java
@@ -0,0 +1,391 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui;
+
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.List;
+
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.IWorkspaceRoot;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.core.runtime.Path;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IJavaModel;
+import org.eclipse.jdt.core.IJavaProject;
+import org.eclipse.jdt.core.IOrdinaryClassFile;
+import org.eclipse.jdt.core.IPackageFragment;
+import org.eclipse.jdt.core.IPackageFragmentRoot;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+
+/**
+ * Replacement for TypeInfoFactory which is internal in 3.2 and removed or partly not
+ * more accessible in 3.3. The class contains a limited features subset from original one
+ */
+public class TypeFactory {
+    static final char SEPARATOR = '/';
+
+    static final char EXTENSION_SEPARATOR = '.';
+
+    static final char PACKAGE_PART_SEPARATOR = '.';
+
+    private final String[] fProjects;
+
+    private char[][] enclosingNames;
+
+    private String simpleTypeName;
+
+    public TypeFactory() {
+        super();
+        fProjects = getProjectList();
+    }
+
+    private IType getType(IJavaSearchScope searchScope, IJavaElement container) {
+        try {
+            if (container instanceof ICompilationUnit) {
+                return findTypeInCompilationUnit((ICompilationUnit) container,
+                        getTypeQualifiedName());
+            } else if (container instanceof IOrdinaryClassFile) {
+                return ((IOrdinaryClassFile) container).getType();
+            }
+            return null;
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.error("getType() fails for: " + simpleTypeName, e);
+        }
+        return null;
+    }
+
+    public String getTypeQualifiedName() {
+        if (enclosingNames != null && enclosingNames.length > 0) {
+            StringBuffer buf = new StringBuffer();
+            for (int i = 0; i < enclosingNames.length; i++) {
+                buf.append(enclosingNames[i]);
+                buf.append('.');
+            }
+            buf.append(simpleTypeName);
+            return buf.toString();
+        }
+        return simpleTypeName;
+    }
+
+    /**
+     * Will be called at most two times if the return value was not null.
+     * @param searchScope
+     * return any non-null value.
+     */
+    public IType create(char[] packageName, char[] simpleTypeName1,
+            char[][] enclosingName, int modifiers, String path,
+            IJavaSearchScope searchScope) {
+        this.enclosingNames = enclosingName;
+        this.simpleTypeName = new String(simpleTypeName1);
+        String pn = new String(packageName);
+
+        int index = path.indexOf(IJavaSearchScope.JAR_FILE_ENTRY_SEPARATOR);
+        IType result = null;
+        if (index != -1) {
+            result = createJarFileEntryTypeInfo(pn, simpleTypeName, enclosingName,
+                    modifiers, path, index, searchScope);
+        } else {
+            String project = getProject(path);
+            if (project != null) {
+                result = createIFileTypeInfo(pn, simpleTypeName, enclosingName,
+                        modifiers, path, project, searchScope);
+            }
+        }
+        return result;
+    }
+
+    private IType createIFileTypeInfo(String packageName, String typeName,
+            char[][] enclosingName, int modifiers, String path, String project,
+            IJavaSearchScope searchScope) {
+        String rest = path.substring(project.length() + 1); // the first slashes.
+        int index = rest.lastIndexOf(SEPARATOR);
+        if (index == -1) {
+            return null;
+        }
+        String middle = rest.substring(0, index);
+        rest = rest.substring(index + 1);
+        index = rest.lastIndexOf(EXTENSION_SEPARATOR);
+        String file = null;
+        String extension = null;
+        if (index != -1) {
+            file = rest.substring(0, index);
+            extension = rest.substring(index + 1);
+        } else {
+            return null;
+        }
+        String src = null;
+        int ml = middle.length();
+        int pl = packageName.length();
+        // if we have a source or package then we have to substract the leading '/'
+        if (ml > 0 && ml - 1 > pl) {
+            // If we have a package then we have to substract the '/' between src and package
+            src = middle.substring(1, ml - pl - (pl > 0 ? 1 : 0));
+        }
+
+        if (typeName.equals(file)) {
+            file = typeName;
+        }
+
+        IFileTypeInfo fileTypeInfo = new IFileTypeInfo(packageName, typeName,
+                enclosingName, modifiers, project, src, file, extension);
+        IJavaElement container = fileTypeInfo.getContainer(searchScope);
+        return getType(searchScope, container);
+    }
+
+    protected IType createJarFileEntryTypeInfo(String packageName, String typeName,
+            char[][] enclosingName, int modifiers, String path, int index,
+            IJavaSearchScope searchScope) {
+        String jar = path.substring(0, index);
+        String rest = path.substring(index + 1);
+        index = rest.lastIndexOf(SEPARATOR);
+        if (index != -1) {
+            rest = rest.substring(index + 1);
+        }
+        String file = null;
+        String extension = null;
+        index = rest.lastIndexOf(EXTENSION_SEPARATOR);
+        if (index != -1) {
+            file = rest.substring(0, index);
+            extension = rest.substring(index + 1);
+        } else {
+            return null;
+        }
+
+        if (typeName.equals(file)) {
+            file = typeName;
+        }
+        JarFileEntryTypeInfo info = new JarFileEntryTypeInfo(packageName, typeName,
+                enclosingName, modifiers, jar, file, extension);
+        IJavaElement container;
+        try {
+            container = info.getContainer(searchScope);
+            return getType(searchScope, container);
+        } catch (JavaModelException e) {
+            BytecodeOutlinePlugin.error("createJarFileEntryTypeInfo() fails for: " + simpleTypeName, e);
+        }
+        return null;
+    }
+
+    private String getProject(String path) {
+        for (int i = 0; i < fProjects.length; i++) {
+            String project = fProjects[i];
+            if (path.startsWith(project, 1)) {
+                return project;
+            }
+        }
+        return null;
+    }
+
+    private static String[] getProjectList() {
+        IJavaModel model = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot());
+        String[] result;
+        try {
+            IJavaProject[] projects = model.getJavaProjects();
+            result = new String[projects.length];
+            for (int i = 0; i < projects.length; i++) {
+                result[i] = projects[i].getElementName();
+            }
+        } catch (JavaModelException e) {
+            result = new String[0];
+        }
+        // We have to sort the list of project names to make sure that we cut of the longest
+        // project from the path, if two projects with the same prefix exist. For example
+        // org.eclipse.jdt.ui and org.eclipse.jdt.ui.tests.
+        Arrays.sort(result, new Comparator<String>() {
+            @Override
+            public int compare(String o1, String o2) {
+                int l1 = o1.length();
+                int l2 = o2.length();
+                if (l1 < l2) {
+                    return 1;
+                }
+                if (l2 < l1) {
+                    return -1;
+                }
+                return 0;
+            }
+        });
+        return result;
+    }
+
+    /**
+     * Returns the qualified type name of the given type using '.' as separators.
+     * This is a replace for IType.getTypeQualifiedName()
+     * which uses '$' as separators. As '$' is also a valid character in an id
+     * this is ambiguous. JavaCore PR: 1GCFUNT
+     */
+    private static String getTypeQualifiedName(IType type) {
+        try {
+            if (type.isBinary() && !type.isAnonymous()) {
+                IType declaringType = type.getDeclaringType();
+                if (declaringType != null) {
+                    return getTypeQualifiedName(declaringType) + '.'
+                    + type.getElementName();
+                }
+            }
+        } catch (JavaModelException e) {
+            // ignore
+        }
+        return type.getTypeQualifiedName('.');
+    }
+
+    /**
+     * Finds a type in a compilation unit. Typical usage is to find the corresponding
+     * type in a working copy.
+     * @param cu the compilation unit to search in
+     * @param typeQualifiedName the type qualified name (type name with enclosing type names (separated by dots))
+     * @return the type found, or null if not existing
+     */
+    private static IType findTypeInCompilationUnit(ICompilationUnit cu,
+            String typeQualifiedName) throws JavaModelException {
+        IType[] types = cu.getAllTypes();
+        for (int i = 0; i < types.length; i++) {
+            String currName = getTypeQualifiedName(types[i]);
+            if (typeQualifiedName.equals(currName)) {
+                return types[i];
+            }
+        }
+        return null;
+    }
+
+    private static final class JarFileEntryTypeInfo {
+
+        private final String fJar;
+
+        private final String fFileName;
+
+        private final String fExtension;
+
+        private final String pkg;
+
+        public JarFileEntryTypeInfo(String pkg, String name, char[][] enclosingTypes,
+                int modifiers, String jar, String fileName, String extension) {
+
+            this.pkg = pkg;
+            fJar = jar;
+            fFileName = fileName;
+            fExtension = extension;
+        }
+
+        private IJavaElement getContainer(IJavaSearchScope scope)
+        throws JavaModelException {
+            IJavaModel jmodel = JavaCore.create(ResourcesPlugin.getWorkspace().getRoot());
+            IPath[] enclosedPaths = scope.enclosingProjectsAndJars();
+
+            for (int i = 0; i < enclosedPaths.length; i++) {
+                IPath curr = enclosedPaths[i];
+                if (curr.segmentCount() == 1) {
+                    IJavaProject jproject = jmodel.getJavaProject(curr.segment(0));
+                    IPackageFragmentRoot root = jproject.getPackageFragmentRoot(fJar);
+                    if (root.exists()) {
+                        return findElementInRoot(root);
+                    }
+                }
+            }
+            List<IPath> paths = Arrays.asList(enclosedPaths);
+            IJavaProject[] projects = jmodel.getJavaProjects();
+            for (int i = 0; i < projects.length; i++) {
+                IJavaProject jproject = projects[i];
+                if (!paths.contains(jproject.getPath())) {
+                    IPackageFragmentRoot root = jproject.getPackageFragmentRoot(fJar);
+                    if (root.exists()) {
+                        return findElementInRoot(root);
+                    }
+                }
+            }
+            return null;
+        }
+
+        private IJavaElement findElementInRoot(IPackageFragmentRoot root) {
+            IJavaElement res;
+            IPackageFragment frag = root.getPackageFragment(pkg);
+            String extension = fExtension;
+            String fullName = fFileName + '.' + extension;
+
+            if ("class".equals(extension)) {
+                res = frag.getClassFile(fullName);
+            } else if (JavaCore.isJavaLikeFileName(fullName)) {
+                res = frag.getCompilationUnit(fullName);
+            } else {
+                return null;
+            }
+            if (res.exists()) {
+                return res;
+            }
+            return null;
+        }
+    }
+
+    private static final class IFileTypeInfo {
+
+        private final String fProject;
+
+        private final String fFolder;
+
+        private final String fFile;
+
+        private final String fExtension;
+
+        private final String pkg;
+
+        public IFileTypeInfo(String pkg, String name, char[][] enclosingTypes,
+                int modifiers, String project, String sourceFolder, String file,
+                String extension) {
+            this.pkg = pkg;
+            fProject = project;
+            fFolder = sourceFolder;
+            fFile = file;
+            fExtension = extension;
+        }
+
+        private IJavaElement getContainer(IJavaSearchScope scope) {
+            IWorkspaceRoot root = ResourcesPlugin.getWorkspace().getRoot();
+            IPath path = new Path(getPath());
+            IResource resource = root.findMember(path);
+            if (resource != null) {
+                IJavaElement elem = JavaCore.create(resource);
+                if (elem != null && elem.exists()) {
+                    return elem;
+                }
+            }
+            return null;
+        }
+
+        private String getPath() {
+            StringBuffer result = new StringBuffer();
+            result.append(SEPARATOR);
+            result.append(fProject);
+            result.append(SEPARATOR);
+            if (fFolder != null && fFolder.length() > 0) {
+                result.append(fFolder);
+                result.append(SEPARATOR);
+            }
+            if (pkg != null && pkg.length() > 0) {
+                result.append(pkg.replace(PACKAGE_PART_SEPARATOR, SEPARATOR));
+                result.append(SEPARATOR);
+            }
+            result.append(fFile);
+            result.append('.');
+            result.append(fExtension);
+            return result.toString();
+        }
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/BytecodeAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/BytecodeAction.java
new file mode 100644
index 0000000..dcd0baa
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/BytecodeAction.java
@@ -0,0 +1,144 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Iterator;
+
+import org.eclipse.compare.CompareUI;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.runtime.IAdaptable;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.compare.BytecodeCompare;
+import org.eclipse.jdt.bcoview.compare.TypedElement;
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.eclipse.jdt.bcoview.ui.JdtUtils;
+import org.eclipse.jdt.core.IClassFile;
+import org.eclipse.jdt.core.ICompilationUnit;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.IObjectActionDelegate;
+import org.eclipse.ui.IWorkbenchPart;
+
+public abstract class BytecodeAction implements IObjectActionDelegate {
+    protected IStructuredSelection selection;
+    protected Shell shell;
+
+    @Override
+    public void selectionChanged(IAction action, ISelection newSelection) {
+        if (newSelection instanceof IStructuredSelection) {
+            this.selection = (IStructuredSelection) newSelection;
+        }
+    }
+
+    @Override
+    public void setActivePart(IAction action, IWorkbenchPart targetPart) {
+        this.shell = targetPart.getSite().getShell();
+    }
+
+    protected void exec(IJavaElement element1, IJavaElement element2) throws Exception {
+        final BitSet modes = getModes();
+        CompareUI.openCompareEditor(new BytecodeCompare(
+            createTypedElement(element1, modes),
+            createTypedElement(element2, modes)));
+    }
+
+    protected TypedElement createTypedElement(IJavaElement javaElement, BitSet modes) {
+        String name;
+        IClassFile classFile = (IClassFile) javaElement
+            .getAncestor(IJavaElement.CLASS_FILE);
+        // existing read-only class files
+        if (classFile != null) {
+            name = classFile.getPath().toOSString();
+            if (!name.endsWith(".class")) { //$NON-NLS-1$
+                name += '/' + JdtUtils.getFullBytecodeName(classFile);
+            }
+        } else {
+            // usual eclipse - generated bytecode
+            name = JdtUtils.getByteCodePath(javaElement);
+        }
+        String methodName = null;
+        if(javaElement.getElementType() == IJavaElement.METHOD ||
+            javaElement.getElementType() == IJavaElement.INITIALIZER){
+            methodName = JdtUtils.getMethodSignature(javaElement);
+            if(methodName != null){
+                name += ":" + methodName;
+            }
+        }
+        return new TypedElement(name, methodName, TypedElement.TYPE_BYTECODE, javaElement, modes);
+    }
+
+    private static BitSet getModes() {
+        IPreferenceStore store = BytecodeOutlinePlugin.getDefault().getPreferenceStore();
+        BitSet modes = new BitSet();
+        modes.set(BCOConstants.F_LINK_VIEW_TO_EDITOR, store.getBoolean(BCOConstants.LINK_VIEW_TO_EDITOR));
+        modes.set(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT, store.getBoolean(BCOConstants.SHOW_ONLY_SELECTED_ELEMENT));
+        modes.set(BCOConstants.F_SHOW_RAW_BYTECODE, store.getBoolean(BCOConstants.SHOW_RAW_BYTECODE));
+        modes.set(BCOConstants.F_SHOW_LINE_INFO, store.getBoolean(BCOConstants.DIFF_SHOW_LINE_INFO));
+        modes.set(BCOConstants.F_SHOW_VARIABLES, store.getBoolean(BCOConstants.DIFF_SHOW_VARIABLES));
+        modes.set(BCOConstants.F_SHOW_ASMIFIER_CODE, store.getBoolean(BCOConstants.DIFF_SHOW_ASMIFIER_CODE));
+        modes.set(BCOConstants.F_SHOW_ANALYZER, store.getBoolean(BCOConstants.SHOW_ANALYZER));
+        modes.set(BCOConstants.F_SHOW_STACKMAP, store.getBoolean(BCOConstants.DIFF_SHOW_STACKMAP));
+        modes.set(BCOConstants.F_EXPAND_STACKMAP, store.getBoolean(BCOConstants.DIFF_EXPAND_STACKMAP));
+        return modes;
+    }
+
+    protected IJavaElement[] getSelectedResources() {
+        ArrayList<Object> resources = null;
+        if (!selection.isEmpty()) {
+            resources = new ArrayList<>();
+            for (Iterator<?> elements = selection.iterator(); elements.hasNext();) {
+                Object next = elements.next();
+                if (next instanceof IFile) {
+                    resources.add(JavaCore.create((IFile)next));
+                    continue;
+                } if (next instanceof IJavaElement) {
+                    resources.add(next);
+                    continue;
+                } else if (next instanceof IAdaptable) {
+                    IAdaptable a = (IAdaptable) next;
+                    Object adapter = a.getAdapter(IFile.class);
+                    if (adapter instanceof IFile) {
+                        resources.add(JavaCore.create((IFile)adapter));
+                        continue;
+                    }
+                    adapter = a.getAdapter(ICompilationUnit.class);
+                    if (adapter instanceof ICompilationUnit) {
+                        resources.add(adapter);
+                        continue;
+                    }
+
+                    adapter = a.getAdapter(IClassFile.class);
+                    if (adapter instanceof IClassFile) {
+                        resources.add(adapter);
+                        continue;
+                    }
+                }
+            }
+        }
+
+        if (resources != null && !resources.isEmpty()) {
+            return resources.toArray(new IJavaElement[resources
+                .size()]);
+        }
+
+        return new IJavaElement[0];
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareBytecodeAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareBytecodeAction.java
new file mode 100644
index 0000000..84176cf
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareBytecodeAction.java
@@ -0,0 +1,33 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jface.action.IAction;
+
+public class CompareBytecodeAction extends BytecodeAction {
+
+    @Override
+    public void run(IAction action) {
+        IJavaElement[] resources = getSelectedResources();
+        try {
+            exec(resources[0], resources[1]);
+        } catch (Exception e) {
+            BytecodeOutlinePlugin.error("Failed to run Compare: "
+                + e.getMessage(), e);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareMemberBytecodeAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareMemberBytecodeAction.java
new file mode 100644
index 0000000..5b3b777
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/CompareMemberBytecodeAction.java
@@ -0,0 +1,66 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+
+import org.eclipse.core.runtime.IAdaptable;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IMember;
+import org.eclipse.jface.action.IAction;
+
+public class CompareMemberBytecodeAction extends BytecodeAction {
+
+    @Override
+    public void run(IAction action) {
+        IJavaElement[] resources = getSelectedResources();
+        try {
+            exec(resources[0], resources[1]);
+        } catch (Exception e) {
+            BytecodeOutlinePlugin.error("Failed to run Compare: "
+                + e.getMessage(), e);
+        }
+    }
+
+    @Override
+    protected IJavaElement[] getSelectedResources() {
+        ArrayList<Object> resources = null;
+        if (!selection.isEmpty()) {
+            resources = new ArrayList<>();
+            for (Iterator<?> elements = selection.iterator(); elements.hasNext();) {
+                Object next = elements.next();
+                if (next instanceof IMember) {
+                    resources.add(next);
+                    continue;
+                } else if (next instanceof IAdaptable) {
+                    IAdaptable a = (IAdaptable) next;
+                    Object adapter = a.getAdapter(IMember.class);
+                    if (adapter instanceof IMember) {
+                        resources.add(adapter);
+                        continue;
+                    }
+                }
+            }
+        }
+
+        if (resources != null && !resources.isEmpty()) {
+            return resources.toArray(new IJavaElement[resources
+                .size()]);
+        }
+
+        return new IJavaElement[0];
+    }
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/DefaultToggleAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/DefaultToggleAction.java
new file mode 100644
index 0000000..d7ebe56
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/DefaultToggleAction.java
@@ -0,0 +1,114 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.util.IPropertyChangeListener;
+import org.eclipse.jface.util.PropertyChangeEvent;
+import org.eclipse.ui.plugin.AbstractUIPlugin;
+
+
+/**
+ * Default action which could be used as template for "toggle" action.
+ * Action image, text and tooltip will be initialized by default.
+ * To use it, register IPropertyChangeListener and check for IAction.CHECKED
+ * event name.
+ */
+public abstract class DefaultToggleAction extends Action implements IPropertyChangeListener {
+
+    private static final String ACTION = "action";
+    boolean avoidUpdate;
+    private final IPreferenceStore store;
+
+    public DefaultToggleAction(final String id) {
+        this(id, true);
+    }
+
+    public DefaultToggleAction(final String id, final boolean addPreferenceListener) {
+        super();
+        setId(id);
+        init();
+
+        IPreferenceStore prefStore = BytecodeOutlinePlugin.getDefault().getPreferenceStore();
+
+        boolean isChecked = prefStore.getBoolean(id);
+        setChecked(isChecked);
+        if(addPreferenceListener) {
+            this.store = prefStore;
+            prefStore.addPropertyChangeListener(this);
+        } else {
+            this.store = null;
+        }
+    }
+
+    @Override
+    public void propertyChange(final PropertyChangeEvent event){
+        if(store == null){
+            return;
+        }
+        String id = getId();
+        if(!id.equals(event.getProperty())){
+            return;
+        }
+        boolean isChecked = store.getBoolean(id);
+        setChecked(isChecked);
+        // The action state can be changed from preference page (therefore run()), but...
+        // see http://forge.objectweb.org/tracker/?func=detail&atid=100023&aid=311888&group_id=23
+        // this causes multiple unneeded re-syncs of the compare editor
+        if(!avoidUpdate) {
+            run(isChecked);
+        }
+    }
+
+    public void dispose(){
+        if(store != null) {
+            store.removePropertyChangeListener(this);
+        }
+    }
+
+    private void init(){
+        String myId = getId();
+        if(myId != null && myId.startsWith("diff_")) {
+            myId = myId.substring("diff_".length());
+        }
+        setImageDescriptor(AbstractUIPlugin
+            .imageDescriptorFromPlugin(
+                BytecodeOutlinePlugin.getDefault().getBundle()
+                    .getSymbolicName(),
+                BytecodeOutlinePlugin
+                    .getResourceString(ACTION + "." + myId + "." + IMAGE)));
+
+        setText(BytecodeOutlinePlugin
+            .getResourceString(ACTION + "." + myId + "." + TEXT));
+        setToolTipText(BytecodeOutlinePlugin
+            .getResourceString(ACTION + "." + myId + "." + TOOL_TIP_TEXT));
+    }
+
+    /**
+     * @see org.eclipse.jface.action.IAction#run()
+     */
+    @Override
+    public final void run() {
+        boolean isChecked = isChecked();
+        avoidUpdate = true;
+        // compare dialog: we use store as global variables to remember the state
+        BytecodeOutlinePlugin.getDefault().getPreferenceStore().setValue(getId(), isChecked);
+        avoidUpdate = false;
+        run(isChecked);
+    }
+
+    public abstract void run(boolean newState);
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenAction.java
new file mode 100644
index 0000000..23f13ff
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenAction.java
@@ -0,0 +1,100 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import org.eclipse.core.resources.IContainer;
+import org.eclipse.core.resources.IFile;
+import org.eclipse.core.resources.IResource;
+import org.eclipse.core.resources.ResourcesPlugin;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.JavaCore;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.dialogs.IDialogConstants;
+import org.eclipse.swt.widgets.Shell;
+import org.eclipse.ui.dialogs.ResourceListSelectionDialog;
+
+public class OpenAction extends BytecodeAction {
+
+    @Override
+    public void run(IAction action) {
+        // always only one element!
+        IJavaElement[] resources = getSelectedResources();
+
+        // select one from input dialog
+        IJavaElement element2 = selectJavaElement();
+        if (element2 == null) {
+            return;
+        }
+        try {
+            exec(resources[0], element2);
+        } catch (Exception e) {
+            BytecodeOutlinePlugin.error("Failed to run Compare: "
+                + e.getMessage(), e);
+        }
+    }
+
+    private IJavaElement selectJavaElement() {
+        IContainer input = ResourcesPlugin.getWorkspace().getRoot();
+
+        OpenClassFileDialog dialog = new OpenClassFileDialog(
+            shell, input, IResource.FILE);
+
+        int resultCode = dialog.open();
+        if (resultCode != IDialogConstants.OK_ID) {
+            return null;
+        }
+
+        Object[] result = dialog.getResult();
+        if (result == null || result.length == 0
+            || !(result[0] instanceof IFile)) {
+            return null;
+        }
+        return JavaCore.create((IFile) result[0]);
+    }
+
+    /**
+     * @author Andrei
+     */
+    private static final class OpenClassFileDialog extends ResourceListSelectionDialog {
+
+        /**
+         * @param parentShell
+         * @param container
+         * @param typesMask
+         */
+        public OpenClassFileDialog(Shell parentShell, IContainer container,
+            int typesMask) {
+            super(parentShell, container, typesMask);
+            setTitle("Bytecode compare");
+            setMessage("Please select class file to compare");
+        }
+
+        /**
+         * Extends the super's filter to exclude derived resources.
+         * @since 3.0
+         */
+        @Override
+        protected boolean select(IResource resource) {
+            if (resource == null) {
+                return false;
+            }
+            String fileExtension = resource.getFileExtension();
+            return super.select(resource)
+                && ("java".equals(fileExtension) || "class"
+                    .equals(fileExtension));
+        }
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenBytecodeReferenceAction.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenBytecodeReferenceAction.java
new file mode 100644
index 0000000..7700e32
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/ui/actions/OpenBytecodeReferenceAction.java
@@ -0,0 +1,65 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.ui.actions;
+
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.ui.IViewActionDelegate;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.PlatformUI;
+
+/**
+ * Opens a bytecode reference from view
+ */
+public class OpenBytecodeReferenceAction implements IViewActionDelegate {
+
+    public OpenBytecodeReferenceAction() {
+        super();
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see org.eclipse.ui.IActionDelegate#run(org.eclipse.jface.action.IAction)
+     */
+    @Override
+    public void run(IAction action) {
+        try {
+            PlatformUI.getWorkbench().getActiveWorkbenchWindow()
+                .getActivePage().showView(
+                    "org.eclipse.jdt.bcoview.views.BytecodeReferenceView");
+        } catch (PartInitException e) {
+            BytecodeOutlinePlugin.error(
+                "Could not open Bytecode Reference View: " + e.getMessage(), e);
+        }
+
+    }
+
+    /*
+     * (non-Javadoc)
+     * @see org.eclipse.ui.IActionDelegate#selectionChanged(org.eclipse.jface.action.IAction,
+     * org.eclipse.jface.viewers.ISelection)
+     */
+    @Override
+    public void selectionChanged(IAction action, ISelection selection) {
+        // no op
+    }
+
+    @Override
+    public void init(IViewPart view) {
+        // no op
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BCOViewSelectionProvider.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BCOViewSelectionProvider.java
new file mode 100644
index 0000000..19f8e9c
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BCOViewSelectionProvider.java
@@ -0,0 +1,111 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jface.viewers.IPostSelectionProvider;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+
+/**
+ * Adapter for different selection provider in one view - text control and table control.
+ *  See <a href="http://forge.objectweb.org/tracker/?func=detail&atid=100023&aid=304424&group_id=23">bug 304424</a>
+ *  The main problem is, that
+ *  <pre>
+ *  getSite().setSelectionProvider(viewSelectionProvider);
+ *  </pre>
+ *  could be set only once per view, so that we cannot switch existing
+ *  selection provider on the fly (or I have no idea how to do this simplier way).
+ */
+class BCOViewSelectionProvider implements IPostSelectionProvider {
+
+    private IPostSelectionProvider realProvider;
+    private final List<IPostSelectionProvider> selProviders;
+    private ISelection selection;
+
+    public BCOViewSelectionProvider(){
+        super();
+        selProviders = new ArrayList<>();
+    }
+
+    public void setCurrentSelectionProvider(IPostSelectionProvider provider){
+        if(!selProviders.contains(provider)){
+            BytecodeOutlinePlugin.log(
+                new Exception(
+                    "Current selection provider is not registered yet"),
+                IStatus.WARNING);
+            return;
+        }
+        realProvider = provider;
+        if(selection != null) {
+            realProvider.setSelection(selection);
+        }
+    }
+
+    public void registerSelectionProvider(IPostSelectionProvider provider) {
+        if(!selProviders.contains(provider)){
+            selProviders.add(provider);
+        }
+    }
+
+    @Override
+    public void addPostSelectionChangedListener(ISelectionChangedListener listener) {
+        for (int i = 0; i < selProviders.size(); i++) {
+            IPostSelectionProvider provider = selProviders.get(i);
+            provider.addPostSelectionChangedListener(listener);
+        }
+    }
+
+    @Override
+    public void removePostSelectionChangedListener(ISelectionChangedListener listener) {
+        for (int i = 0; i < selProviders.size(); i++) {
+            IPostSelectionProvider provider = selProviders.get(i);
+            provider.removePostSelectionChangedListener(listener);
+        }
+    }
+
+    @Override
+    public void addSelectionChangedListener(ISelectionChangedListener listener) {
+        for (int i = 0; i < selProviders.size(); i++) {
+            IPostSelectionProvider provider = selProviders.get(i);
+            provider.addSelectionChangedListener(listener);
+        }
+    }
+
+    @Override
+    public ISelection getSelection() {
+        return realProvider != null? realProvider.getSelection() : null;
+    }
+
+    @Override
+    public void removeSelectionChangedListener(ISelectionChangedListener listener) {
+        for (int i = 0; i < selProviders.size(); i++) {
+            IPostSelectionProvider provider = selProviders.get(i);
+            provider.removeSelectionChangedListener(listener);
+        }
+    }
+
+    @Override
+    public void setSelection(ISelection selection) {
+        this.selection = selection;
+        if(realProvider != null) {
+            realProvider.setSelection(selection);
+        }
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeOutlineView.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeOutlineView.java
new file mode 100644
index 0000000..b9c64ad
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeOutlineView.java
@@ -0,0 +1,1967 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.ResourceBundle;
+import java.util.Set;
+
+import org.eclipse.core.filebuffers.FileBuffers;
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.asm.DecompiledClass;
+import org.eclipse.jdt.bcoview.asm.DecompiledMethod;
+import org.eclipse.jdt.bcoview.asm.DecompilerHelper;
+import org.eclipse.jdt.bcoview.asm.DecompilerOptions;
+import org.eclipse.jdt.bcoview.asm.LineRange;
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.eclipse.jdt.bcoview.ui.EclipseUtils;
+import org.eclipse.jdt.bcoview.ui.JdtUtils;
+import org.eclipse.jdt.bcoview.ui.actions.DefaultToggleAction;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jdt.core.IType;
+import org.eclipse.jdt.core.JavaModelException;
+import org.eclipse.jdt.core.search.IJavaSearchScope;
+import org.eclipse.jdt.core.search.SearchEngine;
+import org.eclipse.jdt.internal.ui.JavaPlugin;
+import org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlink;
+import org.eclipse.jdt.internal.ui.javaeditor.JavaElementHyperlinkDetector;
+import org.eclipse.jdt.internal.ui.javaeditor.JavaSourceViewer;
+import org.eclipse.jdt.internal.ui.text.JavaWordFinder;
+import org.eclipse.jdt.internal.ui.text.java.hover.JavadocBrowserInformationControlInput;
+import org.eclipse.jdt.internal.ui.text.java.hover.JavadocHover;
+import org.eclipse.jdt.ui.actions.OpenAction;
+import org.eclipse.jdt.ui.actions.SelectionDispatchAction;
+import org.eclipse.jdt.ui.text.IColorManager;
+import org.eclipse.jdt.ui.text.IJavaPartitions;
+import org.eclipse.jdt.ui.text.JavaSourceViewerConfiguration;
+import org.eclipse.jdt.ui.text.JavaTextTools;
+import org.eclipse.jface.action.Action;
+import org.eclipse.jface.action.IAction;
+import org.eclipse.jface.action.IMenuListener;
+import org.eclipse.jface.action.IMenuManager;
+import org.eclipse.jface.action.IToolBarManager;
+import org.eclipse.jface.action.MenuManager;
+import org.eclipse.jface.action.Separator;
+import org.eclipse.jface.action.StatusLineManager;
+import org.eclipse.jface.preference.IPreferenceStore;
+import org.eclipse.jface.text.BadLocationException;
+import org.eclipse.jface.text.Document;
+import org.eclipse.jface.text.IDocument;
+import org.eclipse.jface.text.IFindReplaceTarget;
+import org.eclipse.jface.text.IRegion;
+import org.eclipse.jface.text.ITextHover;
+import org.eclipse.jface.text.ITextListener;
+import org.eclipse.jface.text.ITextOperationTarget;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.text.ITextViewer;
+import org.eclipse.jface.text.TextEvent;
+import org.eclipse.jface.text.TextViewer;
+import org.eclipse.jface.text.hyperlink.IHyperlink;
+import org.eclipse.jface.text.hyperlink.IHyperlinkDetector;
+import org.eclipse.jface.text.quickassist.IQuickAssistAssistant;
+import org.eclipse.jface.text.source.ISourceViewer;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.ISelectionChangedListener;
+import org.eclipse.jface.viewers.SelectionChangedEvent;
+import org.eclipse.jface.viewers.TableViewer;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.custom.SashForm;
+import org.eclipse.swt.custom.StackLayout;
+import org.eclipse.swt.custom.StyledText;
+import org.eclipse.swt.events.ControlEvent;
+import org.eclipse.swt.events.ControlListener;
+import org.eclipse.swt.events.KeyEvent;
+import org.eclipse.swt.events.KeyListener;
+import org.eclipse.swt.events.MouseAdapter;
+import org.eclipse.swt.events.MouseEvent;
+import org.eclipse.swt.events.SelectionAdapter;
+import org.eclipse.swt.events.SelectionEvent;
+import org.eclipse.swt.graphics.Color;
+import org.eclipse.swt.graphics.Point;
+import org.eclipse.swt.layout.GridData;
+import org.eclipse.swt.layout.GridLayout;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.swt.widgets.Control;
+import org.eclipse.swt.widgets.Menu;
+import org.eclipse.swt.widgets.Table;
+import org.eclipse.swt.widgets.TableColumn;
+import org.eclipse.swt.widgets.TableItem;
+import org.eclipse.swt.widgets.Widget;
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IEditorPart;
+import org.eclipse.ui.IEditorReference;
+import org.eclipse.ui.ISelectionService;
+import org.eclipse.ui.ISharedImages;
+import org.eclipse.ui.IViewSite;
+import org.eclipse.ui.IWorkbenchActionConstants;
+import org.eclipse.ui.IWorkbenchCommandConstants;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.PlatformUI;
+import org.eclipse.ui.actions.ActionFactory;
+import org.eclipse.ui.console.actions.TextViewerAction;
+import org.eclipse.ui.part.ViewPart;
+import org.eclipse.ui.plugin.AbstractUIPlugin;
+import org.eclipse.ui.texteditor.FindReplaceAction;
+import org.eclipse.ui.texteditor.ITextEditor;
+import org.eclipse.ui.texteditor.IUpdate;
+import org.objectweb.asm.tree.ClassNode;
+import org.objectweb.asm.util.Printer;
+
+/**
+ * This view shows decompiled java bytecode
+ */
+public class BytecodeOutlineView extends ViewPart implements IBytecodePart {
+
+    // orientations
+    static final int VIEW_ORIENTATION_VERTICAL = 0;
+    static final int VIEW_ORIENTATION_HORIZONTAL = 1;
+    static final int VIEW_ORIENTATION_AUTOMATIC = 2;
+
+    /**
+     * The current orientation; either <code>VIEW_ORIENTATION_HORIZONTAL</code>
+     * <code>VIEW_ORIENTATION_VERTICAL</code>,
+     * or <code>VIEW_ORIENTATION_AUTOMATIC</code>.
+     */
+    int orientation = VIEW_ORIENTATION_AUTOMATIC;
+    /**
+     * The current orientation; either <code>VIEW_ORIENTATION_HORIZONTAL</code>
+     * <code>VIEW_ORIENTATION_VERTICAL</code>.
+     */
+    private int currentOrientation;
+
+    protected ToggleOrientationAction[] toggleOrientationActions;
+
+    protected BitSet modes;
+
+    protected boolean inputChanged;
+    protected boolean bufferIsDirty;
+
+    private boolean isEnabled;
+    private boolean isActive;
+    private boolean isVisible;
+
+    protected Composite stackComposite;
+    protected StyledText textControl;
+    protected JavaSourceViewer textViewer;
+    protected SashForm verifyControl;
+    protected SashForm stackAndLvt;
+    protected Table tableControl;
+    protected TableViewer tableControlViewer;
+    protected Table stackTable;
+    protected Table lvtTable;
+
+    protected ITextEditor javaEditor;
+    private IJavaElement javaInput;
+    protected IJavaElement lastChildElement;
+    protected ITextSelection currentSelection;
+    protected EditorListener editorListener;
+    protected Action selectionChangedAction;
+    protected Action refreshVarsAndStackAction;
+    protected DefaultToggleAction linkWithEditorAction;
+    protected DefaultToggleAction showSelectedOnlyAction;
+    protected DefaultToggleAction setRawModeAction;
+    protected DefaultToggleAction toggleASMifierModeAction;
+    protected DefaultToggleAction hideLineInfoAction;
+    protected DefaultToggleAction hideLocalsAction;
+    protected DefaultToggleAction hideStackMapAction;
+    protected DefaultToggleAction showHexValuesAction;
+    protected DefaultToggleAction expandStackMapAction;
+    protected DefaultToggleAction toggleVerifierAction;
+    protected StatusLineManager statusLineManager;
+    protected BCOViewSelectionProvider viewSelectionProvider;
+
+    protected Color errorColor;
+
+    private DecompiledClass lastDecompiledResult;
+
+    protected Map<String, IAction> globalActions;
+    protected List<String> selectionActions;
+    private MenuManager contextMenuManager;
+    /** global class info, without current selection status */
+    protected String currentStatusMessage;
+    protected boolean hasAnalyzerError;
+    /*
+     * I don't know how to update the state of toolbar and menu managers because it seems
+     * that if we toggle the action state internally (not by user click) then either the
+     * managers or contribution items or whatever holds the old state of checked action.
+     * This flag is a workaround and allows us restore the state after internal toggling.
+     */
+    private boolean restoreVerify;
+    private static final String NLS_PREFIX = "BytecodeOutlineView.";
+
+    // updates the find replace action if the document length is > 0
+    private ITextListener textListener;
+
+    // see org.eclipse.ui.console.TextConsolePage for the reason to do this ;)
+    private ISelectionChangedListener textSelectionListener;
+    private Control statusControl;
+
+    // ------------------------------------------------------------------------
+
+    protected void setJavaInput(IJavaElement javaInput) {
+        this.javaInput = javaInput;
+        inputChanged = true;
+    }
+
+    /**
+     * The constructor.
+     */
+    public BytecodeOutlineView() {
+        super();
+        modes = new BitSet();
+        globalActions = new HashMap<>();
+        selectionActions = new ArrayList<>();
+    }
+
+    // ------------------------------------------------------------------------
+
+    /**
+     * Is this view state changes depending on editor changes?
+     * @return true if linked with editor
+     */
+    protected boolean isLinkedWithEditor() {
+        return modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR);
+    }
+
+    /**
+     * Are actions on toolbar active?
+     * @return Returns the isEnabled.
+     */
+    private boolean isEnabled() {
+        return isEnabled;
+    }
+
+    private void setEnabled(boolean on) {
+        this.isEnabled = on;
+        if (tableControl != null && !tableControl.isDisposed()) {
+            tableControl.setEnabled(on);
+        }
+        if (stackTable != null && !stackTable.isDisposed()) {
+            stackTable.setEnabled(on);
+        }
+        if (lvtTable != null && !lvtTable.isDisposed()) {
+            lvtTable.setEnabled(on);
+        }
+        showSelectedOnlyAction.setEnabled(on);
+        // linkWithEditorAction.setEnabled(on);
+        selectionChangedAction.setEnabled(on);
+        toggleVerifierAction.setEnabled(on);
+        hideLocalsAction.setEnabled(on);
+        hideLineInfoAction.setEnabled(on);
+        hideStackMapAction.setEnabled(on);
+        showHexValuesAction.setEnabled(on);
+        toggleASMifierModeAction.setEnabled(on);
+        expandStackMapAction.setEnabled(on);
+        setRawModeAction
+            .setEnabled(on && !toggleASMifierModeAction.isChecked());
+        boolean showAnalyzer = on && toggleVerifierAction.isChecked();
+        for (int i = 0; i < toggleOrientationActions.length; ++i) {
+            toggleOrientationActions[i].setEnabled(showAnalyzer);
+        }
+    }
+
+    /**
+     * Is this view monitoring workspace changes?
+     * @return Returns the isActive.
+     */
+    private boolean isActive() {
+        return isActive;
+    }
+
+    /**
+     * @param bufferIsDirty The bufferIsDirty to set.
+     */
+    private void setBufferIsDirty(boolean bufferIsDirty) {
+        this.bufferIsDirty = bufferIsDirty;
+    }
+
+    private void setInput(ITextEditor editor) {
+        javaEditor = null;
+        setJavaInput(null);
+        lastDecompiledResult = null;
+        if (editor != null) {
+            IJavaElement javaElem = EclipseUtils.getJavaInput(editor);
+            if (javaElem == null) {
+                return;
+            }
+            setJavaInput(javaElem);
+            javaEditor = editor;
+
+            checkVerifyMode();
+
+            updateSelection(EclipseUtils.getSelection(javaEditor
+                .getSelectionProvider()));
+            setBufferIsDirty(editor.isDirty());
+        }
+    }
+
+    private void checkVerifyMode() {
+        if(toggleVerifierAction == null){
+            return;
+        }
+        boolean aoi = JdtUtils.isAbstractOrInterface(javaInput);
+
+        if (!toggleVerifierAction.isChecked()) {
+            // deactivate verify button, but only if *not* in verify mode
+            toggleVerifierAction.setEnabled(!aoi);
+            restoreVerify = false;
+        } else {
+            if (aoi) {
+                // swith verify mode off, because it is not applicable to selected element
+                inputChanged = true;
+                toggleVerifyMode(
+                    getViewSite().getActionBars().getMenuManager(), false);
+                // remember last state, to match the state of the toolbars and menus
+                restoreVerify = true;
+            } else {
+                if (restoreVerify) {
+                    inputChanged = true;
+                    toggleVerifierAction.setEnabled(true);
+                    toggleVerifyMode(getViewSite().getActionBars()
+                        .getMenuManager(), true);
+                }
+                restoreVerify = false;
+            }
+        }
+    }
+
+    private boolean updateSelection(ITextSelection sel) {
+        if (sel != null
+            && (sel.equals(currentSelection) || (currentSelection != null
+                && sel.getStartLine() == currentSelection.getStartLine() && sel
+                .getEndLine() == currentSelection.getEndLine()))) {
+
+            /*
+             * getStartLine/getEndLine is probably not sensitive enough - but in case of
+             * java classes/methods which fits in one selection but not in the other, then
+             * I think we can ignore them here - this is not the 99% of use cases.
+             */
+            return false;
+        }
+
+        currentSelection = sel;
+        return true;
+    }
+
+    // ------------------------------------------------------------------------
+
+    /**
+     * @see org.eclipse.ui.IViewPart#init(org.eclipse.ui.IViewSite)
+     */
+    @Override
+    public void init(IViewSite site) {
+        super.setSite(site);
+        if (editorListener == null) {
+            editorListener = new EditorListener(this);
+            getSite().getWorkbenchWindow().getPartService().addPartListener(
+                editorListener);
+        }
+    }
+
+    /**
+     * This is a callback that will allow us to create the viewer and initialize it.
+     * @param parent
+     */
+    @Override
+    public void createPartControl(Composite parent) {
+        errorColor = parent.getDisplay().getSystemColor(SWT.COLOR_RED);
+        parent.addControlListener(new ControlListener() {
+
+            @Override
+            public void controlMoved(ControlEvent e) {
+                //
+            }
+
+            @Override
+            public void controlResized(ControlEvent e) {
+                computeOrientation();
+            }
+        });
+
+        GridLayout parentLayout = new GridLayout();
+        parentLayout.numColumns = 1;
+        parentLayout.marginBottom = -5;
+        parentLayout.marginTop = -5;
+        parentLayout.marginLeft = -5;
+        parentLayout.marginRight = -5;
+
+        parent.setLayout(parentLayout);
+
+        stackComposite = new Composite(parent, SWT.NONE);
+        stackComposite.setLayoutData(new GridData(GridData.FILL_BOTH));
+        stackComposite.setLayout(new StackLayout());
+
+        statusLineManager = new StatusLineManager();
+        statusControl = statusLineManager.createControl(parent, SWT.NONE);
+        statusControl.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
+        IEditorPart activeEditor = EclipseUtils.getActiveEditor();
+        if(activeEditor instanceof ITextEditor) {
+            setInput((ITextEditor) activeEditor);
+        }
+        createTextControl();
+
+        createTextContextMenu();
+
+        createVerifyControl();
+
+        initModes();
+
+        if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            ((StackLayout) stackComposite.getLayout()).topControl = verifyControl;
+        } else {
+            ((StackLayout) stackComposite.getLayout()).topControl = textControl;
+        }
+
+        createSelectionProvider();
+
+        createToolbarActions();
+
+        setEnabled(false);
+
+//        activateView();
+    }
+
+    private void initModes() {
+        IPreferenceStore store = BytecodeOutlinePlugin.getDefault()
+            .getPreferenceStore();
+        modes.set(BCOConstants.F_LINK_VIEW_TO_EDITOR, store
+            .getBoolean(BCOConstants.LINK_VIEW_TO_EDITOR));
+        modes.set(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT, store
+            .getBoolean(BCOConstants.SHOW_ONLY_SELECTED_ELEMENT));
+        modes.set(BCOConstants.F_SHOW_RAW_BYTECODE, store
+            .getBoolean(BCOConstants.SHOW_RAW_BYTECODE));
+        modes.set(BCOConstants.F_SHOW_LINE_INFO, store
+            .getBoolean(BCOConstants.SHOW_LINE_INFO));
+        modes.set(BCOConstants.F_SHOW_VARIABLES, store
+            .getBoolean(BCOConstants.SHOW_VARIABLES));
+        modes.set(BCOConstants.F_SHOW_STACKMAP, store
+            .getBoolean(BCOConstants.SHOW_STACKMAP));
+        modes.set(BCOConstants.F_EXPAND_STACKMAP, store
+            .getBoolean(BCOConstants.EXPAND_STACKMAP));
+        modes.set(BCOConstants.F_SHOW_ASMIFIER_CODE, store
+            .getBoolean(BCOConstants.SHOW_ASMIFIER_CODE));
+        modes.set(BCOConstants.F_SHOW_ANALYZER, store
+            .getBoolean(BCOConstants.SHOW_ANALYZER));
+        modes.set(BCOConstants.F_SHOW_HEX_VALUES, store
+            .getBoolean(BCOConstants.SHOW_HEX_VALUES));
+    }
+
+    private void createToolbarActions() {
+        createTextActions();
+
+        final IActionBars bars = getViewSite().getActionBars();
+        final IToolBarManager tmanager = bars.getToolBarManager();
+        final IMenuManager mmanager = bars.getMenuManager();
+
+        selectionChangedAction = new Action() {
+
+            @Override
+            public void run() {
+                Point selection = textControl.getSelection();
+                setSelectionInJavaEditor(selection);
+            }
+        };
+
+        refreshVarsAndStackAction = new Action() {
+
+            @Override
+            public void run() {
+                int selectionIndex = tableControl.getSelectionIndex();
+                TableItem[] items = tableControl.getSelection();
+                if(items == null || items.length < 1){
+                    return;
+                }
+                String line = items[0].getText(0);
+                if(line == null || "".equals(line)){
+                    return;
+                }
+                Integer valueOf = Integer.valueOf(line);
+                if(valueOf != null){
+                    updateVerifierControl4insn(valueOf.intValue());
+                    tableControl.setSelection(selectionIndex);
+                }
+            }
+        };
+
+        linkWithEditorAction = new DefaultToggleAction(
+            BCOConstants.LINK_VIEW_TO_EDITOR) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_LINK_VIEW_TO_EDITOR, newState);
+                if (modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+                    showSelectedOnlyAction.setEnabled(true);
+                    toggleVerifierAction.setEnabled(true);
+                    hideLineInfoAction.setEnabled(true);
+                    hideLocalsAction.setEnabled(true);
+                    toggleASMifierModeAction.setEnabled(true);
+                    if (!toggleASMifierModeAction.isChecked()) {
+                        setRawModeAction.setEnabled(true);
+                    }
+                    activateView();
+                    checkOpenEditors(true);
+                    inputChanged = true;
+                    refreshView();
+                }
+            }
+        };
+
+        showSelectedOnlyAction = new DefaultToggleAction(
+            BCOConstants.SHOW_ONLY_SELECTED_ELEMENT) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        setRawModeAction = new DefaultToggleAction(
+            BCOConstants.SHOW_RAW_BYTECODE) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_RAW_BYTECODE, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        hideLineInfoAction = new DefaultToggleAction(
+            BCOConstants.SHOW_LINE_INFO) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_LINE_INFO, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        hideLocalsAction = new DefaultToggleAction(BCOConstants.SHOW_VARIABLES) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_VARIABLES, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        hideStackMapAction = new DefaultToggleAction(BCOConstants.SHOW_STACKMAP) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_STACKMAP, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        expandStackMapAction = new DefaultToggleAction(
+            BCOConstants.EXPAND_STACKMAP) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_EXPAND_STACKMAP, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        showHexValuesAction = new DefaultToggleAction(
+            BCOConstants.SHOW_HEX_VALUES) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_HEX_VALUES, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        toggleASMifierModeAction = new DefaultToggleAction(
+            BCOConstants.SHOW_ASMIFIER_CODE) {
+
+            @Override
+            public void run(boolean newState) {
+                setMode(BCOConstants.F_SHOW_ASMIFIER_CODE, newState);
+                if (newState) {
+                    setMode(BCOConstants.F_SHOW_RAW_BYTECODE, true);
+                    setRawModeAction.setEnabled(false);
+                } else {
+                    setRawModeAction.setEnabled(true);
+                }
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        toggleVerifierAction = new DefaultToggleAction(
+            BCOConstants.SHOW_ANALYZER) {
+
+            @Override
+            public void run(boolean newState) {
+                toggleVerifyMode(mmanager, newState);
+                inputChanged = true;
+                refreshView();
+            }
+        };
+
+        mmanager.add(linkWithEditorAction);
+        mmanager.add(showSelectedOnlyAction);
+        mmanager.add(setRawModeAction);
+        mmanager.add(hideLineInfoAction);
+        mmanager.add(hideLocalsAction);
+        mmanager.add(showHexValuesAction);
+        mmanager.add(hideStackMapAction);
+        mmanager.add(expandStackMapAction);
+        mmanager.add(toggleASMifierModeAction);
+        mmanager.add(toggleVerifierAction);
+
+        mmanager.add(new Separator());
+
+        toggleOrientationActions = new ToggleOrientationAction[]{
+            new ToggleOrientationAction(this, VIEW_ORIENTATION_VERTICAL),
+            new ToggleOrientationAction(this, VIEW_ORIENTATION_HORIZONTAL),
+            new ToggleOrientationAction(this, VIEW_ORIENTATION_AUTOMATIC)};
+        for (int i = 0; i < toggleOrientationActions.length; ++i) {
+            mmanager.add(toggleOrientationActions[i]);
+        }
+
+        tmanager.add(linkWithEditorAction);
+        tmanager.add(showSelectedOnlyAction);
+        tmanager.add(setRawModeAction);
+        // tmanager.add(hideLineInfoAction);
+        // tmanager.add(hideLocalsAction);
+        tmanager.add(toggleASMifierModeAction);
+        tmanager.add(toggleVerifierAction);
+    }
+
+    @SuppressWarnings("unused")
+    private void createVerifyControl() {
+        verifyControl = new SashForm(stackComposite, SWT.VERTICAL);
+
+        tableControl = new Table(verifyControl, SWT.SINGLE | SWT.FULL_SELECTION);
+        tableControlViewer = new TableViewer(tableControl);
+
+        TableColumn tc = new TableColumn(tableControl, SWT.LEFT);
+        tc.setText("#");
+        tc.setToolTipText("ASM instruction offset");
+
+        tc = new TableColumn(tableControl, SWT.LEFT);
+        tc.setText(BytecodeOutlinePlugin.getResourceString(NLS_PREFIX + "lvt.header"));
+        tc.setToolTipText("Local variables");
+
+        tc = new TableColumn(tableControl, SWT.LEFT);
+        tc.setText(BytecodeOutlinePlugin.getResourceString(NLS_PREFIX + "stack.header"));
+        tc.setToolTipText("Stack content *before* current instruction is executed");
+        new TableColumn(tableControl, SWT.LEFT);
+        new TableColumn(tableControl, SWT.LEFT);
+        tableControl.setLinesVisible(false);
+        tableControl.setHeaderVisible(true);
+
+        stackAndLvt = new SashForm(verifyControl, SWT.HORIZONTAL);
+
+        lvtTable = new Table(stackAndLvt, SWT.SINGLE | SWT.FULL_SELECTION);
+        lvtTable.setLinesVisible(false);
+        lvtTable.setHeaderVisible(true);
+
+        new TableColumn(lvtTable, SWT.LEFT).setText("#");
+        new TableColumn(lvtTable, SWT.LEFT).setText("Var Type");
+        new TableColumn(lvtTable, SWT.LEFT).setText("Name");
+
+        stackTable = new Table(stackAndLvt, SWT.SINGLE | SWT.FULL_SELECTION);
+        stackTable.setLinesVisible(false);
+        stackTable.setHeaderVisible(true);
+        new TableColumn(stackTable, SWT.LEFT).setText("#");
+        new TableColumn(stackTable, SWT.LEFT).setText("Stack Type");
+
+        stackAndLvt.setWeights(new int[]{50, 50});
+
+        verifyControl.setWeights(new int[]{75, 25});
+
+        tableControl.addSelectionListener(new SelectionAdapter() {
+
+            @Override
+            public void widgetSelected(SelectionEvent e) {
+                if (modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+                    selectionChangedAction.run();
+                }
+                refreshVarsAndStackAction.run();
+            }
+        });
+
+    }
+
+    private void createSelectionProvider() {
+        viewSelectionProvider = new BCOViewSelectionProvider();
+        viewSelectionProvider.registerSelectionProvider(textViewer);
+        viewSelectionProvider.registerSelectionProvider(tableControlViewer);
+
+        if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            viewSelectionProvider.setCurrentSelectionProvider(tableControlViewer);
+        } else {
+            viewSelectionProvider.setCurrentSelectionProvider(textViewer);
+        }
+        getSite().setSelectionProvider(viewSelectionProvider);
+    }
+
+    /**
+     * create/register context menu on text control
+     */
+    private void createTextContextMenu() {
+        String id = "org.eclipse.jdt.bcoview.views.BytecodeOutlineView#ContextMenu"; //$NON-NLS-1$
+        contextMenuManager = new MenuManager("#ContextMenu", id); //$NON-NLS-1$
+        contextMenuManager.setRemoveAllWhenShown(true);
+        contextMenuManager.addMenuListener(new IMenuListener() {
+
+            @Override
+            public void menuAboutToShow(IMenuManager m) {
+                contextMenuAboutToShow(m);
+            }
+        });
+        Menu menu = contextMenuManager.createContextMenu(textControl);
+        textControl.setMenu(menu);
+
+        getSite().registerContextMenu(id, contextMenuManager, textViewer);
+    }
+
+    private void createTextControl() {
+
+        IPreferenceStore store = JavaPlugin.getDefault().getCombinedPreferenceStore();
+        final JavaSourceViewer viewer = new JavaSourceViewer(
+            stackComposite, null, null, true, SWT.V_SCROLL | SWT.H_SCROLL,
+            store);
+
+        JavaSourceViewerConfiguration configuration = new JavaConfiguration(
+            JavaPlugin.getDefault().getJavaTextTools().getColorManager(), store, null, IJavaPartitions.JAVA_PARTITIONING);
+		viewer.configure(configuration);
+        viewer.setEditable(false);
+        textViewer = viewer;
+
+        textControl = textViewer.getTextWidget();
+        IDocument document = new Document("");
+        textViewer.setDocument(document);
+
+        textSelectionListener = new ISelectionChangedListener() {
+
+            @Override
+            public void selectionChanged(SelectionChangedEvent event) {
+                // Updates selection dependent actions like find/copy.
+                Iterator<String> iterator = selectionActions.iterator();
+                while (iterator.hasNext()) {
+                    updateAction(iterator.next());
+                }
+            }
+        };
+
+        textListener = new ITextListener() {
+
+            @Override
+            public void textChanged(TextEvent event) {
+                IUpdate findReplace = (IUpdate) globalActions
+                    .get(ActionFactory.FIND.getId());
+                if (findReplace != null) {
+                    findReplace.update();
+                }
+            }
+        };
+
+        textViewer.getSelectionProvider().addSelectionChangedListener(
+            textSelectionListener);
+        textViewer.addTextListener(textListener);
+
+        textControl.addMouseListener(new MouseAdapter() {
+
+            @Override
+            public void mouseDown(MouseEvent e) {
+                if (modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+                    selectionChangedAction.run();
+                }
+            }
+            @Override
+            public void mouseUp(MouseEvent e) {
+                if (modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+                    selectionChangedAction.run();
+                }
+            }
+        });
+
+        textControl.addKeyListener(new KeyListener() {
+
+            @Override
+            public void keyPressed(KeyEvent e) {
+                // ignored
+            }
+
+            @Override
+            public void keyReleased(KeyEvent e) {
+                if (modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+                    selectionChangedAction.run();
+                }
+            }
+        });
+    }
+
+    /**
+     * @see org.eclipse.ui.IWorkbenchPart#dispose()
+     */
+    @Override
+    public void dispose() {
+        deActivateView();
+        if (editorListener != null) {
+            getSite().getWorkbenchWindow().getPartService().removePartListener(
+                editorListener);
+            getSite().getWorkbenchWindow()
+                .getSelectionService().removePostSelectionListener(editorListener);
+            FileBuffers.getTextFileBufferManager().removeFileBufferListener(
+                editorListener);
+            editorListener.dispose();
+            editorListener = null;
+        }
+
+        if (contextMenuManager != null) {
+            contextMenuManager.dispose();
+        }
+
+        selectionActions.clear();
+        globalActions.clear();
+
+        textViewer.getSelectionProvider().removeSelectionChangedListener(
+            textSelectionListener);
+        textViewer.removeTextListener(textListener);
+        textViewer = null;
+        viewSelectionProvider = null;
+
+        if (textControl != null) {
+            textControl.dispose();
+            textControl = null;
+        }
+        if (verifyControl != null) {
+            verifyControl.dispose();
+            verifyControl = null;
+            tableControl = null;
+            stackTable = null;
+            lvtTable = null;
+            tableControlViewer = null;
+        }
+        currentSelection = null;
+        javaEditor = null;
+        setJavaInput(null);
+        lastChildElement = null;
+        lastDecompiledResult = null;
+
+        linkWithEditorAction.dispose();
+        showSelectedOnlyAction.dispose();
+        setRawModeAction.dispose();
+        toggleASMifierModeAction.dispose();
+        hideLineInfoAction.dispose();
+        hideLocalsAction.dispose();
+        hideStackMapAction.dispose();
+        showHexValuesAction.dispose();
+        expandStackMapAction.dispose();
+        toggleVerifierAction.dispose();
+
+        linkWithEditorAction = null;
+        selectionChangedAction = null;
+        refreshVarsAndStackAction = null;
+        showSelectedOnlyAction = null;
+        setRawModeAction = null;
+        toggleASMifierModeAction = null;
+        hideLineInfoAction = null;
+        hideLocalsAction = null;
+        hideStackMapAction = null;
+        showHexValuesAction = null;
+        expandStackMapAction = null;
+        toggleVerifierAction = null;
+        super.dispose();
+    }
+
+    /**
+     * Fill the context menu
+     * @param menuManager menu
+     */
+    protected void contextMenuAboutToShow(IMenuManager menuManager) {
+        IDocument doc = textViewer.getDocument();
+        if (doc == null) {
+            return;
+        }
+
+        menuManager
+            .add(globalActions.get(ActionFactory.COPY.getId()));
+        menuManager.add(globalActions.get(ActionFactory.SELECT_ALL
+            .getId()));
+
+        menuManager.add(new Separator("FIND")); //$NON-NLS-1$
+        menuManager
+            .add(globalActions.get(ActionFactory.FIND.getId()));
+
+        menuManager.add(new Separator(IWorkbenchActionConstants.MB_ADDITIONS));
+    }
+
+    // -----------------------------------------------------------------------
+
+    /**
+     * Passing the focus request to the viewer's control.
+     */
+    @Override
+    public void setFocus() {
+        if (!modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            if (textViewer != null) {
+                textViewer.getTextWidget().setFocus();
+            }
+        } else {
+            if (tableControl != null) {
+                tableControl.setFocus();
+            }
+        }
+    }
+
+    protected void handleBufferIsDirty(boolean isDirty) {
+        if (!modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR) || !isActive()) {
+            return;
+        }
+        if (isDirty) {
+            setBufferIsDirty(isDirty);
+        } else {
+            if (!bufferIsDirty) {
+                // second time calling with same argument -
+                // cause new bytecode should be written now
+                inputChanged = true;
+                refreshView();
+            } else {
+                // first time - set the flag only - cause
+                // bytecode is not yet written
+                setBufferIsDirty(false);
+            }
+        }
+    }
+
+    protected void handlePartHidden(IWorkbenchPart part) {
+        if (!modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+            return;
+        }
+        if (this == part) {
+            isVisible = false;
+            deActivateView();
+        } else if (isActive() && (part instanceof IEditorPart)) {
+            // check if at least one editor is open
+            checkOpenEditors(false);
+        }
+    }
+
+    protected void handlePartVisible(IWorkbenchPart part) {
+        if (!modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR)) {
+            if(this == part){
+                isVisible = true;
+            }
+            return;
+        }
+        if (this == part) {
+            if (isVisible) {
+                return;
+            }
+            isVisible = true;
+            // check if java editor is already open
+            IEditorPart activeEditor = EclipseUtils.getActiveEditor();
+            if (!(activeEditor instanceof ITextEditor)) {
+                // start monitoring again, even if current editor is not
+                // supported - but we at front now
+                activateView();
+                return;
+            }
+            part = activeEditor;
+            // continue with setting input
+        }
+        if (isVisible && part instanceof ITextEditor) {
+            if (isActive() && part == javaEditor) {
+                return;
+            }
+            activateView();
+            setEnabled(true);
+            setInput((ITextEditor) part);
+            refreshView();
+        } else if (part instanceof IEditorPart) {
+            if (isActive()) {
+                deActivateView();
+            }
+        }
+    }
+
+    protected void handleSelectionChanged(IWorkbenchPart part,
+        ISelection selection) {
+        if (!modes.get(BCOConstants.F_LINK_VIEW_TO_EDITOR) || !isActive()
+            || !isVisible || !(part instanceof IEditorPart)) {
+            return;
+        }
+        if (!(part instanceof ITextEditor)) {
+            deActivateView();
+            return;
+        }
+        if (!isEnabled()) {
+            setEnabled(true);
+        }
+        if (part != javaEditor) {
+            setInput((ITextEditor) part);
+        } else {
+            if (!updateSelection((ITextSelection) selection)) {
+                return;
+            }
+        }
+        refreshView();
+    }
+
+    /**
+     * Does nothing if view is already active
+     */
+    private void activateView() {
+        if (isActive()) {
+            return;
+        }
+        isActive = true;
+        getSite().getWorkbenchWindow().getSelectionService()
+            .addPostSelectionListener(editorListener);
+        FileBuffers.getTextFileBufferManager().addFileBufferListener(
+            editorListener);
+    }
+
+    /**
+     * Does nothing if view is already deactivated
+     */
+    private void deActivateView() {
+        if (!isActive()) {
+            return;
+        }
+        setEnabled(false);
+        if (editorListener != null) {
+            ISelectionService service = getSite().getWorkbenchWindow()
+                .getSelectionService();
+            if (service != null) {
+                service.removePostSelectionListener(editorListener);
+            }
+            FileBuffers.getTextFileBufferManager().removeFileBufferListener(
+                editorListener);
+
+        }
+        if (textViewer != null && textViewer.getTextWidget() != null
+            && !textViewer.getTextWidget().isDisposed()) {
+            IDocument document = new Document("");
+            textViewer.setDocument(document);
+        }
+        if (tableControl != null && !tableControl.isDisposed()) {
+            setVerifyTableItems(null);
+        }
+        /*
+         * if(stackControl != null && !stackControl.isDisposed()){
+         * stackControl.setText(""); } if(lvtControl != null && !lvtControl.isDisposed()){
+         * lvtControl.setText(""); }
+         */
+        if (stackTable != null && !stackTable.isDisposed()) {
+            stackTable.removeAll();
+        }
+        if (lvtTable != null && !lvtTable.isDisposed()) {
+            lvtTable.removeAll();
+        }
+        if (statusControl != null && !statusControl.isDisposed()) {
+            updateStatus(null, -1, -1);
+        }
+        currentSelection = null;
+        lastDecompiledResult = null;
+        javaEditor = null;
+        setJavaInput(null);
+        lastChildElement = null;
+        setBufferIsDirty(false);
+        isActive = false;
+    }
+
+    protected void refreshView() {
+        if (!isActive()) {
+            return;
+        }
+
+        IJavaElement childEl = getCurrentJavaElement();
+        if (childEl == null && javaInput == null) {
+            setInput(javaEditor);
+            childEl = javaInput;
+        }
+
+        // after getCurrentJavaElement() call it is possible that java type is disappear
+        // because corresponding type is not more exist in model
+        if (javaInput == null) {
+            deActivateView();
+            return;
+        }
+
+        boolean clearOutput = false;
+
+        if (inputChanged || isSelectedElementChanged(childEl)) {
+
+            DecompiledClass result = decompileBytecode(childEl);
+            if (result == null) {
+                clearOutput = true;
+            } else {
+                boolean hasMethods = !result.isAbstractOrInterface() || result.isDefaultMethodPossible();
+                if (modes.get(BCOConstants.F_SHOW_ANALYZER) && hasMethods) {
+                    refreshVerifyView(result);
+                } else {
+                    toggleVerifierAction.setEnabled(hasMethods);
+                    refreshTextView(result);
+                }
+            }
+            lastDecompiledResult = result;
+        } else if (childEl == null
+            && modes.get(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT)) {
+            clearOutput = true;
+        }
+
+        lastChildElement = childEl;
+        if (clearOutput) {
+            if (!modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+                IDocument document = new Document("");
+                textViewer.setDocument(document);
+            } else {
+                setVerifyTableItems(null);
+            }
+        }
+        setSelectionInBytecodeView();
+        inputChanged = false;
+    }
+
+    private void refreshTextView(DecompiledClass result) {
+        IDocument document = new Document(result.getText());
+        JavaTextTools tools= JavaPlugin.getDefault().getJavaTextTools();
+        tools.setupJavaDocumentPartitioner(document, IJavaPartitions.JAVA_PARTITIONING);
+//        JavaSourceViewerConfiguration configuration = new JavaSourceViewerConfiguration(
+//            JavaPlugin.getDefault().getJavaTextTools().getColorManager(),
+//            JavaPlugin.getDefault().getCombinedPreferenceStore(), javaEditor,
+//            IJavaPartitions.JAVA_PARTITIONING);
+//        textViewer.unconfigure();
+//        textViewer.configure(configuration);
+        textViewer.setDocument(document);
+        // we are in verify mode but we can't show content because
+        // current element is abstract, so we clean table content
+        if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            setVerifyTableItems(null);
+        }
+        hasAnalyzerError = false;
+    }
+
+    private void refreshVerifyView(DecompiledClass result) {
+        setVerifyTableItems(result.getTextTable());
+        List<Integer> errors = result.getErrorLines();
+        if (errors.size() > 0) {
+            // TODO this only changes color of status line -
+            // but it is possible also to provide useful info here...
+            hasAnalyzerError = true;
+            // currentErrorMessage = ...
+        }
+        for (int i = 0; i < errors.size(); ++i) {
+            int l = errors.get(i).intValue();
+            tableControl.getItem(l).setForeground(errorColor);
+        }
+        toggleVerifierAction.setEnabled(true);
+    }
+
+    /**
+     * @param result
+     */
+    private void updateStatus(DecompiledClass result, int bytecodeOffsetStart,
+        int bytecodeOffsetEnd) {
+        // clear error messages, if any
+        statusLineManager.setErrorMessage(null);
+        if (result != null) {
+            currentStatusMessage = "Java:"
+                + result.getJavaVersion() + " | class size:"
+                + result.getClassSize();
+            ClassNode classNode = result.getClassNode();
+            if(classNode != null && classNode.name != null) {
+                setContentDescription(classNode.name);
+            }
+        } else {
+            currentStatusMessage = "";
+            setContentDescription("");
+        }
+        String selectionInfo = "";
+        if (bytecodeOffsetStart >= 0) {
+            selectionInfo = " | offset:" + bytecodeOffsetStart;
+            if (bytecodeOffsetEnd >= 0) {
+                selectionInfo += "-" + bytecodeOffsetEnd;
+            }
+        }
+        if (hasAnalyzerError) {
+            statusLineManager.setErrorMessage(currentStatusMessage
+                + selectionInfo);
+        } else {
+            statusLineManager.setMessage(currentStatusMessage + selectionInfo);
+        }
+
+    }
+
+    @Override
+    public int getBytecodeInstructionAtLine(int line) {
+        if (lastDecompiledResult != null) {
+            return lastDecompiledResult.getBytecodeInsn(line);
+        }
+        return -1;
+    }
+
+    /**
+     * @return IJavaElement which fits in the current selection in java editor
+     */
+    private IJavaElement getCurrentJavaElement() {
+        IJavaElement childEl = null;
+        try {
+            childEl = JdtUtils.getElementAtOffset(javaInput, currentSelection);
+            if (childEl != null) {
+                switch (childEl.getElementType()) {
+                    case IJavaElement.METHOD :
+                    case IJavaElement.FIELD :
+                    case IJavaElement.INITIALIZER :
+                    case IJavaElement.TYPE :
+                        break;
+                    case IJavaElement.LOCAL_VARIABLE :
+                        childEl = childEl.getAncestor(IJavaElement.METHOD);
+                        break;
+                    default :
+                        childEl = null;
+                        break;
+                }
+            }
+        } catch (JavaModelException e) {
+            // the exception is mostly occured if java structure was
+            // changed and current element is not more exist in model
+            // e.g. on rename/delete/move operation.
+            // so it is not an error for user, but info for us
+            BytecodeOutlinePlugin.log(e, IStatus.INFO);
+            setJavaInput(null);
+            lastChildElement = null;
+        }
+        return childEl;
+    }
+
+    private void setSelectionInBytecodeView() {
+        if (lastDecompiledResult == null) {
+            return;
+        }
+
+        if (currentSelection.getStartLine() != currentSelection.getEndLine()) {
+            setMultiLineSelectionInBytecodeView(currentSelection);
+            return;
+        }
+
+        int sourceLine = currentSelection.getStartLine() + 1;
+        int decompiledLine = lastDecompiledResult.getDecompiledLine(sourceLine);
+
+        if (decompiledLine < 0
+            && !modes.get(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT)
+            && lastChildElement != null) {
+            /*
+             * May be this is the selection in outline view, if complete class is shown.
+             * Because there are no bytecode instructions/offset for method name, we need
+             * to find and select first method line. See cr 306011
+             */
+            DecompiledMethod match = lastDecompiledResult.getBestDecompiledMatch(sourceLine);
+            if(match != null){
+                // this is relative to method start
+                decompiledLine = match.getBestDecompiledLine(sourceLine);
+                if(decompiledLine > 0){
+                    // convert to class file relative
+                    decompiledLine = lastDecompiledResult.getDecompiledLine(match, decompiledLine);
+                }
+            }
+            if(decompiledLine < 0){
+                String methodName = JdtUtils.getMethodSignature(lastChildElement);
+                if (methodName != null) {
+                    decompiledLine = lastDecompiledResult
+                        .getDecompiledLine(methodName) - 1;
+                }
+            }
+        }
+
+        if (decompiledLine > 0) {
+            try {
+                if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+                    updateVerifierControl4line(decompiledLine);
+                    tableControl.setSelection(decompiledLine);
+                } else {
+                    int lineCount = textControl.getLineCount();
+                    if (decompiledLine < lineCount) {
+                        int offsetAtLine = textControl
+                            .getOffsetAtLine(decompiledLine);
+                        int offsetEnd = textControl.getText().indexOf(
+                            '\n', offsetAtLine);
+                        textControl.setSelection(offsetAtLine, offsetEnd);
+                    }
+                }
+            } catch (IllegalArgumentException e) {
+                BytecodeOutlinePlugin.error(null, e);
+            }
+        } else if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            lvtTable.removeAll();
+            stackTable.removeAll();
+        }
+        int bytecodeOffset = lastDecompiledResult
+            .getBytecodeOffset(decompiledLine);
+        updateStatus(lastDecompiledResult, bytecodeOffset, -1);
+    }
+
+    private void setMultiLineSelectionInBytecodeView(
+        ITextSelection multiLineSelection) {
+        LineRange range = lastDecompiledResult
+            .getDecompiledRange(multiLineSelection);
+        int firstDecompiledLine = range.startLine;
+        if (firstDecompiledLine > 0) {
+            try {
+                if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+                    updateVerifierControl4line(firstDecompiledLine);
+                    tableControl.setSelection(firstDecompiledLine);
+                } else {
+                    int lineCount = textControl.getLineCount();
+                    if (firstDecompiledLine < lineCount) {
+                        int offsetAtLine = textControl
+                            .getOffsetAtLine(firstDecompiledLine);
+                        int offsetEnd;
+                        String text = textControl.getText();
+                        if (range.endLine > 0 && range.endLine < lineCount) {
+                            offsetEnd = textControl
+                                .getOffsetAtLine(range.endLine);
+                            offsetEnd = text.indexOf("LINENUMBER", text
+                                .indexOf('\n', offsetEnd));
+                            if (offsetEnd < 0) {
+                                offsetEnd = text.indexOf('\n', offsetEnd);
+                            }
+                        } else {
+                            offsetEnd = text.indexOf('\n', offsetAtLine);
+                        }
+                        textControl.setSelection(offsetAtLine, offsetEnd);
+                    }
+                }
+            } catch (IllegalArgumentException e) {
+                BytecodeOutlinePlugin.error(null, e);
+            }
+        } else if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            lvtTable.removeAll();
+            stackTable.removeAll();
+        }
+        int bytecodeOffsetStart = lastDecompiledResult
+            .getBytecodeOffset(firstDecompiledLine);
+        int bytecodeOffsetEnd = lastDecompiledResult
+            .getBytecodeOffset(range.endLine);
+        updateStatus(
+            lastDecompiledResult, bytecodeOffsetStart, bytecodeOffsetEnd);
+    }
+
+    protected void updateVerifierControl4line(int decompiledLine) {
+        String[][][] frame = lastDecompiledResult.getFrameTables(
+            decompiledLine, !modes.get(BCOConstants.F_SHOW_RAW_BYTECODE));
+        updateVerifierControl(frame);
+    }
+
+    protected void updateVerifierControl4insn(int insn) {
+        String[][][] frame = lastDecompiledResult.getFrameTablesForInsn(
+            insn, !modes.get(BCOConstants.F_SHOW_RAW_BYTECODE));
+        updateVerifierControl(frame);
+    }
+
+    private void updateVerifierControl(String[][][] frame) {
+        lvtTable.removeAll();
+        stackTable.removeAll();
+        if (frame == null) {
+            return;
+        }
+        for (int i = 0; i < frame[0].length; ++i) {
+            if (frame[0][i] != null) {
+                new TableItem(lvtTable, SWT.NONE).setText(frame[0][i]);
+            }
+        }
+        for (int i = 0; i < frame[1].length; ++i) {
+            if (frame[1][i] != null) {
+                new TableItem(stackTable, SWT.NONE).setText(frame[1][i]);
+            }
+        }
+
+        lvtTable.getColumn(0).pack();
+        lvtTable.getColumn(1).pack();
+        lvtTable.getColumn(2).pack();
+        stackTable.getColumn(0).pack();
+        stackTable.getColumn(1).pack();
+    }
+
+    protected void setSelectionInJavaEditor(Point selection) {
+        if (javaEditor != null && javaEditor.getEditorInput() == null) {
+            // editor was closed - we should clean the reference
+            javaEditor = null;
+            setJavaInput(null);
+        }
+        if (javaEditor == null || lastDecompiledResult == null) {
+            deActivateView();
+            return;
+        }
+
+        int startDecLine;
+        int endDecLine = -1;
+        if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            startDecLine = tableControl.getSelectionIndex();
+            endDecLine = startDecLine;
+        } else {
+            startDecLine = textControl.getLineAtOffset(selection.x);
+            endDecLine = textControl.getLineAtOffset(selection.y);
+        }
+        int startSourceLine = lastDecompiledResult.getSourceLine(startDecLine);
+        int endSourceLine = -1;
+        if(endDecLine > 0){
+            endSourceLine = lastDecompiledResult.getSourceLine(endDecLine);
+        }
+
+        if(endSourceLine < startSourceLine){
+            int tmp = startSourceLine;
+            startSourceLine = endSourceLine;
+            endSourceLine = tmp;
+        }
+
+        try {
+            if (startSourceLine > 0) {
+                IDocument document = javaEditor.getDocumentProvider()
+                    .getDocument(javaEditor.getEditorInput());
+                try {
+                    IRegion lineInfo = document
+                        .getLineInformation(startSourceLine - 1);
+
+                    int startOffset = lineInfo.getOffset();
+                    int length = lineInfo.getLength();
+                    if(endSourceLine > 0){
+                        IRegion region = document.getLineInformation(endSourceLine - 1);
+                        length = region.getLength() + (region.getOffset() - startOffset);
+                    }
+                    EclipseUtils.selectInEditor(javaEditor, startOffset, length);
+                } catch (BadLocationException e) {
+                    // do nothing. This could happens e.g. if editor does not contain
+                    // full source code etc, so that line info is not exist in editor
+                }
+            }
+        } catch (Exception e) {
+            BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+        }
+
+        int bytecodeOffset = lastDecompiledResult
+            .getBytecodeOffset(startDecLine);
+        updateStatus(lastDecompiledResult, bytecodeOffset, -1);
+    }
+
+    // ------------------------------------------------------------------------
+
+    /**
+     * check if at least one java editor is open - if not, deactivate me
+     * @param checkNewSelection
+     */
+    protected void checkOpenEditors(boolean checkNewSelection) {
+        IEditorReference[] editorReferences = getSite().getPage()
+            .getEditorReferences();
+        if (editorReferences == null || editorReferences.length == 0) {
+            deActivateView();
+        } else if (checkNewSelection) {
+            IEditorPart activeEditor = EclipseUtils.getActiveEditor();
+            if (activeEditor instanceof ITextEditor) {
+                ITextSelection selection = EclipseUtils
+                    .getSelection(((ITextEditor) activeEditor)
+                        .getSelectionProvider());
+                handleSelectionChanged(activeEditor, selection);
+            } else {
+                deActivateView();
+            }
+        }
+    }
+
+    /**
+     * @param childEl
+     * @return true if java element selection was changed (means, that previous selection
+     * do not match to the given element)
+     */
+    private boolean isSelectedElementChanged(IJavaElement childEl) {
+
+        if (lastChildElement == null && childEl == null) {
+            // no selected child before - and no new selection now => no changes
+            return false;
+        }
+
+        if (modes.get(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT)) {
+            if (lastChildElement == null || !lastChildElement.equals(childEl)) {
+                return true;
+            }
+        }
+
+        /*
+         * the check if we changed from inner class to outer class or vice versa
+         */
+        if (lastChildElement != null && childEl != null) {
+            IType newEnclosingType = JdtUtils.getEnclosingType(childEl);
+            IType oldEnclosingType = JdtUtils
+                .getEnclosingType(lastChildElement);
+            return newEnclosingType == null
+                || !newEnclosingType.equals(oldEnclosingType);
+        }
+        return false;
+    }
+
+    /**
+     * @param childEl
+     * @return return null if type is not known or bytecode is not written or cannot be
+     * found
+     */
+    private DecompiledClass decompileBytecode(IJavaElement childEl) {
+        // check here for inner classes too
+        IJavaElement type = JdtUtils.getEnclosingType(childEl);
+        if (type == null) {
+            type = javaInput;
+        }
+        if (type == null) {
+            return null;
+        }
+        byte[] bytes = JdtUtils.readClassBytes(type);
+        if (bytes == null) {
+            return null;
+        }
+        DecompiledClass decompiledClass = null;
+        int available = bytes.length;
+        try {
+            ClassLoader cl = null;
+            if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+                cl = JdtUtils.getClassLoader(type);
+            }
+
+            String fieldName = null;
+            String methodName = null;
+            /*
+             * find out, which name we should use for selected element
+             */
+            if (modes.get(BCOConstants.F_SHOW_ONLY_SELECTED_ELEMENT)
+                && childEl != null) {
+                if (childEl.getElementType() == IJavaElement.FIELD) {
+                    fieldName = childEl.getElementName();
+                } else {
+                    methodName = JdtUtils.getMethodSignature(childEl);
+                }
+            }
+            decompiledClass = DecompilerHelper.getDecompiledClass(
+                bytes, new DecompilerOptions(fieldName, methodName, modes, cl));
+        } catch (Exception e) {
+            try {
+                // check if compilation unit is ok - then this is the user problem
+                if (type.isStructureKnown()) {
+                    BytecodeOutlinePlugin.error("Cannot decompile: " + type, e);
+                } else {
+                    BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+                }
+            } catch (JavaModelException e1) {
+                // this is compilation problem - don't show the message
+                BytecodeOutlinePlugin.log(e1, IStatus.WARNING);
+            }
+        } catch (UnsupportedClassVersionError e) {
+            BytecodeOutlinePlugin.error("Cannot decompile: " + type
+                + ". Error was caused by attempt to "
+                + "load a class compiled with the Java version which is not "
+                + "supported by the current JVM. ", e);
+        }
+        // remember class file size to show it later in UI
+        if (decompiledClass != null) {
+            decompiledClass.setClassSize(available);
+        }
+        return decompiledClass;
+    }
+
+    private void setVerifyTableItems(String[][] items) {
+        tableControl.removeAll();
+        if (items != null) {
+            for (int i = 0; i < items.length; ++i) {
+                TableItem item = new TableItem(tableControl, SWT.NONE);
+                for (int j = 0; j < items[i].length; ++j) {
+                    String s = items[i][j];
+                    if (s.endsWith("\n")) {
+                        s = s.substring(0, s.length() - 1);
+                        // this is the "cookie" for the bytecode reference, which could be
+                        // mapped later to the sourcecode line on selection event in the
+                        // table
+                        item.setData(Integer.valueOf(i));
+                    }
+                    item.setText(j, s);
+                }
+            }
+            tableControl.getColumn(0).pack();
+            tableControl.getColumn(1).pack();
+            tableControl.getColumn(2).pack();
+            tableControl.getColumn(3).pack();
+            tableControl.getColumn(4).pack();
+        }
+    }
+
+    @Override
+    public <T> T getAdapter(Class<T> adapter) {
+        if (IFindReplaceTarget.class.equals(adapter)) {
+            return adapter.cast(textViewer.getFindReplaceTarget());
+        }
+        if (Widget.class.equals(adapter)) {
+            return adapter.cast(textViewer.getTextWidget());
+        }
+        if (TextViewer.class.equals(adapter)) {
+            return adapter.cast(textViewer);
+        }
+        return super.getAdapter(adapter);
+    }
+
+    /**
+     * Configures an action for key bindings.
+     * @param actionBars action bars for this page
+     * @param actionID action definition id
+     * @param action associated action
+     */
+    protected void setGlobalAction(IActionBars actionBars, String actionID,
+        IAction action) {
+        globalActions.put(actionID, action);
+        actionBars.setGlobalActionHandler(actionID, action);
+    }
+
+    /**
+     * Updates the global action with the given id
+     * @param actionId action definition id
+     */
+    protected void updateAction(String actionId) {
+        IAction action = globalActions.get(actionId);
+        if (action instanceof IUpdate) {
+            ((IUpdate) action).update();
+        }
+    }
+
+    protected void createTextActions() {
+        IActionBars actionBars = getViewSite().getActionBars();
+        TextViewerAction action = new TextViewerAction(
+            textViewer, ITextOperationTarget.SELECT_ALL);
+
+        action.configureAction(
+            BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                + "select_all.label"), BytecodeOutlinePlugin
+                .getResourceString(NLS_PREFIX + "select_all.tooltip"),
+            BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                + "select_all.description"));
+        setGlobalAction(actionBars, ActionFactory.SELECT_ALL.getId(), action);
+
+        action = new TextViewerAction(textViewer, ITextOperationTarget.COPY);
+        action.configureAction(
+            BytecodeOutlinePlugin.getResourceString(NLS_PREFIX + "copy.label"),
+            BytecodeOutlinePlugin
+                .getResourceString(NLS_PREFIX + "copy.tooltip"),
+            BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                + "copy.description"));
+        action.setImageDescriptor(PlatformUI.getWorkbench().getSharedImages()
+            .getImageDescriptor(ISharedImages.IMG_TOOL_COPY));
+        action.setActionDefinitionId(IWorkbenchCommandConstants.EDIT_COPY);
+        setGlobalAction(actionBars, ActionFactory.COPY.getId(), action);
+
+        ResourceBundle bundle = BytecodeOutlinePlugin.getDefault()
+            .getResourceBundle();
+
+        setGlobalAction(
+            actionBars, ActionFactory.FIND.getId(), new FindReplaceAction(
+                bundle, NLS_PREFIX + "find_replace.", this)); //$NON-NLS-1$
+
+        selectionActions.add(ActionFactory.COPY.getId());
+        selectionActions.add(ActionFactory.FIND.getId());
+
+        actionBars.updateActionBars();
+    }
+
+    // orientation
+
+    private void setOrientation(int orientation) {
+        if (verifyControl == null || verifyControl.isDisposed()) {
+            return;
+        }
+
+        boolean horizontal = orientation == VIEW_ORIENTATION_HORIZONTAL;
+        verifyControl.setOrientation(horizontal
+            ? SWT.HORIZONTAL
+            : SWT.VERTICAL);
+
+        for (int i = 0; i < toggleOrientationActions.length; ++i) {
+            toggleOrientationActions[i]
+                .setChecked(orientation == toggleOrientationActions[i]
+                    .getOrientation());
+        }
+
+        currentOrientation = orientation;
+        // GridLayout layout= (GridLayout) fCounterComposite.getLayout();
+        // setCounterColumns(layout);
+        stackComposite.getParent().layout();
+    }
+
+    protected void computeOrientation() {
+        if (orientation != VIEW_ORIENTATION_AUTOMATIC) {
+            currentOrientation = orientation;
+            setOrientation(currentOrientation);
+        } else {
+            Point size = stackComposite.getParent().getSize();
+            if (size.x != 0 && size.y != 0) {
+                setOrientation(size.x > size.y
+                    ? VIEW_ORIENTATION_HORIZONTAL
+                    : VIEW_ORIENTATION_VERTICAL);
+            }
+        }
+    }
+
+    /**
+     * Set the bit with given index to given value and remembers it in the preferences
+     * @param bitIndex
+     * @param value
+     */
+    protected void setMode(int bitIndex, boolean value) {
+        modes.set(bitIndex, value);
+    }
+
+    protected void toggleVerifyMode(final IMenuManager mmanager,
+        boolean showAnalyzer) {
+        setMode(BCOConstants.F_SHOW_ANALYZER, showAnalyzer);
+        if (modes.get(BCOConstants.F_SHOW_ANALYZER)) {
+            ((StackLayout) stackComposite.getLayout()).topControl = verifyControl;
+            viewSelectionProvider
+                .setCurrentSelectionProvider(tableControlViewer);
+        } else {
+            ((StackLayout) stackComposite.getLayout()).topControl = textControl;
+            viewSelectionProvider.setCurrentSelectionProvider(textViewer);
+        }
+        stackComposite.layout();
+
+        for (int i = 0; i < toggleOrientationActions.length; ++i) {
+            toggleOrientationActions[i].setEnabled(showAnalyzer);
+        }
+        mmanager.markDirty();
+        mmanager.update();
+    }
+
+
+    private class ToggleOrientationAction extends Action {
+
+        private final int actionOrientation;
+
+        public ToggleOrientationAction(BytecodeOutlineView v, int orientation) {
+            super("", AS_RADIO_BUTTON); //$NON-NLS-1$
+
+            String symbolicName = BytecodeOutlinePlugin.getDefault()
+                .getBundle().getSymbolicName();
+            if (orientation == VIEW_ORIENTATION_HORIZONTAL) {
+                setText(BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                    + "toggle.horizontal.label")); //$NON-NLS-1$
+                setImageDescriptor(AbstractUIPlugin.imageDescriptorFromPlugin(
+                    symbolicName, "icons/th_horizontal.gif")); //$NON-NLS-1$
+            } else if (orientation == VIEW_ORIENTATION_VERTICAL) {
+                setText(BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                    + "toggle.vertical.label")); //$NON-NLS-1$
+                setImageDescriptor(AbstractUIPlugin.imageDescriptorFromPlugin(
+                    symbolicName, "icons/th_vertical.gif")); //$NON-NLS-1$
+            } else if (orientation == VIEW_ORIENTATION_AUTOMATIC) {
+                setText(BytecodeOutlinePlugin.getResourceString(NLS_PREFIX
+                    + "toggle.automatic.label")); //$NON-NLS-1$
+                setImageDescriptor(AbstractUIPlugin.imageDescriptorFromPlugin(
+                    symbolicName, "icons/th_automatic.gif")); //$NON-NLS-1$
+            }
+            actionOrientation = orientation;
+            // WorkbenchHelp.setHelp(this,
+            // IJUnitHelpContextIds.RESULTS_VIEW_TOGGLE_ORIENTATION_ACTION);
+        }
+
+        public int getOrientation() {
+            return actionOrientation;
+        }
+
+        @Override
+        public void run() {
+            if (isChecked()) {
+                orientation = actionOrientation;
+                computeOrientation();
+            }
+        }
+    }
+
+    protected IJavaElement[] guessTypesFromSelectionInView(IRegion wordRegion)
+        throws JavaModelException {
+        if (wordRegion == null || wordRegion.getLength() == 0 || javaInput == null) {
+            return null;
+        }
+        String typeName;
+        try {
+            typeName = textViewer.getDocument().get(wordRegion.getOffset(), wordRegion.getLength());
+        } catch (BadLocationException e) {
+            return null;
+        }
+        if(typeName.isEmpty()) {
+            return null;
+        }
+        if(typeName.contains("$")) {
+            typeName = typeName.substring(typeName.lastIndexOf('$') + 1);
+        }
+        IJavaSearchScope scope = SearchEngine.createJavaSearchScope(new IJavaElement[] {javaInput.getJavaProject()});
+        return JdtUtils.getTypeForName(typeName, scope, null);
+    }
+
+    private class JavaElementHyperlinkDetectorInView extends JavaElementHyperlinkDetector {
+
+        @Override
+        public IHyperlink[] detectHyperlinks(ITextViewer textViewer1,
+            IRegion region, boolean canShowMultipleHyperlinks) {
+            if (region == null || javaInput == null) {
+                return null;
+            }
+
+            IAction openAction = new OpenAction(getSite());
+            int offset = region.getOffset();
+
+            IDocument document = textViewer1.getDocument();
+            IRegion wordRegion = JavaWordFinder.findWord(document, offset);
+            List<IHyperlink> links = new ArrayList<>();
+            IJavaElement[] elements;
+            try {
+                elements = guessTypesFromSelectionInView(wordRegion);
+            } catch (JavaModelException e) {
+                return null;
+            }
+            // TODO check for inner class files possibly referenced in current line.
+            // If found, add new hyperlink to jump to this inner class, see
+            // https://forge.ow2.org/tracker/index.php?func=detail&aid=316206&group_id=23&atid=350023
+            if (elements == null) {
+                return null;
+            }
+            elements = JdtUtils.selectOpenableElements(elements);
+            if (elements.length == 0) {
+                return null;
+            }
+            for (int i = 0; i < elements.length; i++) {
+                if (elements[i] == null) {
+                    continue;
+                }
+                addHyperlinks2(
+                    links, wordRegion, (SelectionDispatchAction) openAction,
+                    elements[i], elements.length > 1);
+            }
+            if (links.size() == 0) {
+                return null;
+            }
+            return links.toArray(new IHyperlink[links.size()]);
+        }
+
+        /**
+         * This method is added for compatibility with Eclipse 3.6 and 3.7 only!
+         * <p>
+         * Creates and adds Java element hyperlinks.
+         *
+         * @param hyperlinksCollector the list to which hyperlinks should be added
+         * @param wordRegion the region of the link
+         * @param openAction the action to use to open the Java elements
+         * @param element the Java element to open
+         * @param qualify <code>true</code> if the hyperlink text should show a qualified name for
+         *            element
+         * @param editor the active Java editor
+         *
+         * @since 3.7.1
+         */
+        protected void addHyperlinks2(List<IHyperlink> hyperlinksCollector, IRegion wordRegion, SelectionDispatchAction openAction, IJavaElement element, boolean qualify) {
+            hyperlinksCollector.add(new JavaElementHyperlink(wordRegion, openAction, element, qualify));
+        }
+
+    }
+
+    private final class JavaConfiguration extends JavaSourceViewerConfiguration {
+
+        private JavaConfiguration(
+            IColorManager colorManager, IPreferenceStore preferenceStore,
+            ITextEditor editor, String partitioning) {
+            super(colorManager, preferenceStore, editor, partitioning);
+        }
+
+        @Override
+        public IHyperlinkDetector[] getHyperlinkDetectors(
+            ISourceViewer sourceViewer) {
+            // does not work, as they work on *text editor*, not on the *view*...
+            // HyperlinkDetectorRegistry registry = EditorsUI.getHyperlinkDetectorRegistry();
+            // IHyperlinkDetector[] detectors = registry.createHyperlinkDetectors("org.eclipse.jdt.ui.javaCode", dummyEditorForHyperlinks);
+            JavaElementHyperlinkDetectorInView det = new JavaElementHyperlinkDetectorInView();
+            return new IHyperlinkDetector[] {det} ;
+        }
+
+        @Override
+        public ITextHover getTextHover(ISourceViewer sourceViewer,
+            String contentType, int stateMask) {
+            JavadocHover javadocHover = new JavadocHoverExtension();
+            return javadocHover;
+        }
+
+        @Override
+        public IQuickAssistAssistant getQuickAssistAssistant(
+            ISourceViewer sourceViewer) {
+            return null;
+        }
+    }
+
+    private final class JavadocHoverExtension extends JavadocHover {
+
+        private final Set<String> OPCODES = new HashSet<>(Arrays.asList(Printer.OPCODES));
+
+
+        @Override
+        protected IJavaElement[] getJavaElementsAt(
+            ITextViewer textViewer1, IRegion hoverRegion) {
+            try {
+                return guessTypesFromSelectionInView(hoverRegion);
+            } catch (JavaModelException e) {
+                return null;
+            }
+        }
+
+        @Override
+        public Object getHoverInfo2(ITextViewer viewer, IRegion region) {
+            String typeName;
+            IDocument document = viewer.getDocument();
+            try {
+                typeName = document.get(region.getOffset(), region.getLength());
+            } catch (BadLocationException e) {
+                return null;
+            }
+
+            if(!OPCODES.contains(typeName)) {
+                return super.getHoverInfo2(viewer, region);
+            }
+            int line;
+            try {
+                line = document.getLineOfOffset(region.getOffset());
+            } catch (BadLocationException e) {
+                return null;
+            }
+            StringBuilder sb = HelpUtils.getOpcodeHelpFor(getBytecodeInstructionAtLine(line));
+            if(sb.length() > 0) {
+                JavadocBrowserInformationControlInput input = new JavadocBrowserInformationControlInput(
+                    null, null, sb.toString(), 0);
+                return input;
+            }
+            return null;
+        }
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeReferenceView.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeReferenceView.java
new file mode 100644
index 0000000..b4eac1b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/BytecodeReferenceView.java
@@ -0,0 +1,194 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Eugene Kuleshov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Eugene Kuleshov - initial API and implementation
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+import org.eclipse.core.runtime.IStatus;
+import org.eclipse.jdt.bcoview.BytecodeOutlinePlugin;
+import org.eclipse.jdt.bcoview.preferences.BCOConstants;
+import org.eclipse.jdt.bcoview.ui.actions.DefaultToggleAction;
+import org.eclipse.jface.action.IToolBarManager;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.swt.SWT;
+import org.eclipse.swt.browser.Browser;
+import org.eclipse.swt.widgets.Composite;
+import org.eclipse.ui.IActionBars;
+import org.eclipse.ui.IPartListener2;
+import org.eclipse.ui.ISelectionListener;
+import org.eclipse.ui.ISelectionService;
+import org.eclipse.ui.IViewPart;
+import org.eclipse.ui.IViewReference;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.IWorkbenchPartReference;
+import org.eclipse.ui.IWorkbenchWindow;
+import org.eclipse.ui.PartInitException;
+import org.eclipse.ui.part.ViewPart;
+
+public class BytecodeReferenceView extends ViewPart implements IPartListener2, ISelectionListener {
+
+    private Browser browser;
+    private DefaultToggleAction linkWithViewAction;
+    private boolean linkWithView;
+
+    public BytecodeReferenceView() {
+        super();
+    }
+
+    @Override
+    public void createPartControl(Composite parent) {
+        browser = new Browser(parent, SWT.BORDER);
+        final IWorkbenchWindow workbenchWindow = getSite().getWorkbenchWindow();
+        linkWithView = BytecodeOutlinePlugin.getDefault().getPreferenceStore()
+            .getBoolean(BCOConstants.LINK_REF_VIEW_TO_EDITOR);
+        linkWithViewAction = new DefaultToggleAction(BCOConstants.LINK_REF_VIEW_TO_EDITOR){
+            @Override
+            public void run(boolean newState) {
+                linkWithView = newState;
+                if(linkWithView){
+                    ISelectionService selectionService = workbenchWindow
+                        .getSelectionService();
+                    try {
+                        IViewPart part = workbenchWindow.getActivePage()
+                            .showView(
+                                "org.eclipse.jdt.bcoview.views.BytecodeOutlineView");
+                        ISelection selection = selectionService
+                            .getSelection("org.eclipse.jdt.bcoview.views.BytecodeOutlineView");
+                        selectionChanged(part, selection);
+                    } catch (PartInitException e) {
+                        BytecodeOutlinePlugin.log(e, IStatus.ERROR);
+                    }
+                }
+            }
+        };
+        final IActionBars bars = getViewSite().getActionBars();
+        final IToolBarManager tmanager = bars.getToolBarManager();
+        tmanager.add(linkWithViewAction);
+        shouDefaultEmptyPage();
+        workbenchWindow.getPartService().addPartListener(this);
+    }
+
+    @Override
+    public void dispose() {
+        getSite().getWorkbenchWindow().getPartService().removePartListener(this);
+        browser.dispose();
+        browser = null;
+        linkWithViewAction = null;
+        super.dispose();
+    }
+
+    @Override
+    public void setFocus() {
+        browser.setFocus();
+    }
+
+    @Override
+    public void partActivated(IWorkbenchPartReference partRef) {
+        //
+    }
+
+    @Override
+    public void partBroughtToTop(IWorkbenchPartReference partRef) {
+        //
+    }
+
+    @Override
+    public void partClosed(IWorkbenchPartReference partRef) {
+        //
+    }
+
+    @Override
+    public void partDeactivated(IWorkbenchPartReference partRef) {
+        //
+    }
+
+    @Override
+    public void partOpened(IWorkbenchPartReference partRef) {
+        // WORKAROUND  - sometimes Eclipse does not invoke partVisible(),
+        // but only partOpened()...
+        partVisible(partRef);
+    }
+
+    @Override
+    public void partHidden(IWorkbenchPartReference partRef) {
+        if (partRef.getId().equals(getSite().getId())) {
+            getSite().getWorkbenchWindow().getSelectionService()
+                .removePostSelectionListener(this);
+        }
+    }
+
+    @Override
+    public void partVisible(IWorkbenchPartReference partRef) {
+        if (partRef.getId().equals(getSite().getId())) {
+            IWorkbenchWindow workbenchWindow = getSite().getWorkbenchWindow();
+            ISelectionService selectionService = workbenchWindow
+                .getSelectionService();
+            String partId = BytecodeOutlineView.class.getName();
+            selectionService.addPostSelectionListener(this);
+
+
+            // perform initialization with already existing selection (if any)
+            ISelection selection = selectionService.getSelection(partId);
+            if(selection != null) {
+                IViewReference viewReference = workbenchWindow.getActivePage()
+                    .findViewReference(partId);
+                if(viewReference != null) {
+                    selectionChanged(viewReference.getView(false), selection);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void partInputChanged(IWorkbenchPartReference partRef) {
+        //
+    }
+
+    @Override
+    public void selectionChanged(IWorkbenchPart part, ISelection selection) {
+        boolean isBytecodePartSelection = part instanceof IBytecodePart;
+        if (!linkWithView || !isBytecodePartSelection) {
+            return;
+        }
+        int line = -1;
+        if (selection instanceof ITextSelection) {
+            line = ((ITextSelection)selection).getStartLine();
+        } else if(selection instanceof IStructuredSelection){
+            IStructuredSelection sselection = (IStructuredSelection) selection;
+            int size = sselection.size();
+            if(size == 1 && sselection.getFirstElement() instanceof Integer){
+                line = ((Integer)sselection.getFirstElement()).intValue();
+            }
+        }
+
+        if(line < 0) {
+            shouDefaultEmptyPage();
+            return;
+        }
+        int opcode = ((IBytecodePart)part).getBytecodeInstructionAtLine(line);
+        StringBuilder helpFor = HelpUtils.getOpcodeHelpFor(opcode);
+        if (helpFor.length() > 0) {
+            browser.setText(helpFor.toString());
+        } else {
+            shouDefaultEmptyPage();
+        }
+    }
+
+    private void shouDefaultEmptyPage() {
+        browser.setUrl(HelpUtils.getHelpIndex().toString());
+    }
+
+}
+
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/EditorListener.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/EditorListener.java
new file mode 100644
index 0000000..fa778e0
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/EditorListener.java
@@ -0,0 +1,265 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+import org.eclipse.core.filebuffers.IFileBuffer;
+import org.eclipse.core.filebuffers.IFileBufferListener;
+import org.eclipse.core.runtime.IPath;
+import org.eclipse.jdt.core.IJavaElement;
+import org.eclipse.jface.text.ITextSelection;
+import org.eclipse.jface.viewers.ISelection;
+import org.eclipse.jface.viewers.IStructuredSelection;
+import org.eclipse.swt.widgets.Display;
+import org.eclipse.ui.IPartListener2;
+import org.eclipse.ui.ISelectionListener;
+import org.eclipse.ui.IWorkbenchPart;
+import org.eclipse.ui.IWorkbenchPartReference;
+
+public class EditorListener implements ISelectionListener, IFileBufferListener,
+    IPartListener2 {
+    volatile protected BytecodeOutlineView view;
+
+    EditorListener(BytecodeOutlineView view){
+        this.view = view;
+    }
+
+    /**
+     * clean view reference
+     */
+    public void dispose(){
+        this.view = null;
+    }
+
+    /**
+     * @param part
+     * @param selection
+     *
+     */
+    @Override
+    public void selectionChanged(IWorkbenchPart part, ISelection selection) {
+        if(!(selection instanceof ITextSelection)){
+            if(selection instanceof IStructuredSelection){
+                IStructuredSelection ssel = (IStructuredSelection) selection;
+                if(ssel.isEmpty()){
+                    return;
+                }
+                if(ssel.getFirstElement() instanceof IJavaElement){
+                    /*
+                     * this may be selection in outline view. If so, the editor selection
+                     * would be changed but no event would be sent :(
+                     * So we just delay the call and wait for new selection in editor
+                     */
+                    Display display = Display.getDefault();
+                    // fork
+                    display.asyncExec(new Runnable() {
+                        @Override
+                        public void run() {
+                            if(view != null) {
+                                view.checkOpenEditors(true);
+                            }
+                        }
+                    });
+                }
+            }
+            return;
+        }
+        view.handleSelectionChanged(part, selection);
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#dirtyStateChanged(org.eclipse.core.filebuffers.IFileBuffer, boolean)
+     */
+    @Override
+    public void dirtyStateChanged(IFileBuffer buffer, final boolean isDirty) {
+        if(!view.isLinkedWithEditor()){
+            return;
+        }
+        if(isSupportedBuffer(buffer)){
+            // first call set only view flag - cause
+            view.handleBufferIsDirty(isDirty);
+
+            // second call will really refresh view
+            if(!isDirty){
+                // this one will be called in UI thread after some delay, because we need
+                // to wait until the bytecode will be written on disk
+                final Runnable runnable2 = new Runnable() {
+                    @Override
+                    public void run() {
+                        view.handleBufferIsDirty(isDirty);
+                    }
+                };
+                // this one will be called in UI thread ASAP and allow us to leave
+                // current (probably non-UI) thread
+                Runnable runnable1 = new Runnable() {
+                    @Override
+                    public void run() {
+                        Display display = Display.getCurrent();
+                        display.timerExec(1000, runnable2);
+                    }
+                };
+                Display display = Display.getDefault();
+                // fork
+                display.asyncExec(runnable1);
+            }
+        }
+    }
+
+    private static boolean isSupportedBuffer(IFileBuffer buffer) {
+        String fileExtension = buffer.getLocation().getFileExtension();
+        // TODO export to properties
+        return "java".equals(fileExtension);// || "groovy".equals(fileExtension);  //$NON-NLS-1$
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partClosed(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partClosed(IWorkbenchPartReference partRef) {
+        view.handlePartHidden(partRef.getPart(false));
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partHidden(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partHidden(IWorkbenchPartReference partRef) {
+        view.handlePartHidden(partRef.getPart(false));
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partOpened(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partOpened(IWorkbenchPartReference partRef) {
+        view.handlePartVisible(partRef.getPart(false));
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partVisible(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partVisible(IWorkbenchPartReference partRef) {
+        view.handlePartVisible(partRef.getPart(false));
+    }
+
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#bufferDisposed(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void bufferDisposed(IFileBuffer buffer) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#bufferCreated(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void bufferCreated(IFileBuffer buffer) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#bufferContentAboutToBeReplaced(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void bufferContentAboutToBeReplaced(IFileBuffer buffer) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#bufferContentReplaced(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void bufferContentReplaced(IFileBuffer buffer) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#stateChanging(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void stateChanging(IFileBuffer buffer) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#stateValidationChanged(org.eclipse.core.filebuffers.IFileBuffer, boolean)
+     */
+    @Override
+    public void stateValidationChanged(IFileBuffer buffer, boolean isStateValidated) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#underlyingFileMoved(org.eclipse.core.filebuffers.IFileBuffer, org.eclipse.core.runtime.IPath)
+     */
+    @Override
+    public void underlyingFileMoved(IFileBuffer buffer, IPath path) {
+        //is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#underlyingFileDeleted(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void underlyingFileDeleted(IFileBuffer buffer) {
+        //is not used here
+    }
+
+    /**
+     * @see org.eclipse.core.filebuffers.IFileBufferListener#stateChangeFailed(org.eclipse.core.filebuffers.IFileBuffer)
+     */
+    @Override
+    public void stateChangeFailed(IFileBuffer buffer) {
+        //is not used here
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partInputChanged(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partInputChanged(IWorkbenchPartReference partRef) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partActivated(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partActivated(IWorkbenchPartReference partRef) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partBroughtToTop(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partBroughtToTop(IWorkbenchPartReference partRef) {
+        // is not used here
+    }
+
+    /**
+     * @see org.eclipse.ui.IPartListener2#partDeactivated(org.eclipse.ui.IWorkbenchPartReference)
+     */
+    @Override
+    public void partDeactivated(IWorkbenchPartReference partRef) {
+        // is not used here
+    }
+
+
+
+
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/HelpUtils.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/HelpUtils.java
new file mode 100644
index 0000000..16b5d6b
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/HelpUtils.java
@@ -0,0 +1,192 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Scanner;
+
+import org.objectweb.asm.util.Printer;
+
+public class HelpUtils {
+    // TODO: configure it via preference
+    private static final String SPECS_HTML = "https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-6.html";
+    private static String fullSpec;
+    private static String htmlHead;
+
+    private static String checkOpcodeName(String opcodeName) {
+        opcodeName = opcodeName.toLowerCase();
+        /*
+         * we need an additional check for DCONST_1...5, FCONST_1...5 etc case
+         * to convert it to DCONST_D etc
+         */
+        int sepIndex = opcodeName.indexOf('_');
+        if(sepIndex > 0) {
+            if (Character.isDigit(opcodeName.charAt(sepIndex + 1))) {
+                opcodeName = opcodeName.substring(0, sepIndex);
+                switch(opcodeName.charAt(0)){
+                    case 'd':
+                        opcodeName += "_<d&gt;";
+                        break;
+                    case 'f':
+                        opcodeName += "_<f&gt;";
+                        break;
+                    case 'l':
+                        opcodeName += "_<l&gt;";
+                        break;
+                    default:
+                        // ICONST uses "n"
+                        opcodeName += "_<n&gt;";
+                        break;
+                }
+            }
+            if(opcodeName.startsWith("if_acmp")) {
+                opcodeName = "if_acmp<cond&gt;";
+            } else
+            if(opcodeName.startsWith("if_icmp")) {
+                opcodeName = "if_icmp<cond&gt;";
+            } else
+            if(opcodeName.startsWith("if_")) {
+                opcodeName = "if<cond&gt;";
+            } else
+            if(opcodeName.startsWith("aload_")) {
+                opcodeName = "aload_<n&gt;";
+            } else
+            if(opcodeName.startsWith("iconst_")) {
+                opcodeName = "iconst_<i&gt;";
+            }
+        }  else
+            if(opcodeName.startsWith("if")) {
+                opcodeName = "if<cond&gt;";
+            }
+        return opcodeName;
+    }
+
+    private static String getOpcodeName(int opcode) {
+        if(opcode < 0 || opcode >= Printer.OPCODES.length) {
+            return null;
+        }
+        String opcodeName = Printer.OPCODES[opcode];
+        if(opcodeName == null) {
+            return null;
+        }
+        return opcodeName;
+    }
+
+    private static URL toUrl(String href) {
+        try {
+            return new URL(href);
+        } catch (MalformedURLException e) {
+            return null;
+        }
+    }
+
+    public static URL getHelpIndex() {
+        return toUrl(SPECS_HTML);
+    }
+
+    private static String readFullSpec() {
+        URL helpResource = toUrl(SPECS_HTML);
+        StringBuilder sb = new StringBuilder();
+        try (BufferedReader in = new BufferedReader(new InputStreamReader(helpResource.openStream(), "UTF-8"))){
+            String line;
+            while ((line = in.readLine()) != null) {
+                    sb.append(line).append('\n');
+            }
+        } catch (IOException e) {
+            sb.append("Error trying access JVM specification at ").append(SPECS_HTML);
+            sb.append(":");
+            sb.append(e);
+        }
+        return sb.toString();
+    }
+
+    public static StringBuilder getOpcodeHelpFor(int opcode) {
+        if(fullSpec == null) {
+            fullSpec = readFullSpec();
+            htmlHead = readHtmlHead();
+        }
+        StringBuilder sb = new StringBuilder();
+        String opcodeName = getOpcodeName(opcode);
+        if(opcodeName == null) {
+            return sb;
+        }
+        return getOpcodeHelpFor(opcodeName);
+    }
+
+    public static StringBuilder getOpcodeHelpFor(String opcodeName) {
+        if(fullSpec == null) {
+            fullSpec = readFullSpec();
+            htmlHead = readHtmlHead();
+        }
+        StringBuilder sb = new StringBuilder();
+        if (opcodeName != null) {
+            opcodeName = checkOpcodeName(opcodeName);
+        }
+        sb.append(htmlHead);
+
+        // Extract only important part related to the given opcode
+        String patternStart = "<div class=\"section-execution\" title=\"" + opcodeName + "\"";
+        String patternEnd = "<div class=\"section-execution\" title=\"";
+        try (Scanner in = new Scanner(fullSpec)){
+            String line;
+            boolean foundStart = false;
+            boolean checkEnd = false;
+            while (in.hasNextLine()) {
+                line = in.nextLine();
+                if(checkEnd && line.contains(patternEnd)) {
+                    break;
+                }
+                if(!foundStart && line.contains(patternStart)) {
+                    foundStart = true;
+                    checkEnd = true;
+                }
+                if(foundStart) {
+                    sb.append(line);
+                }
+            }
+        }
+
+        // Allow navigation relative to the document
+        int endHeadIdx= sb.indexOf("</head>"); //$NON-NLS-1$
+        if(endHeadIdx > 0) {
+            sb.insert(endHeadIdx, "\n<base href='" + SPECS_HTML + "'>\n");
+        }
+        sb.append("</body></html>");
+        return sb;
+    }
+
+    private static String readHtmlHead() {
+        StringBuilder sb = new StringBuilder();
+        if(fullSpec == null) {
+            return sb.toString();
+        }
+        try (Scanner in = new Scanner(fullSpec)){
+            String line;
+            while (in.hasNextLine()) {
+                line = in.nextLine();
+                if(line.contains("<body")) {
+                    sb.append(line.substring(0, line.indexOf("<body")));
+                    break;
+                }
+                sb.append(line);
+            }
+        }
+        return sb.toString();
+    }
+
+}
diff --git a/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/IBytecodePart.java b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/IBytecodePart.java
new file mode 100644
index 0000000..bb26716
--- /dev/null
+++ b/org.eclipse.jdt.bcoview/src/org/eclipse/jdt/bcoview/views/IBytecodePart.java
@@ -0,0 +1,18 @@
+/*******************************************************************************
+ * Copyright (c) 2018 Andrey Loskutov and others.
+ *
+ * This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License 2.0
+ * which accompanies this distribution, and is available at
+ * https://www.eclipse.org/legal/epl-2.0/
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ *
+ * Contributors:
+ *     Andrey Loskutov - initial API and implementation
+ *******************************************************************************/
+package org.eclipse.jdt.bcoview.views;
+
+public interface IBytecodePart {
+    public int getBytecodeInstructionAtLine(int line);
+}
diff --git a/pom.xml b/pom.xml
index 5592fea..3829927 100644
--- a/pom.xml
+++ b/pom.xml
@@ -70,5 +70,8 @@
     <module>org.eclipse.jdt.junit5.runtime</module>
     <module>org.eclipse.jdt.ui.unittest.junit</module>
     <module>org.eclipse.jdt.ui.unittest.junit.feature</module>
+    <module>org.eclipse.jdt.bcoview</module>
+    <module>org.eclipse.jdt.bcoview.feature</module>
+    <module>org.eclipse.jdt.bcoview.tests</module>
   </modules>
 </project>
-- 
1.8.3.1

